/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library line.src.talk_service;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:thrift/thrift.dart';
import 'package:line/line.dart';


abstract class TalkService {

  Future<Map<String, List<ChatRoomAnnouncement>>> getChatRoomAnnouncementsBulk(List<String> chatRoomMids);

  Future<List<ChatRoomAnnouncement>> getChatRoomAnnouncements(String chatRoomMid);

  Future<ChatRoomAnnouncement> createChatRoomAnnouncement(int reqSeq, String chatRoomMid, int type, ChatRoomAnnouncementContents contents);

  Future removeChatRoomAnnouncement(int reqSeq, String chatRoomMid, int announcementSeq);

  Future unsendMessage(int seq, String messageId);

  Future<Group> getGroupWithoutMembers(String groupId);

  Future requestResendMessage(int reqSeq, String senderMid, String messageId);

  Future respondResendMessage(int reqSeq, String receiverMid, String originalMessageId, Message resendMessage, int errorCode);

  Future acceptGroupInvitation(int reqSeq, String groupId);

  Future acceptGroupInvitationByTicket(int reqSeq, String groupMid, String ticketId);

  Future acceptProximityMatches(String sessionId, Set<String> ids);

  Future<List<String>> acquireCallRoute(String to);

  Future<String> acquireCallTicket(String to);

  Future<String> acquireEncryptedAccessToken(int featureType);

  Future<String> addSnsId(int snsIdType, String snsAccessToken);

  Future blockContact(int reqSeq, String id);

  Future blockRecommendation(int reqSeq, String id);

  Future cancelGroupInvitation(int reqSeq, String groupId, List<String> contactIds);

  Future<VerificationSessionData> changeVerificationMethod(String sessionId, int method);

  Future clearIdentityCredential();

  Future clearMessageBox(String channelId, String messageBoxId);

  Future closeProximityMatch(String sessionId);

  Future<Map<String, String>> commitSendMessage(int seq, String messageId, List<String> receiverMids);

  Future<Map<String, String>> commitSendMessages(int seq, List<String> messageIds, List<String> receiverMids);

  Future<Map<String, String>> commitUpdateProfile(int seq, List<int> attrs, List<String> receiverMids);

  Future confirmEmail(String verifier, String pinCode);

  Future<Group> createGroup(int seq, String name, List<String> contactIds);

  Future<String> createQrcodeBase64Image(String url, String characterSet, int imageSize, int x, int y, int width, int height);

  Future<Room> createRoom(int reqSeq, List<String> contactIds);

  Future<String> createSession();

  Future<List<Announcement>> fetchAnnouncements(int lastFetchedIndex);

  Future<List<Message>> fetchMessages(int localTs, int count);

  Future<List<Operation>> fetchOperations(int localRev, int count);

  Future<List<Operation>> fetchOps(int localRev, int count, int globalRev, int individualRev);

  Future<Map<String, Contact>> findAndAddContactsByEmail(int reqSeq, Set<String> emails);

  Future<Map<String, Contact>> findAndAddContactsByMid(int reqSeq, String mid, int type, String reference);

  Future<Group> findGroupByTicketV2(String ticketId);

  Future<Map<String, Contact>> findAndAddContactsByPhone(int reqSeq, Set<String> phones);

  Future<List<FriendRequest>> getFriendRequests(int direction, int lastSeenSeqId);

  Future removeFriendRequest(int direction, String midOrEMid);

  Future<Map<String, Contact>> findAndAddContactsByUserid(int reqSeq, String userid);

  Future<Contact> findContactByUserid(String userid);

  Future<Contact> findContactByUserTicket(String ticketIdWithTag);

  Future<Map<String, Contact>> findContactsByEmail(Set<String> emails);

  Future<Map<String, Contact>> findContactsByPhone(Set<String> phones);

  Future<SnsIdUserStatus> findSnsIdUserStatus(int snsIdType, String snsAccessToken, String udidHash);

  Future finishUpdateVerification(String sessionId);

  Future<Ticket> generateUserTicket(int expirationTime, int maxUseCount);

  Future destroyMessage(int seq, String chatId, String messageId, int sessionId);

  Future<Set<String>> getAcceptedProximityMatches(String sessionId);

  Future<List<String>> getActiveBuddySubscriberIds();

  Future<List<String>> getAllContactIds();

  Future<AuthQrcode> getAuthQrcode(bool keepLoggedIn, String systemName);

  Future<List<String>> getBlockedContactIds();

  Future<RegisterWithPhoneNumberResult> registerWithPhoneNumber(String sessionId, String migrationPincodeSessionId);

  Future<RegisterWithPhoneNumberResult> registerWithPhoneNumberAndPassword(String sessionId, String keynm, String encrypted);

  Future<AnalyticsInfo> getAnalyticsInfo();

  Future reportClientStatistics(int reqSeq, int category, int count);

  Future<String> verifyPhoneNumberForLogin(String verifierFromPhone, String pinCodeForPhone, String verifierFromLogin);

  Future<PhoneVerificationResult> verifyPhoneNumber(String sessionId, String pinCode, String udidHash, String migrationPincodeSessionId, String oldUdidHash);

  Future<List<String>> getBlockedContactIdsByRange(int start, int count);

  Future<List<String>> getBlockedRecommendationIds();

  Future<List<String>> getBuddyBlockerIds();

  Future<Geolocation> getBuddyLocation(String mid, int index);

  Future<List<CompactContact>> getCompactContactsModifiedSince(int timestamp);

  Future<Group> getCompactGroup(String groupId);

  Future<Room> getCompactRoom(String roomId);

  Future<Contact> getContact(String id);

  Future<List<Contact>> getContacts(List<String> ids);

  Future<Contact> getContactWithFriendRequestStatus(String id);

  Future<String> getCountryWithRequestIp();

  Future<List<String>> getFavoriteMids();

  Future<Group> getGroup(String groupId);

  Future<List<String>> getGroupIdsInvited();

  Future<List<String>> getGroupIdsJoined();

  Future<List<Group>> getGroups(List<String> groupIds);

  Future<List<String>> getHiddenContactMids();

  Future<String> getIdentityIdentifier();

  Future<int> getLastAnnouncementIndex();

  Future<int> getLastOpRevision();

  Future<SuggestDictionaryRevisions> getSuggestRevisions();

  Future<List<Message>> getPreviousMessagesV2WithReadCount(String messageBoxId, MessageBoxV2MessageId endMessageId, int messagesCount);

  Future<TMessageBox> getMessageBox(String channelId, String messageBoxId, int lastMessagesCount);

  Future<TMessageBoxWrapUp> getMessageBoxCompactWrapUp(String mid);

  Future<TMessageBoxWrapUpResponse> getMessageBoxCompactWrapUpList(int start, int messageBoxCount);

  Future<List<TMessageBox>> getMessageBoxList(String channelId, int lastMessagesCount);

  Future<List<TMessageBox>> getMessageBoxListByStatus(String channelId, int lastMessagesCount, int status);

  Future<TMessageBoxWrapUp> getMessageBoxWrapUp(String mid);

  Future<TMessageBoxWrapUpResponse> getMessageBoxWrapUpList(int start, int messageBoxCount);

  Future<List<Message>> getMessagesBySequenceNumber(String channelId, String messageBoxId, int startSeq, int endSeq);

  Future<List<Message>> getNextMessages(String messageBoxId, int startSeq, int messagesCount);

  Future<List<int>> getNotificationPolicy(int carrier);

  Future<List<Message>> getPreviousMessages(String messageBoxId, int endSeq, int messagesCount);

  Future<Profile> getProfile();

  Future<ProximityMatchCandidateResult> getProximityMatchCandidateList(String sessionId);

  Future<Set<Contact>> getProximityMatchCandidates(String sessionId);

  Future<List<Message>> getRecentMessages(String messageBoxId, int messagesCount);

  Future<List<String>> getRecommendationIds();

  Future<Room> getRoom(String roomId);

  Future<RSAKey> getRSAKeyInfo(int provider);

  Future<int> getServerTime();

  Future<List<LoginSession>> getSessions();

  Future<Settings> getSettings();

  Future<List<Group>> getGroupsV2(List<String> groupIds);

  Future<Settings> getSettingsAttributes(int attrBitset);

  Future<SystemConfiguration> getSystemConfiguration();

  Future<Ticket> getUserTicket();

  Future<WapInvitation> getWapInvitation(String invitationHash);

  Future invalidateUserTicket();

  Future inviteFriendsBySms(List<String> phoneNumberList);

  Future inviteIntoGroup(int reqSeq, String groupId, List<String> contactIds);

  Future inviteIntoRoom(int reqSeq, String roomId, List<String> contactIds);

  Future inviteViaEmail(int reqSeq, String email, String name);

  Future<bool> isIdentityIdentifierAvailable(int provider, String identifier);

  Future<bool> isUseridAvailable(String userid);

  Future kickoutFromGroup(int reqSeq, String groupId, List<String> contactIds);

  Future<String> reissueGroupTicket(String groupMid);

  Future<Group> findGroupByTicket(String ticketId);

  Future leaveGroup(int reqSeq, String groupId);

  Future leaveRoom(int reqSeq, String roomId);

  Future<String> loginWithIdentityCredential(int identityProvider, String identifier, String password, bool keepLoggedIn, String accessLocation, String systemName, String certificate);

  Future<LoginResult> loginWithIdentityCredentialForCertificate(int identityProvider, String identifier, String password, bool keepLoggedIn, String accessLocation, String systemName, String certificate);

  Future<String> loginWithVerifier(String verifier);

  Future<LoginResult> loginWithVerifierForCerificate(String verifier);

  Future<LoginResult> loginWithVerifierForCertificate(String verifier);

  Future logout();

  Future logoutSession(String tokenKey);

  Future noop();

  Future notifiedRedirect(Map<String, String> paramMap);

  Future<Map<String, String>> notifyBuddyOnAir(int seq, List<String> receiverMids);

  Future notifyIndividualEvent(int notificationStatus, List<String> receiverMids);

  Future notifyInstalled(String udidHash, String applicationTypeWithExtensions);

  Future notifyRegistrationComplete(String udidHash, String applicationTypeWithExtensions);

  Future notifySleep(int lastRev, int badge);

  Future notifyUpdated(int lastRev, DeviceInfo deviceInfo);

  Future<String> openProximityMatch(Location location);

  Future<String> registerBuddyUser(String buddyId, String registrarPassword);

  Future registerBuddyUserid(int seq, String userid);

  Future<String> registerDevice(String sessionId);

  Future<String> registerDeviceWithIdentityCredential(String sessionId, int provider, String identifier, String verifier);

  Future<String> registerDeviceWithoutPhoneNumber(String region, String udidHash, DeviceInfo deviceInfo);

  Future<String> registerDeviceWithoutPhoneNumberWithIdentityCredential(String region, String udidHash, DeviceInfo deviceInfo, int provider, String identifier, String verifier, String mid, String migrationPincodeSessionId);

  Future<bool> registerUserid(int reqSeq, String userid);

  Future<String> registerWapDevice(String invitationHash, String guidHash, String email, DeviceInfo deviceInfo);

  Future<String> registerWithExistingSnsIdAndIdentityCredential(IdentityCredential identityCredential, String region, String udidHash, DeviceInfo deviceInfo);

  Future<RegisterWithSnsIdResult> registerWithSnsId(int snsIdType, String snsAccessToken, String region, String udidHash, DeviceInfo deviceInfo, String mid);

  Future<String> registerWithSnsIdAndIdentityCredential(int snsIdType, String snsAccessToken, IdentityCredential identityCredential, String region, String udidHash, DeviceInfo deviceInfo);

  Future<String> reissueDeviceCredential();

  Future<String> reissueUserTicket(int expirationTime, int maxUseCount);

  Future<List<TMessageReadRange>> getMessageReadRange(List<String> chatIds);

  Future rejectGroupInvitation(int reqSeq, String groupId);

  Future releaseSession();

  Future removeAllMessages(int seq, String lastMessageId);

  Future removeBuddyLocation(String mid, int index);

  Future<bool> removeMessage(String messageId);

  Future<ContactTransition> makeUserAddMyselfAsContact(String contactOwnerMid);

  Future<bool> removeMessageFromMyHome(String messageId);

  Future<String> removeSnsId(int snsIdType);

  Future report(int syncOpRevision, int category, String report);

  Future<List<ContactReportResult>> reportContacts(int syncOpRevision, int category, List<ContactReport> contactReports, int actionType);

  Future reportGroups(int syncOpRevision, List<Group> groups);

  Future reportProfile(int syncOpRevision, Profile profile);

  Future reportRooms(int syncOpRevision, List<Room> rooms);

  Future<Contact> findAndAddContactByMetaTag(int reqSeq, String userid, String reference);

  Future reportSettings(int syncOpRevision, Settings settings);

  Future reportSpam(String chatMid, List<String> memberMids, List<int> spammerReasons, List<String> senderMids, List<String> spamMessageIds, List<String> spamMessages);

  Future reportSpammer(String spammerMid, List<int> spammerReasons, List<String> spamMessageIds);

  Future requestAccountPasswordReset(int provider, String identifier, String locale);

  Future<EmailConfirmationSession> requestEmailConfirmation(EmailConfirmation emailConfirmation);

  Future requestIdentityUnbind(int provider, String identifier);

  Future<EmailConfirmationSession> resendEmailConfirmation(String verifier);

  Future resendPinCode(String sessionId);

  Future resendPinCodeBySMS(String sessionId);

  Future sendChatChecked(int seq, String consumer, String lastMessageId);

  Future<CommitMessageResult> sendMessageAwaitCommit(int seq, Message message);

  Future sendChatRemoved(int seq, String consumer, String lastMessageId);

  Future<Map<String, String>> sendContentPreviewUpdated(int esq, String messageId, List<String> receiverMids);

  Future sendContentReceipt(int seq, String consumer, String messageId);

  Future sendDummyPush();

  Future removeE2EEPublicKey(E2EEPublicKey publicKey);

  Future<E2EENegotiationResult> negotiateE2EEPublicKey(String mid);

  Future<E2EEPublicKey> getE2EEPublicKey(String mid, int version, int keyId);

  Future requestE2EEKeyExchange(int reqSeq, Uint8List temporalPublicKey, E2EEPublicKey publicKey, Uint8List verifier);

  Future<Map<String, E2EEPublicKey>> getLastE2EEPublicKeys(String chatMid);

  Future<E2EEPublicKey> registerE2EEPublicKey(int reqSeq, E2EEPublicKey publicKey);

  Future<List<E2EEPublicKey>> getE2EEPublicKeys();

  Future<List<E2EEPublicKey>> getE2EEPublicKeysEx(bool ignoreE2EEStatus);

  Future<List<Operation>> getReadMessageOpsInBulk(List<String> chatIds);

  Future<Message> sendEvent(int seq, Message message);

  Future<Message> sendMessage(int seq, Message message);

  Future sendMessageIgnored(int seq, String consumer, List<String> messageIds);

  Future sendMessageReceipt(int seq, String consumer, List<String> messageIds);

  Future<Contact> findContactByMetaTag(String userid, String reference);

  Future<Message> sendMessageToMyHome(int seq, Message message);

  Future setBuddyLocation(String mid, int index, Geolocation location);

  Future setIdentityCredential(String identifier, String verifier, int provider);

  Future setNotificationsEnabled(int reqSeq, int type, String target, bool enablement);

  Future<VerificationSessionData> startUpdateVerification(String region, int carrier, String phone, String udidHash, DeviceInfo deviceInfo, String networkCode, String locale);

  Future<VerificationSessionData> startVerification(String region, int carrier, String phone, String udidHash, DeviceInfo deviceInfo, String networkCode, String mid, String locale, SIMInfo simInfo, String oldUdidHash);

  Future updateGroupPreferenceAttribute(int reqSeq, String groupMid, Map<int, String> updatedAttrs);

  Future<Room> createRoomV2(int reqSeq, List<String> contactIds);

  Future storeUpdateProfileAttribute(int seq, int profileAttribute, String value);

  Future<List<SnsFriendContactRegistration>> syncContactBySnsIds(int reqSeq, List<SnsFriendModification> modifications);

  Future<Map<String, ContactRegistration>> syncContacts(int reqSeq, List<ContactModification> localContacts);

  Future<Message> trySendMessage(int seq, Message message);

  Future<List<Message>> getNextMessagesV2(String messageBoxId, MessageBoxV2MessageId startMessageId, int messagesCount);

  Future<TMessageBoxWrapUp> getMessageBoxCompactWrapUpV2(String messageBoxId);

  Future<List<Message>> getRecentMessagesV2(String messageBoxId, int messagesCount);

  Future<Map<String, String>> validateContactsOnBot(List<String> contacts);

  Future tryFriendRequest(String midOrEMid, int method, String friendRequestParams);

  Future unblockContact(int reqSeq, String id);

  Future unblockRecommendation(int reqSeq, String id);

  Future<String> unregisterUserAndDevice();

  Future updateApnsDeviceToken(Uint8List apnsDeviceToken);

  Future updateBuddySetting(String key, String value);

  Future updateC2DMRegistrationId(String registrationId);

  Future updateContactSetting(int reqSeq, String mid, int flag, String value);

  Future updateCustomModeSettings(int customMode, Map<String, String> paramMap);

  Future updateDeviceInfo(String deviceUid, DeviceInfo deviceInfo);

  Future updateGroup(int reqSeq, Group group);

  Future updateNotificationToken(int type, String token);

  Future updateNotificationTokenWithBytes(int type, Uint8List token);

  Future updateProfile(int reqSeq, Profile profile);

  Future updateProfileAttribute(int reqSeq, int attr, String value);

  Future updateRegion(String region);

  Future updateSettings(int reqSeq, Settings settings);

  Future<int> updateSettings2(int reqSeq, Settings settings);

  Future updateSettingsAttribute(int reqSeq, int attr, String value);

  Future<int> updateSettingsAttributes(int reqSeq, int attrBitset, Settings settings);

  Future verifyIdentityCredential(int identityProvider, String identifier, String password);

  Future<UserAuthStatus> verifyIdentityCredentialWithResult(IdentityCredential identityCredential);

  Future<int> verifyPhone(String sessionId, String pinCode, String udidHash);

  Future<String> verifyQrcode(String verifier, String pinCode);
}

class TalkServiceClient implements TalkService {

  TalkServiceClient(TProtocol iprot, [TProtocol oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  TProtocol _iprot;

  TProtocol get iprot => _iprot;

  TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future<Map<String, List<ChatRoomAnnouncement>>> getChatRoomAnnouncementsBulk(List<String> chatRoomMids) async {
    oprot.writeMessageBegin(new TMessage("getChatRoomAnnouncementsBulk", TMessageType.CALL, nextSeqid()));
    getChatRoomAnnouncementsBulk_args args = new getChatRoomAnnouncementsBulk_args();
    args.chatRoomMids = chatRoomMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getChatRoomAnnouncementsBulk_result result = new getChatRoomAnnouncementsBulk_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getChatRoomAnnouncementsBulk failed: unknown result");
  }

  Future<List<ChatRoomAnnouncement>> getChatRoomAnnouncements(String chatRoomMid) async {
    oprot.writeMessageBegin(new TMessage("getChatRoomAnnouncements", TMessageType.CALL, nextSeqid()));
    getChatRoomAnnouncements_args args = new getChatRoomAnnouncements_args();
    args.chatRoomMid = chatRoomMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getChatRoomAnnouncements_result result = new getChatRoomAnnouncements_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getChatRoomAnnouncements failed: unknown result");
  }

  Future<ChatRoomAnnouncement> createChatRoomAnnouncement(int reqSeq, String chatRoomMid, int type, ChatRoomAnnouncementContents contents) async {
    oprot.writeMessageBegin(new TMessage("createChatRoomAnnouncement", TMessageType.CALL, nextSeqid()));
    createChatRoomAnnouncement_args args = new createChatRoomAnnouncement_args();
    args.reqSeq = reqSeq;
    args.chatRoomMid = chatRoomMid;
    args.type = type;
    args.contents = contents;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createChatRoomAnnouncement_result result = new createChatRoomAnnouncement_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createChatRoomAnnouncement failed: unknown result");
  }

  Future removeChatRoomAnnouncement(int reqSeq, String chatRoomMid, int announcementSeq) async {
    oprot.writeMessageBegin(new TMessage("removeChatRoomAnnouncement", TMessageType.CALL, nextSeqid()));
    removeChatRoomAnnouncement_args args = new removeChatRoomAnnouncement_args();
    args.reqSeq = reqSeq;
    args.chatRoomMid = chatRoomMid;
    args.announcementSeq = announcementSeq;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeChatRoomAnnouncement_result result = new removeChatRoomAnnouncement_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future unsendMessage(int seq, String messageId) async {
    oprot.writeMessageBegin(new TMessage("unsendMessage", TMessageType.CALL, nextSeqid()));
    unsendMessage_args args = new unsendMessage_args();
    args.seq = seq;
    args.messageId = messageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    unsendMessage_result result = new unsendMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Group> getGroupWithoutMembers(String groupId) async {
    oprot.writeMessageBegin(new TMessage("getGroupWithoutMembers", TMessageType.CALL, nextSeqid()));
    getGroupWithoutMembers_args args = new getGroupWithoutMembers_args();
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupWithoutMembers_result result = new getGroupWithoutMembers_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupWithoutMembers failed: unknown result");
  }

  Future requestResendMessage(int reqSeq, String senderMid, String messageId) async {
    oprot.writeMessageBegin(new TMessage("requestResendMessage", TMessageType.CALL, nextSeqid()));
    requestResendMessage_args args = new requestResendMessage_args();
    args.reqSeq = reqSeq;
    args.senderMid = senderMid;
    args.messageId = messageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    requestResendMessage_result result = new requestResendMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future respondResendMessage(int reqSeq, String receiverMid, String originalMessageId, Message resendMessage, int errorCode) async {
    oprot.writeMessageBegin(new TMessage("respondResendMessage", TMessageType.CALL, nextSeqid()));
    respondResendMessage_args args = new respondResendMessage_args();
    args.reqSeq = reqSeq;
    args.receiverMid = receiverMid;
    args.originalMessageId = originalMessageId;
    args.resendMessage = resendMessage;
    args.errorCode = errorCode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    respondResendMessage_result result = new respondResendMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future acceptGroupInvitation(int reqSeq, String groupId) async {
    oprot.writeMessageBegin(new TMessage("acceptGroupInvitation", TMessageType.CALL, nextSeqid()));
    acceptGroupInvitation_args args = new acceptGroupInvitation_args();
    args.reqSeq = reqSeq;
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acceptGroupInvitation_result result = new acceptGroupInvitation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future acceptGroupInvitationByTicket(int reqSeq, String groupMid, String ticketId) async {
    oprot.writeMessageBegin(new TMessage("acceptGroupInvitationByTicket", TMessageType.CALL, nextSeqid()));
    acceptGroupInvitationByTicket_args args = new acceptGroupInvitationByTicket_args();
    args.reqSeq = reqSeq;
    args.groupMid = groupMid;
    args.ticketId = ticketId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acceptGroupInvitationByTicket_result result = new acceptGroupInvitationByTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future acceptProximityMatches(String sessionId, Set<String> ids) async {
    oprot.writeMessageBegin(new TMessage("acceptProximityMatches", TMessageType.CALL, nextSeqid()));
    acceptProximityMatches_args args = new acceptProximityMatches_args();
    args.sessionId = sessionId;
    args.ids = ids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acceptProximityMatches_result result = new acceptProximityMatches_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<List<String>> acquireCallRoute(String to) async {
    oprot.writeMessageBegin(new TMessage("acquireCallRoute", TMessageType.CALL, nextSeqid()));
    acquireCallRoute_args args = new acquireCallRoute_args();
    args.to = to;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acquireCallRoute_result result = new acquireCallRoute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "acquireCallRoute failed: unknown result");
  }

  Future<String> acquireCallTicket(String to) async {
    oprot.writeMessageBegin(new TMessage("acquireCallTicket", TMessageType.CALL, nextSeqid()));
    acquireCallTicket_args args = new acquireCallTicket_args();
    args.to = to;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acquireCallTicket_result result = new acquireCallTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "acquireCallTicket failed: unknown result");
  }

  Future<String> acquireEncryptedAccessToken(int featureType) async {
    oprot.writeMessageBegin(new TMessage("acquireEncryptedAccessToken", TMessageType.CALL, nextSeqid()));
    acquireEncryptedAccessToken_args args = new acquireEncryptedAccessToken_args();
    args.featureType = featureType;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acquireEncryptedAccessToken_result result = new acquireEncryptedAccessToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "acquireEncryptedAccessToken failed: unknown result");
  }

  Future<String> addSnsId(int snsIdType, String snsAccessToken) async {
    oprot.writeMessageBegin(new TMessage("addSnsId", TMessageType.CALL, nextSeqid()));
    addSnsId_args args = new addSnsId_args();
    args.snsIdType = snsIdType;
    args.snsAccessToken = snsAccessToken;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    addSnsId_result result = new addSnsId_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "addSnsId failed: unknown result");
  }

  Future blockContact(int reqSeq, String id) async {
    oprot.writeMessageBegin(new TMessage("blockContact", TMessageType.CALL, nextSeqid()));
    blockContact_args args = new blockContact_args();
    args.reqSeq = reqSeq;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    blockContact_result result = new blockContact_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future blockRecommendation(int reqSeq, String id) async {
    oprot.writeMessageBegin(new TMessage("blockRecommendation", TMessageType.CALL, nextSeqid()));
    blockRecommendation_args args = new blockRecommendation_args();
    args.reqSeq = reqSeq;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    blockRecommendation_result result = new blockRecommendation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future cancelGroupInvitation(int reqSeq, String groupId, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("cancelGroupInvitation", TMessageType.CALL, nextSeqid()));
    cancelGroupInvitation_args args = new cancelGroupInvitation_args();
    args.reqSeq = reqSeq;
    args.groupId = groupId;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    cancelGroupInvitation_result result = new cancelGroupInvitation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<VerificationSessionData> changeVerificationMethod(String sessionId, int method) async {
    oprot.writeMessageBegin(new TMessage("changeVerificationMethod", TMessageType.CALL, nextSeqid()));
    changeVerificationMethod_args args = new changeVerificationMethod_args();
    args.sessionId = sessionId;
    args.method = method;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    changeVerificationMethod_result result = new changeVerificationMethod_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "changeVerificationMethod failed: unknown result");
  }

  Future clearIdentityCredential() async {
    oprot.writeMessageBegin(new TMessage("clearIdentityCredential", TMessageType.CALL, nextSeqid()));
    clearIdentityCredential_args args = new clearIdentityCredential_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    clearIdentityCredential_result result = new clearIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future clearMessageBox(String channelId, String messageBoxId) async {
    oprot.writeMessageBegin(new TMessage("clearMessageBox", TMessageType.CALL, nextSeqid()));
    clearMessageBox_args args = new clearMessageBox_args();
    args.channelId = channelId;
    args.messageBoxId = messageBoxId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    clearMessageBox_result result = new clearMessageBox_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future closeProximityMatch(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("closeProximityMatch", TMessageType.CALL, nextSeqid()));
    closeProximityMatch_args args = new closeProximityMatch_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    closeProximityMatch_result result = new closeProximityMatch_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, String>> commitSendMessage(int seq, String messageId, List<String> receiverMids) async {
    oprot.writeMessageBegin(new TMessage("commitSendMessage", TMessageType.CALL, nextSeqid()));
    commitSendMessage_args args = new commitSendMessage_args();
    args.seq = seq;
    args.messageId = messageId;
    args.receiverMids = receiverMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    commitSendMessage_result result = new commitSendMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "commitSendMessage failed: unknown result");
  }

  Future<Map<String, String>> commitSendMessages(int seq, List<String> messageIds, List<String> receiverMids) async {
    oprot.writeMessageBegin(new TMessage("commitSendMessages", TMessageType.CALL, nextSeqid()));
    commitSendMessages_args args = new commitSendMessages_args();
    args.seq = seq;
    args.messageIds = messageIds;
    args.receiverMids = receiverMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    commitSendMessages_result result = new commitSendMessages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "commitSendMessages failed: unknown result");
  }

  Future<Map<String, String>> commitUpdateProfile(int seq, List<int> attrs, List<String> receiverMids) async {
    oprot.writeMessageBegin(new TMessage("commitUpdateProfile", TMessageType.CALL, nextSeqid()));
    commitUpdateProfile_args args = new commitUpdateProfile_args();
    args.seq = seq;
    args.attrs = attrs;
    args.receiverMids = receiverMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    commitUpdateProfile_result result = new commitUpdateProfile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "commitUpdateProfile failed: unknown result");
  }

  Future confirmEmail(String verifier, String pinCode) async {
    oprot.writeMessageBegin(new TMessage("confirmEmail", TMessageType.CALL, nextSeqid()));
    confirmEmail_args args = new confirmEmail_args();
    args.verifier = verifier;
    args.pinCode = pinCode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    confirmEmail_result result = new confirmEmail_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Group> createGroup(int seq, String name, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("createGroup", TMessageType.CALL, nextSeqid()));
    createGroup_args args = new createGroup_args();
    args.seq = seq;
    args.name = name;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createGroup_result result = new createGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createGroup failed: unknown result");
  }

  Future<String> createQrcodeBase64Image(String url, String characterSet, int imageSize, int x, int y, int width, int height) async {
    oprot.writeMessageBegin(new TMessage("createQrcodeBase64Image", TMessageType.CALL, nextSeqid()));
    createQrcodeBase64Image_args args = new createQrcodeBase64Image_args();
    args.url = url;
    args.characterSet = characterSet;
    args.imageSize = imageSize;
    args.x = x;
    args.y = y;
    args.width = width;
    args.height = height;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createQrcodeBase64Image_result result = new createQrcodeBase64Image_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createQrcodeBase64Image failed: unknown result");
  }

  Future<Room> createRoom(int reqSeq, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("createRoom", TMessageType.CALL, nextSeqid()));
    createRoom_args args = new createRoom_args();
    args.reqSeq = reqSeq;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createRoom_result result = new createRoom_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createRoom failed: unknown result");
  }

  Future<String> createSession() async {
    oprot.writeMessageBegin(new TMessage("createSession", TMessageType.CALL, nextSeqid()));
    createSession_args args = new createSession_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createSession_result result = new createSession_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createSession failed: unknown result");
  }

  Future<List<Announcement>> fetchAnnouncements(int lastFetchedIndex) async {
    oprot.writeMessageBegin(new TMessage("fetchAnnouncements", TMessageType.CALL, nextSeqid()));
    fetchAnnouncements_args args = new fetchAnnouncements_args();
    args.lastFetchedIndex = lastFetchedIndex;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    fetchAnnouncements_result result = new fetchAnnouncements_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "fetchAnnouncements failed: unknown result");
  }

  Future<List<Message>> fetchMessages(int localTs, int count) async {
    oprot.writeMessageBegin(new TMessage("fetchMessages", TMessageType.CALL, nextSeqid()));
    fetchMessages_args args = new fetchMessages_args();
    args.localTs = localTs;
    args.count = count;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    fetchMessages_result result = new fetchMessages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "fetchMessages failed: unknown result");
  }

  Future<List<Operation>> fetchOperations(int localRev, int count) async {
    oprot.writeMessageBegin(new TMessage("fetchOperations", TMessageType.CALL, nextSeqid()));
    fetchOperations_args args = new fetchOperations_args();
    args.localRev = localRev;
    args.count = count;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    fetchOperations_result result = new fetchOperations_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "fetchOperations failed: unknown result");
  }

  Future<List<Operation>> fetchOps(int localRev, int count, int globalRev, int individualRev) async {
    oprot.writeMessageBegin(new TMessage("fetchOps", TMessageType.CALL, nextSeqid()));
    fetchOps_args args = new fetchOps_args();
    args.localRev = localRev;
    args.count = count;
    args.globalRev = globalRev;
    args.individualRev = individualRev;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    fetchOps_result result = new fetchOps_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "fetchOps failed: unknown result");
  }

  Future<Map<String, Contact>> findAndAddContactsByEmail(int reqSeq, Set<String> emails) async {
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByEmail", TMessageType.CALL, nextSeqid()));
    findAndAddContactsByEmail_args args = new findAndAddContactsByEmail_args();
    args.reqSeq = reqSeq;
    args.emails = emails;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findAndAddContactsByEmail_result result = new findAndAddContactsByEmail_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findAndAddContactsByEmail failed: unknown result");
  }

  Future<Map<String, Contact>> findAndAddContactsByMid(int reqSeq, String mid, int type, String reference) async {
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByMid", TMessageType.CALL, nextSeqid()));
    findAndAddContactsByMid_args args = new findAndAddContactsByMid_args();
    args.reqSeq = reqSeq;
    args.mid = mid;
    args.type = type;
    args.reference = reference;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findAndAddContactsByMid_result result = new findAndAddContactsByMid_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findAndAddContactsByMid failed: unknown result");
  }

  Future<Group> findGroupByTicketV2(String ticketId) async {
    oprot.writeMessageBegin(new TMessage("findGroupByTicketV2", TMessageType.CALL, nextSeqid()));
    findGroupByTicketV2_args args = new findGroupByTicketV2_args();
    args.ticketId = ticketId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findGroupByTicketV2_result result = new findGroupByTicketV2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findGroupByTicketV2 failed: unknown result");
  }

  Future<Map<String, Contact>> findAndAddContactsByPhone(int reqSeq, Set<String> phones) async {
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByPhone", TMessageType.CALL, nextSeqid()));
    findAndAddContactsByPhone_args args = new findAndAddContactsByPhone_args();
    args.reqSeq = reqSeq;
    args.phones = phones;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findAndAddContactsByPhone_result result = new findAndAddContactsByPhone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findAndAddContactsByPhone failed: unknown result");
  }

  Future<List<FriendRequest>> getFriendRequests(int direction, int lastSeenSeqId) async {
    oprot.writeMessageBegin(new TMessage("getFriendRequests", TMessageType.CALL, nextSeqid()));
    getFriendRequests_args args = new getFriendRequests_args();
    args.direction = direction;
    args.lastSeenSeqId = lastSeenSeqId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getFriendRequests_result result = new getFriendRequests_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getFriendRequests failed: unknown result");
  }

  Future removeFriendRequest(int direction, String midOrEMid) async {
    oprot.writeMessageBegin(new TMessage("removeFriendRequest", TMessageType.CALL, nextSeqid()));
    removeFriendRequest_args args = new removeFriendRequest_args();
    args.direction = direction;
    args.midOrEMid = midOrEMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeFriendRequest_result result = new removeFriendRequest_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, Contact>> findAndAddContactsByUserid(int reqSeq, String userid) async {
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByUserid", TMessageType.CALL, nextSeqid()));
    findAndAddContactsByUserid_args args = new findAndAddContactsByUserid_args();
    args.reqSeq = reqSeq;
    args.userid = userid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findAndAddContactsByUserid_result result = new findAndAddContactsByUserid_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findAndAddContactsByUserid failed: unknown result");
  }

  Future<Contact> findContactByUserid(String userid) async {
    oprot.writeMessageBegin(new TMessage("findContactByUserid", TMessageType.CALL, nextSeqid()));
    findContactByUserid_args args = new findContactByUserid_args();
    args.userid = userid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findContactByUserid_result result = new findContactByUserid_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findContactByUserid failed: unknown result");
  }

  Future<Contact> findContactByUserTicket(String ticketIdWithTag) async {
    oprot.writeMessageBegin(new TMessage("findContactByUserTicket", TMessageType.CALL, nextSeqid()));
    findContactByUserTicket_args args = new findContactByUserTicket_args();
    args.ticketIdWithTag = ticketIdWithTag;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findContactByUserTicket_result result = new findContactByUserTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findContactByUserTicket failed: unknown result");
  }

  Future<Map<String, Contact>> findContactsByEmail(Set<String> emails) async {
    oprot.writeMessageBegin(new TMessage("findContactsByEmail", TMessageType.CALL, nextSeqid()));
    findContactsByEmail_args args = new findContactsByEmail_args();
    args.emails = emails;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findContactsByEmail_result result = new findContactsByEmail_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findContactsByEmail failed: unknown result");
  }

  Future<Map<String, Contact>> findContactsByPhone(Set<String> phones) async {
    oprot.writeMessageBegin(new TMessage("findContactsByPhone", TMessageType.CALL, nextSeqid()));
    findContactsByPhone_args args = new findContactsByPhone_args();
    args.phones = phones;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findContactsByPhone_result result = new findContactsByPhone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findContactsByPhone failed: unknown result");
  }

  Future<SnsIdUserStatus> findSnsIdUserStatus(int snsIdType, String snsAccessToken, String udidHash) async {
    oprot.writeMessageBegin(new TMessage("findSnsIdUserStatus", TMessageType.CALL, nextSeqid()));
    findSnsIdUserStatus_args args = new findSnsIdUserStatus_args();
    args.snsIdType = snsIdType;
    args.snsAccessToken = snsAccessToken;
    args.udidHash = udidHash;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findSnsIdUserStatus_result result = new findSnsIdUserStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findSnsIdUserStatus failed: unknown result");
  }

  Future finishUpdateVerification(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("finishUpdateVerification", TMessageType.CALL, nextSeqid()));
    finishUpdateVerification_args args = new finishUpdateVerification_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    finishUpdateVerification_result result = new finishUpdateVerification_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Ticket> generateUserTicket(int expirationTime, int maxUseCount) async {
    oprot.writeMessageBegin(new TMessage("generateUserTicket", TMessageType.CALL, nextSeqid()));
    generateUserTicket_args args = new generateUserTicket_args();
    args.expirationTime = expirationTime;
    args.maxUseCount = maxUseCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    generateUserTicket_result result = new generateUserTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "generateUserTicket failed: unknown result");
  }

  Future destroyMessage(int seq, String chatId, String messageId, int sessionId) async {
    oprot.writeMessageBegin(new TMessage("destroyMessage", TMessageType.CALL, nextSeqid()));
    destroyMessage_args args = new destroyMessage_args();
    args.seq = seq;
    args.chatId = chatId;
    args.messageId = messageId;
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    destroyMessage_result result = new destroyMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Set<String>> getAcceptedProximityMatches(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("getAcceptedProximityMatches", TMessageType.CALL, nextSeqid()));
    getAcceptedProximityMatches_args args = new getAcceptedProximityMatches_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getAcceptedProximityMatches_result result = new getAcceptedProximityMatches_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getAcceptedProximityMatches failed: unknown result");
  }

  Future<List<String>> getActiveBuddySubscriberIds() async {
    oprot.writeMessageBegin(new TMessage("getActiveBuddySubscriberIds", TMessageType.CALL, nextSeqid()));
    getActiveBuddySubscriberIds_args args = new getActiveBuddySubscriberIds_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getActiveBuddySubscriberIds_result result = new getActiveBuddySubscriberIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getActiveBuddySubscriberIds failed: unknown result");
  }

  Future<List<String>> getAllContactIds() async {
    oprot.writeMessageBegin(new TMessage("getAllContactIds", TMessageType.CALL, nextSeqid()));
    getAllContactIds_args args = new getAllContactIds_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getAllContactIds_result result = new getAllContactIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getAllContactIds failed: unknown result");
  }

  Future<AuthQrcode> getAuthQrcode(bool keepLoggedIn, String systemName) async {
    oprot.writeMessageBegin(new TMessage("getAuthQrcode", TMessageType.CALL, nextSeqid()));
    getAuthQrcode_args args = new getAuthQrcode_args();
    args.keepLoggedIn = keepLoggedIn;
    args.systemName = systemName;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getAuthQrcode_result result = new getAuthQrcode_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getAuthQrcode failed: unknown result");
  }

  Future<List<String>> getBlockedContactIds() async {
    oprot.writeMessageBegin(new TMessage("getBlockedContactIds", TMessageType.CALL, nextSeqid()));
    getBlockedContactIds_args args = new getBlockedContactIds_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getBlockedContactIds_result result = new getBlockedContactIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getBlockedContactIds failed: unknown result");
  }

  Future<RegisterWithPhoneNumberResult> registerWithPhoneNumber(String sessionId, String migrationPincodeSessionId) async {
    oprot.writeMessageBegin(new TMessage("registerWithPhoneNumber", TMessageType.CALL, nextSeqid()));
    registerWithPhoneNumber_args args = new registerWithPhoneNumber_args();
    args.sessionId = sessionId;
    args.migrationPincodeSessionId = migrationPincodeSessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerWithPhoneNumber_result result = new registerWithPhoneNumber_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerWithPhoneNumber failed: unknown result");
  }

  Future<RegisterWithPhoneNumberResult> registerWithPhoneNumberAndPassword(String sessionId, String keynm, String encrypted) async {
    oprot.writeMessageBegin(new TMessage("registerWithPhoneNumberAndPassword", TMessageType.CALL, nextSeqid()));
    registerWithPhoneNumberAndPassword_args args = new registerWithPhoneNumberAndPassword_args();
    args.sessionId = sessionId;
    args.keynm = keynm;
    args.encrypted = encrypted;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerWithPhoneNumberAndPassword_result result = new registerWithPhoneNumberAndPassword_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerWithPhoneNumberAndPassword failed: unknown result");
  }

  Future<AnalyticsInfo> getAnalyticsInfo() async {
    oprot.writeMessageBegin(new TMessage("getAnalyticsInfo", TMessageType.CALL, nextSeqid()));
    getAnalyticsInfo_args args = new getAnalyticsInfo_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getAnalyticsInfo_result result = new getAnalyticsInfo_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getAnalyticsInfo failed: unknown result");
  }

  Future reportClientStatistics(int reqSeq, int category, int count) async {
    oprot.writeMessageBegin(new TMessage("reportClientStatistics", TMessageType.CALL, nextSeqid()));
    reportClientStatistics_args args = new reportClientStatistics_args();
    args.reqSeq = reqSeq;
    args.category = category;
    args.count = count;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportClientStatistics_result result = new reportClientStatistics_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> verifyPhoneNumberForLogin(String verifierFromPhone, String pinCodeForPhone, String verifierFromLogin) async {
    oprot.writeMessageBegin(new TMessage("verifyPhoneNumberForLogin", TMessageType.CALL, nextSeqid()));
    verifyPhoneNumberForLogin_args args = new verifyPhoneNumberForLogin_args();
    args.verifierFromPhone = verifierFromPhone;
    args.pinCodeForPhone = pinCodeForPhone;
    args.verifierFromLogin = verifierFromLogin;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyPhoneNumberForLogin_result result = new verifyPhoneNumberForLogin_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "verifyPhoneNumberForLogin failed: unknown result");
  }

  Future<PhoneVerificationResult> verifyPhoneNumber(String sessionId, String pinCode, String udidHash, String migrationPincodeSessionId, String oldUdidHash) async {
    oprot.writeMessageBegin(new TMessage("verifyPhoneNumber", TMessageType.CALL, nextSeqid()));
    verifyPhoneNumber_args args = new verifyPhoneNumber_args();
    args.sessionId = sessionId;
    args.pinCode = pinCode;
    args.udidHash = udidHash;
    args.migrationPincodeSessionId = migrationPincodeSessionId;
    args.oldUdidHash = oldUdidHash;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyPhoneNumber_result result = new verifyPhoneNumber_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "verifyPhoneNumber failed: unknown result");
  }

  Future<List<String>> getBlockedContactIdsByRange(int start, int count) async {
    oprot.writeMessageBegin(new TMessage("getBlockedContactIdsByRange", TMessageType.CALL, nextSeqid()));
    getBlockedContactIdsByRange_args args = new getBlockedContactIdsByRange_args();
    args.start = start;
    args.count = count;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getBlockedContactIdsByRange_result result = new getBlockedContactIdsByRange_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getBlockedContactIdsByRange failed: unknown result");
  }

  Future<List<String>> getBlockedRecommendationIds() async {
    oprot.writeMessageBegin(new TMessage("getBlockedRecommendationIds", TMessageType.CALL, nextSeqid()));
    getBlockedRecommendationIds_args args = new getBlockedRecommendationIds_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getBlockedRecommendationIds_result result = new getBlockedRecommendationIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getBlockedRecommendationIds failed: unknown result");
  }

  Future<List<String>> getBuddyBlockerIds() async {
    oprot.writeMessageBegin(new TMessage("getBuddyBlockerIds", TMessageType.CALL, nextSeqid()));
    getBuddyBlockerIds_args args = new getBuddyBlockerIds_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getBuddyBlockerIds_result result = new getBuddyBlockerIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getBuddyBlockerIds failed: unknown result");
  }

  Future<Geolocation> getBuddyLocation(String mid, int index) async {
    oprot.writeMessageBegin(new TMessage("getBuddyLocation", TMessageType.CALL, nextSeqid()));
    getBuddyLocation_args args = new getBuddyLocation_args();
    args.mid = mid;
    args.index = index;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getBuddyLocation_result result = new getBuddyLocation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getBuddyLocation failed: unknown result");
  }

  Future<List<CompactContact>> getCompactContactsModifiedSince(int timestamp) async {
    oprot.writeMessageBegin(new TMessage("getCompactContactsModifiedSince", TMessageType.CALL, nextSeqid()));
    getCompactContactsModifiedSince_args args = new getCompactContactsModifiedSince_args();
    args.timestamp = timestamp;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCompactContactsModifiedSince_result result = new getCompactContactsModifiedSince_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCompactContactsModifiedSince failed: unknown result");
  }

  Future<Group> getCompactGroup(String groupId) async {
    oprot.writeMessageBegin(new TMessage("getCompactGroup", TMessageType.CALL, nextSeqid()));
    getCompactGroup_args args = new getCompactGroup_args();
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCompactGroup_result result = new getCompactGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCompactGroup failed: unknown result");
  }

  Future<Room> getCompactRoom(String roomId) async {
    oprot.writeMessageBegin(new TMessage("getCompactRoom", TMessageType.CALL, nextSeqid()));
    getCompactRoom_args args = new getCompactRoom_args();
    args.roomId = roomId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCompactRoom_result result = new getCompactRoom_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCompactRoom failed: unknown result");
  }

  Future<Contact> getContact(String id) async {
    oprot.writeMessageBegin(new TMessage("getContact", TMessageType.CALL, nextSeqid()));
    getContact_args args = new getContact_args();
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getContact_result result = new getContact_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getContact failed: unknown result");
  }

  Future<List<Contact>> getContacts(List<String> ids) async {
    oprot.writeMessageBegin(new TMessage("getContacts", TMessageType.CALL, nextSeqid()));
    getContacts_args args = new getContacts_args();
    args.ids = ids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getContacts_result result = new getContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getContacts failed: unknown result");
  }

  Future<Contact> getContactWithFriendRequestStatus(String id) async {
    oprot.writeMessageBegin(new TMessage("getContactWithFriendRequestStatus", TMessageType.CALL, nextSeqid()));
    getContactWithFriendRequestStatus_args args = new getContactWithFriendRequestStatus_args();
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getContactWithFriendRequestStatus_result result = new getContactWithFriendRequestStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getContactWithFriendRequestStatus failed: unknown result");
  }

  Future<String> getCountryWithRequestIp() async {
    oprot.writeMessageBegin(new TMessage("getCountryWithRequestIp", TMessageType.CALL, nextSeqid()));
    getCountryWithRequestIp_args args = new getCountryWithRequestIp_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCountryWithRequestIp_result result = new getCountryWithRequestIp_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCountryWithRequestIp failed: unknown result");
  }

  Future<List<String>> getFavoriteMids() async {
    oprot.writeMessageBegin(new TMessage("getFavoriteMids", TMessageType.CALL, nextSeqid()));
    getFavoriteMids_args args = new getFavoriteMids_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getFavoriteMids_result result = new getFavoriteMids_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getFavoriteMids failed: unknown result");
  }

  Future<Group> getGroup(String groupId) async {
    oprot.writeMessageBegin(new TMessage("getGroup", TMessageType.CALL, nextSeqid()));
    getGroup_args args = new getGroup_args();
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroup_result result = new getGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroup failed: unknown result");
  }

  Future<List<String>> getGroupIdsInvited() async {
    oprot.writeMessageBegin(new TMessage("getGroupIdsInvited", TMessageType.CALL, nextSeqid()));
    getGroupIdsInvited_args args = new getGroupIdsInvited_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupIdsInvited_result result = new getGroupIdsInvited_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupIdsInvited failed: unknown result");
  }

  Future<List<String>> getGroupIdsJoined() async {
    oprot.writeMessageBegin(new TMessage("getGroupIdsJoined", TMessageType.CALL, nextSeqid()));
    getGroupIdsJoined_args args = new getGroupIdsJoined_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupIdsJoined_result result = new getGroupIdsJoined_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupIdsJoined failed: unknown result");
  }

  Future<List<Group>> getGroups(List<String> groupIds) async {
    oprot.writeMessageBegin(new TMessage("getGroups", TMessageType.CALL, nextSeqid()));
    getGroups_args args = new getGroups_args();
    args.groupIds = groupIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroups_result result = new getGroups_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroups failed: unknown result");
  }

  Future<List<String>> getHiddenContactMids() async {
    oprot.writeMessageBegin(new TMessage("getHiddenContactMids", TMessageType.CALL, nextSeqid()));
    getHiddenContactMids_args args = new getHiddenContactMids_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getHiddenContactMids_result result = new getHiddenContactMids_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getHiddenContactMids failed: unknown result");
  }

  Future<String> getIdentityIdentifier() async {
    oprot.writeMessageBegin(new TMessage("getIdentityIdentifier", TMessageType.CALL, nextSeqid()));
    getIdentityIdentifier_args args = new getIdentityIdentifier_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getIdentityIdentifier_result result = new getIdentityIdentifier_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getIdentityIdentifier failed: unknown result");
  }

  Future<int> getLastAnnouncementIndex() async {
    oprot.writeMessageBegin(new TMessage("getLastAnnouncementIndex", TMessageType.CALL, nextSeqid()));
    getLastAnnouncementIndex_args args = new getLastAnnouncementIndex_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getLastAnnouncementIndex_result result = new getLastAnnouncementIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getLastAnnouncementIndex failed: unknown result");
  }

  Future<int> getLastOpRevision() async {
    oprot.writeMessageBegin(new TMessage("getLastOpRevision", TMessageType.CALL, nextSeqid()));
    getLastOpRevision_args args = new getLastOpRevision_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getLastOpRevision_result result = new getLastOpRevision_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getLastOpRevision failed: unknown result");
  }

  Future<SuggestDictionaryRevisions> getSuggestRevisions() async {
    oprot.writeMessageBegin(new TMessage("getSuggestRevisions", TMessageType.CALL, nextSeqid()));
    getSuggestRevisions_args args = new getSuggestRevisions_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSuggestRevisions_result result = new getSuggestRevisions_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getSuggestRevisions failed: unknown result");
  }

  Future<List<Message>> getPreviousMessagesV2WithReadCount(String messageBoxId, MessageBoxV2MessageId endMessageId, int messagesCount) async {
    oprot.writeMessageBegin(new TMessage("getPreviousMessagesV2WithReadCount", TMessageType.CALL, nextSeqid()));
    getPreviousMessagesV2WithReadCount_args args = new getPreviousMessagesV2WithReadCount_args();
    args.messageBoxId = messageBoxId;
    args.endMessageId = endMessageId;
    args.messagesCount = messagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPreviousMessagesV2WithReadCount_result result = new getPreviousMessagesV2WithReadCount_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPreviousMessagesV2WithReadCount failed: unknown result");
  }

  Future<TMessageBox> getMessageBox(String channelId, String messageBoxId, int lastMessagesCount) async {
    oprot.writeMessageBegin(new TMessage("getMessageBox", TMessageType.CALL, nextSeqid()));
    getMessageBox_args args = new getMessageBox_args();
    args.channelId = channelId;
    args.messageBoxId = messageBoxId;
    args.lastMessagesCount = lastMessagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBox_result result = new getMessageBox_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBox failed: unknown result");
  }

  Future<TMessageBoxWrapUp> getMessageBoxCompactWrapUp(String mid) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUp", TMessageType.CALL, nextSeqid()));
    getMessageBoxCompactWrapUp_args args = new getMessageBoxCompactWrapUp_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxCompactWrapUp_result result = new getMessageBoxCompactWrapUp_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxCompactWrapUp failed: unknown result");
  }

  Future<TMessageBoxWrapUpResponse> getMessageBoxCompactWrapUpList(int start, int messageBoxCount) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUpList", TMessageType.CALL, nextSeqid()));
    getMessageBoxCompactWrapUpList_args args = new getMessageBoxCompactWrapUpList_args();
    args.start = start;
    args.messageBoxCount = messageBoxCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxCompactWrapUpList_result result = new getMessageBoxCompactWrapUpList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxCompactWrapUpList failed: unknown result");
  }

  Future<List<TMessageBox>> getMessageBoxList(String channelId, int lastMessagesCount) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxList", TMessageType.CALL, nextSeqid()));
    getMessageBoxList_args args = new getMessageBoxList_args();
    args.channelId = channelId;
    args.lastMessagesCount = lastMessagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxList_result result = new getMessageBoxList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxList failed: unknown result");
  }

  Future<List<TMessageBox>> getMessageBoxListByStatus(String channelId, int lastMessagesCount, int status) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxListByStatus", TMessageType.CALL, nextSeqid()));
    getMessageBoxListByStatus_args args = new getMessageBoxListByStatus_args();
    args.channelId = channelId;
    args.lastMessagesCount = lastMessagesCount;
    args.status = status;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxListByStatus_result result = new getMessageBoxListByStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxListByStatus failed: unknown result");
  }

  Future<TMessageBoxWrapUp> getMessageBoxWrapUp(String mid) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxWrapUp", TMessageType.CALL, nextSeqid()));
    getMessageBoxWrapUp_args args = new getMessageBoxWrapUp_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxWrapUp_result result = new getMessageBoxWrapUp_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxWrapUp failed: unknown result");
  }

  Future<TMessageBoxWrapUpResponse> getMessageBoxWrapUpList(int start, int messageBoxCount) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxWrapUpList", TMessageType.CALL, nextSeqid()));
    getMessageBoxWrapUpList_args args = new getMessageBoxWrapUpList_args();
    args.start = start;
    args.messageBoxCount = messageBoxCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxWrapUpList_result result = new getMessageBoxWrapUpList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxWrapUpList failed: unknown result");
  }

  Future<List<Message>> getMessagesBySequenceNumber(String channelId, String messageBoxId, int startSeq, int endSeq) async {
    oprot.writeMessageBegin(new TMessage("getMessagesBySequenceNumber", TMessageType.CALL, nextSeqid()));
    getMessagesBySequenceNumber_args args = new getMessagesBySequenceNumber_args();
    args.channelId = channelId;
    args.messageBoxId = messageBoxId;
    args.startSeq = startSeq;
    args.endSeq = endSeq;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessagesBySequenceNumber_result result = new getMessagesBySequenceNumber_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessagesBySequenceNumber failed: unknown result");
  }

  Future<List<Message>> getNextMessages(String messageBoxId, int startSeq, int messagesCount) async {
    oprot.writeMessageBegin(new TMessage("getNextMessages", TMessageType.CALL, nextSeqid()));
    getNextMessages_args args = new getNextMessages_args();
    args.messageBoxId = messageBoxId;
    args.startSeq = startSeq;
    args.messagesCount = messagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getNextMessages_result result = new getNextMessages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getNextMessages failed: unknown result");
  }

  Future<List<int>> getNotificationPolicy(int carrier) async {
    oprot.writeMessageBegin(new TMessage("getNotificationPolicy", TMessageType.CALL, nextSeqid()));
    getNotificationPolicy_args args = new getNotificationPolicy_args();
    args.carrier = carrier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getNotificationPolicy_result result = new getNotificationPolicy_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getNotificationPolicy failed: unknown result");
  }

  Future<List<Message>> getPreviousMessages(String messageBoxId, int endSeq, int messagesCount) async {
    oprot.writeMessageBegin(new TMessage("getPreviousMessages", TMessageType.CALL, nextSeqid()));
    getPreviousMessages_args args = new getPreviousMessages_args();
    args.messageBoxId = messageBoxId;
    args.endSeq = endSeq;
    args.messagesCount = messagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPreviousMessages_result result = new getPreviousMessages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPreviousMessages failed: unknown result");
  }

  Future<Profile> getProfile() async {
    oprot.writeMessageBegin(new TMessage("getProfile", TMessageType.CALL, nextSeqid()));
    getProfile_args args = new getProfile_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProfile_result result = new getProfile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProfile failed: unknown result");
  }

  Future<ProximityMatchCandidateResult> getProximityMatchCandidateList(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("getProximityMatchCandidateList", TMessageType.CALL, nextSeqid()));
    getProximityMatchCandidateList_args args = new getProximityMatchCandidateList_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProximityMatchCandidateList_result result = new getProximityMatchCandidateList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProximityMatchCandidateList failed: unknown result");
  }

  Future<Set<Contact>> getProximityMatchCandidates(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("getProximityMatchCandidates", TMessageType.CALL, nextSeqid()));
    getProximityMatchCandidates_args args = new getProximityMatchCandidates_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProximityMatchCandidates_result result = new getProximityMatchCandidates_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProximityMatchCandidates failed: unknown result");
  }

  Future<List<Message>> getRecentMessages(String messageBoxId, int messagesCount) async {
    oprot.writeMessageBegin(new TMessage("getRecentMessages", TMessageType.CALL, nextSeqid()));
    getRecentMessages_args args = new getRecentMessages_args();
    args.messageBoxId = messageBoxId;
    args.messagesCount = messagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRecentMessages_result result = new getRecentMessages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRecentMessages failed: unknown result");
  }

  Future<List<String>> getRecommendationIds() async {
    oprot.writeMessageBegin(new TMessage("getRecommendationIds", TMessageType.CALL, nextSeqid()));
    getRecommendationIds_args args = new getRecommendationIds_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRecommendationIds_result result = new getRecommendationIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRecommendationIds failed: unknown result");
  }

  Future<Room> getRoom(String roomId) async {
    oprot.writeMessageBegin(new TMessage("getRoom", TMessageType.CALL, nextSeqid()));
    getRoom_args args = new getRoom_args();
    args.roomId = roomId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRoom_result result = new getRoom_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRoom failed: unknown result");
  }

  Future<RSAKey> getRSAKeyInfo(int provider) async {
    oprot.writeMessageBegin(new TMessage("getRSAKeyInfo", TMessageType.CALL, nextSeqid()));
    getRSAKeyInfo_args args = new getRSAKeyInfo_args();
    args.provider = provider;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRSAKeyInfo_result result = new getRSAKeyInfo_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRSAKeyInfo failed: unknown result");
  }

  Future<int> getServerTime() async {
    oprot.writeMessageBegin(new TMessage("getServerTime", TMessageType.CALL, nextSeqid()));
    getServerTime_args args = new getServerTime_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getServerTime_result result = new getServerTime_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getServerTime failed: unknown result");
  }

  Future<List<LoginSession>> getSessions() async {
    oprot.writeMessageBegin(new TMessage("getSessions", TMessageType.CALL, nextSeqid()));
    getSessions_args args = new getSessions_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSessions_result result = new getSessions_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getSessions failed: unknown result");
  }

  Future<Settings> getSettings() async {
    oprot.writeMessageBegin(new TMessage("getSettings", TMessageType.CALL, nextSeqid()));
    getSettings_args args = new getSettings_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSettings_result result = new getSettings_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getSettings failed: unknown result");
  }

  Future<List<Group>> getGroupsV2(List<String> groupIds) async {
    oprot.writeMessageBegin(new TMessage("getGroupsV2", TMessageType.CALL, nextSeqid()));
    getGroupsV2_args args = new getGroupsV2_args();
    args.groupIds = groupIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupsV2_result result = new getGroupsV2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupsV2 failed: unknown result");
  }

  Future<Settings> getSettingsAttributes(int attrBitset) async {
    oprot.writeMessageBegin(new TMessage("getSettingsAttributes", TMessageType.CALL, nextSeqid()));
    getSettingsAttributes_args args = new getSettingsAttributes_args();
    args.attrBitset = attrBitset;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSettingsAttributes_result result = new getSettingsAttributes_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getSettingsAttributes failed: unknown result");
  }

  Future<SystemConfiguration> getSystemConfiguration() async {
    oprot.writeMessageBegin(new TMessage("getSystemConfiguration", TMessageType.CALL, nextSeqid()));
    getSystemConfiguration_args args = new getSystemConfiguration_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSystemConfiguration_result result = new getSystemConfiguration_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getSystemConfiguration failed: unknown result");
  }

  Future<Ticket> getUserTicket() async {
    oprot.writeMessageBegin(new TMessage("getUserTicket", TMessageType.CALL, nextSeqid()));
    getUserTicket_args args = new getUserTicket_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserTicket_result result = new getUserTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserTicket failed: unknown result");
  }

  Future<WapInvitation> getWapInvitation(String invitationHash) async {
    oprot.writeMessageBegin(new TMessage("getWapInvitation", TMessageType.CALL, nextSeqid()));
    getWapInvitation_args args = new getWapInvitation_args();
    args.invitationHash = invitationHash;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getWapInvitation_result result = new getWapInvitation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getWapInvitation failed: unknown result");
  }

  Future invalidateUserTicket() async {
    oprot.writeMessageBegin(new TMessage("invalidateUserTicket", TMessageType.CALL, nextSeqid()));
    invalidateUserTicket_args args = new invalidateUserTicket_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    invalidateUserTicket_result result = new invalidateUserTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future inviteFriendsBySms(List<String> phoneNumberList) async {
    oprot.writeMessageBegin(new TMessage("inviteFriendsBySms", TMessageType.CALL, nextSeqid()));
    inviteFriendsBySms_args args = new inviteFriendsBySms_args();
    args.phoneNumberList = phoneNumberList;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    inviteFriendsBySms_result result = new inviteFriendsBySms_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future inviteIntoGroup(int reqSeq, String groupId, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("inviteIntoGroup", TMessageType.CALL, nextSeqid()));
    inviteIntoGroup_args args = new inviteIntoGroup_args();
    args.reqSeq = reqSeq;
    args.groupId = groupId;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    inviteIntoGroup_result result = new inviteIntoGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future inviteIntoRoom(int reqSeq, String roomId, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("inviteIntoRoom", TMessageType.CALL, nextSeqid()));
    inviteIntoRoom_args args = new inviteIntoRoom_args();
    args.reqSeq = reqSeq;
    args.roomId = roomId;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    inviteIntoRoom_result result = new inviteIntoRoom_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future inviteViaEmail(int reqSeq, String email, String name) async {
    oprot.writeMessageBegin(new TMessage("inviteViaEmail", TMessageType.CALL, nextSeqid()));
    inviteViaEmail_args args = new inviteViaEmail_args();
    args.reqSeq = reqSeq;
    args.email = email;
    args.name = name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    inviteViaEmail_result result = new inviteViaEmail_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<bool> isIdentityIdentifierAvailable(int provider, String identifier) async {
    oprot.writeMessageBegin(new TMessage("isIdentityIdentifierAvailable", TMessageType.CALL, nextSeqid()));
    isIdentityIdentifierAvailable_args args = new isIdentityIdentifierAvailable_args();
    args.provider = provider;
    args.identifier = identifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    isIdentityIdentifierAvailable_result result = new isIdentityIdentifierAvailable_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "isIdentityIdentifierAvailable failed: unknown result");
  }

  Future<bool> isUseridAvailable(String userid) async {
    oprot.writeMessageBegin(new TMessage("isUseridAvailable", TMessageType.CALL, nextSeqid()));
    isUseridAvailable_args args = new isUseridAvailable_args();
    args.userid = userid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    isUseridAvailable_result result = new isUseridAvailable_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "isUseridAvailable failed: unknown result");
  }

  Future kickoutFromGroup(int reqSeq, String groupId, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("kickoutFromGroup", TMessageType.CALL, nextSeqid()));
    kickoutFromGroup_args args = new kickoutFromGroup_args();
    args.reqSeq = reqSeq;
    args.groupId = groupId;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    kickoutFromGroup_result result = new kickoutFromGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> reissueGroupTicket(String groupMid) async {
    oprot.writeMessageBegin(new TMessage("reissueGroupTicket", TMessageType.CALL, nextSeqid()));
    reissueGroupTicket_args args = new reissueGroupTicket_args();
    args.groupMid = groupMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reissueGroupTicket_result result = new reissueGroupTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reissueGroupTicket failed: unknown result");
  }

  Future<Group> findGroupByTicket(String ticketId) async {
    oprot.writeMessageBegin(new TMessage("findGroupByTicket", TMessageType.CALL, nextSeqid()));
    findGroupByTicket_args args = new findGroupByTicket_args();
    args.ticketId = ticketId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findGroupByTicket_result result = new findGroupByTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findGroupByTicket failed: unknown result");
  }

  Future leaveGroup(int reqSeq, String groupId) async {
    oprot.writeMessageBegin(new TMessage("leaveGroup", TMessageType.CALL, nextSeqid()));
    leaveGroup_args args = new leaveGroup_args();
    args.reqSeq = reqSeq;
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    leaveGroup_result result = new leaveGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future leaveRoom(int reqSeq, String roomId) async {
    oprot.writeMessageBegin(new TMessage("leaveRoom", TMessageType.CALL, nextSeqid()));
    leaveRoom_args args = new leaveRoom_args();
    args.reqSeq = reqSeq;
    args.roomId = roomId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    leaveRoom_result result = new leaveRoom_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> loginWithIdentityCredential(int identityProvider, String identifier, String password, bool keepLoggedIn, String accessLocation, String systemName, String certificate) async {
    oprot.writeMessageBegin(new TMessage("loginWithIdentityCredential", TMessageType.CALL, nextSeqid()));
    loginWithIdentityCredential_args args = new loginWithIdentityCredential_args();
    args.identityProvider = identityProvider;
    args.identifier = identifier;
    args.password = password;
    args.keepLoggedIn = keepLoggedIn;
    args.accessLocation = accessLocation;
    args.systemName = systemName;
    args.certificate = certificate;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    loginWithIdentityCredential_result result = new loginWithIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "loginWithIdentityCredential failed: unknown result");
  }

  Future<LoginResult> loginWithIdentityCredentialForCertificate(int identityProvider, String identifier, String password, bool keepLoggedIn, String accessLocation, String systemName, String certificate) async {
    oprot.writeMessageBegin(new TMessage("loginWithIdentityCredentialForCertificate", TMessageType.CALL, nextSeqid()));
    loginWithIdentityCredentialForCertificate_args args = new loginWithIdentityCredentialForCertificate_args();
    args.identityProvider = identityProvider;
    args.identifier = identifier;
    args.password = password;
    args.keepLoggedIn = keepLoggedIn;
    args.accessLocation = accessLocation;
    args.systemName = systemName;
    args.certificate = certificate;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    loginWithIdentityCredentialForCertificate_result result = new loginWithIdentityCredentialForCertificate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "loginWithIdentityCredentialForCertificate failed: unknown result");
  }

  Future<String> loginWithVerifier(String verifier) async {
    oprot.writeMessageBegin(new TMessage("loginWithVerifier", TMessageType.CALL, nextSeqid()));
    loginWithVerifier_args args = new loginWithVerifier_args();
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    loginWithVerifier_result result = new loginWithVerifier_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "loginWithVerifier failed: unknown result");
  }

  Future<LoginResult> loginWithVerifierForCerificate(String verifier) async {
    oprot.writeMessageBegin(new TMessage("loginWithVerifierForCerificate", TMessageType.CALL, nextSeqid()));
    loginWithVerifierForCerificate_args args = new loginWithVerifierForCerificate_args();
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    loginWithVerifierForCerificate_result result = new loginWithVerifierForCerificate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "loginWithVerifierForCerificate failed: unknown result");
  }

  Future<LoginResult> loginWithVerifierForCertificate(String verifier) async {
    oprot.writeMessageBegin(new TMessage("loginWithVerifierForCertificate", TMessageType.CALL, nextSeqid()));
    loginWithVerifierForCertificate_args args = new loginWithVerifierForCertificate_args();
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    loginWithVerifierForCertificate_result result = new loginWithVerifierForCertificate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "loginWithVerifierForCertificate failed: unknown result");
  }

  Future logout() async {
    oprot.writeMessageBegin(new TMessage("logout", TMessageType.CALL, nextSeqid()));
    logout_args args = new logout_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    logout_result result = new logout_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future logoutSession(String tokenKey) async {
    oprot.writeMessageBegin(new TMessage("logoutSession", TMessageType.CALL, nextSeqid()));
    logoutSession_args args = new logoutSession_args();
    args.tokenKey = tokenKey;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    logoutSession_result result = new logoutSession_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future noop() async {
    oprot.writeMessageBegin(new TMessage("noop", TMessageType.CALL, nextSeqid()));
    noop_args args = new noop_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    noop_result result = new noop_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future notifiedRedirect(Map<String, String> paramMap) async {
    oprot.writeMessageBegin(new TMessage("notifiedRedirect", TMessageType.CALL, nextSeqid()));
    notifiedRedirect_args args = new notifiedRedirect_args();
    args.paramMap = paramMap;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifiedRedirect_result result = new notifiedRedirect_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, String>> notifyBuddyOnAir(int seq, List<String> receiverMids) async {
    oprot.writeMessageBegin(new TMessage("notifyBuddyOnAir", TMessageType.CALL, nextSeqid()));
    notifyBuddyOnAir_args args = new notifyBuddyOnAir_args();
    args.seq = seq;
    args.receiverMids = receiverMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyBuddyOnAir_result result = new notifyBuddyOnAir_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "notifyBuddyOnAir failed: unknown result");
  }

  Future notifyIndividualEvent(int notificationStatus, List<String> receiverMids) async {
    oprot.writeMessageBegin(new TMessage("notifyIndividualEvent", TMessageType.CALL, nextSeqid()));
    notifyIndividualEvent_args args = new notifyIndividualEvent_args();
    args.notificationStatus = notificationStatus;
    args.receiverMids = receiverMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyIndividualEvent_result result = new notifyIndividualEvent_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future notifyInstalled(String udidHash, String applicationTypeWithExtensions) async {
    oprot.writeMessageBegin(new TMessage("notifyInstalled", TMessageType.CALL, nextSeqid()));
    notifyInstalled_args args = new notifyInstalled_args();
    args.udidHash = udidHash;
    args.applicationTypeWithExtensions = applicationTypeWithExtensions;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyInstalled_result result = new notifyInstalled_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future notifyRegistrationComplete(String udidHash, String applicationTypeWithExtensions) async {
    oprot.writeMessageBegin(new TMessage("notifyRegistrationComplete", TMessageType.CALL, nextSeqid()));
    notifyRegistrationComplete_args args = new notifyRegistrationComplete_args();
    args.udidHash = udidHash;
    args.applicationTypeWithExtensions = applicationTypeWithExtensions;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyRegistrationComplete_result result = new notifyRegistrationComplete_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future notifySleep(int lastRev, int badge) async {
    oprot.writeMessageBegin(new TMessage("notifySleep", TMessageType.CALL, nextSeqid()));
    notifySleep_args args = new notifySleep_args();
    args.lastRev = lastRev;
    args.badge = badge;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifySleep_result result = new notifySleep_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future notifyUpdated(int lastRev, DeviceInfo deviceInfo) async {
    oprot.writeMessageBegin(new TMessage("notifyUpdated", TMessageType.CALL, nextSeqid()));
    notifyUpdated_args args = new notifyUpdated_args();
    args.lastRev = lastRev;
    args.deviceInfo = deviceInfo;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyUpdated_result result = new notifyUpdated_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> openProximityMatch(Location location) async {
    oprot.writeMessageBegin(new TMessage("openProximityMatch", TMessageType.CALL, nextSeqid()));
    openProximityMatch_args args = new openProximityMatch_args();
    args.location = location;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    openProximityMatch_result result = new openProximityMatch_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "openProximityMatch failed: unknown result");
  }

  Future<String> registerBuddyUser(String buddyId, String registrarPassword) async {
    oprot.writeMessageBegin(new TMessage("registerBuddyUser", TMessageType.CALL, nextSeqid()));
    registerBuddyUser_args args = new registerBuddyUser_args();
    args.buddyId = buddyId;
    args.registrarPassword = registrarPassword;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerBuddyUser_result result = new registerBuddyUser_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerBuddyUser failed: unknown result");
  }

  Future registerBuddyUserid(int seq, String userid) async {
    oprot.writeMessageBegin(new TMessage("registerBuddyUserid", TMessageType.CALL, nextSeqid()));
    registerBuddyUserid_args args = new registerBuddyUserid_args();
    args.seq = seq;
    args.userid = userid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerBuddyUserid_result result = new registerBuddyUserid_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> registerDevice(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("registerDevice", TMessageType.CALL, nextSeqid()));
    registerDevice_args args = new registerDevice_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerDevice_result result = new registerDevice_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerDevice failed: unknown result");
  }

  Future<String> registerDeviceWithIdentityCredential(String sessionId, int provider, String identifier, String verifier) async {
    oprot.writeMessageBegin(new TMessage("registerDeviceWithIdentityCredential", TMessageType.CALL, nextSeqid()));
    registerDeviceWithIdentityCredential_args args = new registerDeviceWithIdentityCredential_args();
    args.sessionId = sessionId;
    args.provider = provider;
    args.identifier = identifier;
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerDeviceWithIdentityCredential_result result = new registerDeviceWithIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerDeviceWithIdentityCredential failed: unknown result");
  }

  Future<String> registerDeviceWithoutPhoneNumber(String region, String udidHash, DeviceInfo deviceInfo) async {
    oprot.writeMessageBegin(new TMessage("registerDeviceWithoutPhoneNumber", TMessageType.CALL, nextSeqid()));
    registerDeviceWithoutPhoneNumber_args args = new registerDeviceWithoutPhoneNumber_args();
    args.region = region;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerDeviceWithoutPhoneNumber_result result = new registerDeviceWithoutPhoneNumber_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerDeviceWithoutPhoneNumber failed: unknown result");
  }

  Future<String> registerDeviceWithoutPhoneNumberWithIdentityCredential(String region, String udidHash, DeviceInfo deviceInfo, int provider, String identifier, String verifier, String mid, String migrationPincodeSessionId) async {
    oprot.writeMessageBegin(new TMessage("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType.CALL, nextSeqid()));
    registerDeviceWithoutPhoneNumberWithIdentityCredential_args args = new registerDeviceWithoutPhoneNumberWithIdentityCredential_args();
    args.region = region;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.provider = provider;
    args.identifier = identifier;
    args.verifier = verifier;
    args.mid = mid;
    args.migrationPincodeSessionId = migrationPincodeSessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerDeviceWithoutPhoneNumberWithIdentityCredential_result result = new registerDeviceWithoutPhoneNumberWithIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerDeviceWithoutPhoneNumberWithIdentityCredential failed: unknown result");
  }

  Future<bool> registerUserid(int reqSeq, String userid) async {
    oprot.writeMessageBegin(new TMessage("registerUserid", TMessageType.CALL, nextSeqid()));
    registerUserid_args args = new registerUserid_args();
    args.reqSeq = reqSeq;
    args.userid = userid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerUserid_result result = new registerUserid_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerUserid failed: unknown result");
  }

  Future<String> registerWapDevice(String invitationHash, String guidHash, String email, DeviceInfo deviceInfo) async {
    oprot.writeMessageBegin(new TMessage("registerWapDevice", TMessageType.CALL, nextSeqid()));
    registerWapDevice_args args = new registerWapDevice_args();
    args.invitationHash = invitationHash;
    args.guidHash = guidHash;
    args.email = email;
    args.deviceInfo = deviceInfo;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerWapDevice_result result = new registerWapDevice_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerWapDevice failed: unknown result");
  }

  Future<String> registerWithExistingSnsIdAndIdentityCredential(IdentityCredential identityCredential, String region, String udidHash, DeviceInfo deviceInfo) async {
    oprot.writeMessageBegin(new TMessage("registerWithExistingSnsIdAndIdentityCredential", TMessageType.CALL, nextSeqid()));
    registerWithExistingSnsIdAndIdentityCredential_args args = new registerWithExistingSnsIdAndIdentityCredential_args();
    args.identityCredential = identityCredential;
    args.region = region;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerWithExistingSnsIdAndIdentityCredential_result result = new registerWithExistingSnsIdAndIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerWithExistingSnsIdAndIdentityCredential failed: unknown result");
  }

  Future<RegisterWithSnsIdResult> registerWithSnsId(int snsIdType, String snsAccessToken, String region, String udidHash, DeviceInfo deviceInfo, String mid) async {
    oprot.writeMessageBegin(new TMessage("registerWithSnsId", TMessageType.CALL, nextSeqid()));
    registerWithSnsId_args args = new registerWithSnsId_args();
    args.snsIdType = snsIdType;
    args.snsAccessToken = snsAccessToken;
    args.region = region;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerWithSnsId_result result = new registerWithSnsId_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerWithSnsId failed: unknown result");
  }

  Future<String> registerWithSnsIdAndIdentityCredential(int snsIdType, String snsAccessToken, IdentityCredential identityCredential, String region, String udidHash, DeviceInfo deviceInfo) async {
    oprot.writeMessageBegin(new TMessage("registerWithSnsIdAndIdentityCredential", TMessageType.CALL, nextSeqid()));
    registerWithSnsIdAndIdentityCredential_args args = new registerWithSnsIdAndIdentityCredential_args();
    args.snsIdType = snsIdType;
    args.snsAccessToken = snsAccessToken;
    args.identityCredential = identityCredential;
    args.region = region;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerWithSnsIdAndIdentityCredential_result result = new registerWithSnsIdAndIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerWithSnsIdAndIdentityCredential failed: unknown result");
  }

  Future<String> reissueDeviceCredential() async {
    oprot.writeMessageBegin(new TMessage("reissueDeviceCredential", TMessageType.CALL, nextSeqid()));
    reissueDeviceCredential_args args = new reissueDeviceCredential_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reissueDeviceCredential_result result = new reissueDeviceCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reissueDeviceCredential failed: unknown result");
  }

  Future<String> reissueUserTicket(int expirationTime, int maxUseCount) async {
    oprot.writeMessageBegin(new TMessage("reissueUserTicket", TMessageType.CALL, nextSeqid()));
    reissueUserTicket_args args = new reissueUserTicket_args();
    args.expirationTime = expirationTime;
    args.maxUseCount = maxUseCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reissueUserTicket_result result = new reissueUserTicket_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reissueUserTicket failed: unknown result");
  }

  Future<List<TMessageReadRange>> getMessageReadRange(List<String> chatIds) async {
    oprot.writeMessageBegin(new TMessage("getMessageReadRange", TMessageType.CALL, nextSeqid()));
    getMessageReadRange_args args = new getMessageReadRange_args();
    args.chatIds = chatIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageReadRange_result result = new getMessageReadRange_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageReadRange failed: unknown result");
  }

  Future rejectGroupInvitation(int reqSeq, String groupId) async {
    oprot.writeMessageBegin(new TMessage("rejectGroupInvitation", TMessageType.CALL, nextSeqid()));
    rejectGroupInvitation_args args = new rejectGroupInvitation_args();
    args.reqSeq = reqSeq;
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    rejectGroupInvitation_result result = new rejectGroupInvitation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future releaseSession() async {
    oprot.writeMessageBegin(new TMessage("releaseSession", TMessageType.CALL, nextSeqid()));
    releaseSession_args args = new releaseSession_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    releaseSession_result result = new releaseSession_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future removeAllMessages(int seq, String lastMessageId) async {
    oprot.writeMessageBegin(new TMessage("removeAllMessages", TMessageType.CALL, nextSeqid()));
    removeAllMessages_args args = new removeAllMessages_args();
    args.seq = seq;
    args.lastMessageId = lastMessageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeAllMessages_result result = new removeAllMessages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future removeBuddyLocation(String mid, int index) async {
    oprot.writeMessageBegin(new TMessage("removeBuddyLocation", TMessageType.CALL, nextSeqid()));
    removeBuddyLocation_args args = new removeBuddyLocation_args();
    args.mid = mid;
    args.index = index;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeBuddyLocation_result result = new removeBuddyLocation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<bool> removeMessage(String messageId) async {
    oprot.writeMessageBegin(new TMessage("removeMessage", TMessageType.CALL, nextSeqid()));
    removeMessage_args args = new removeMessage_args();
    args.messageId = messageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeMessage_result result = new removeMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "removeMessage failed: unknown result");
  }

  Future<ContactTransition> makeUserAddMyselfAsContact(String contactOwnerMid) async {
    oprot.writeMessageBegin(new TMessage("makeUserAddMyselfAsContact", TMessageType.CALL, nextSeqid()));
    makeUserAddMyselfAsContact_args args = new makeUserAddMyselfAsContact_args();
    args.contactOwnerMid = contactOwnerMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    makeUserAddMyselfAsContact_result result = new makeUserAddMyselfAsContact_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "makeUserAddMyselfAsContact failed: unknown result");
  }

  Future<bool> removeMessageFromMyHome(String messageId) async {
    oprot.writeMessageBegin(new TMessage("removeMessageFromMyHome", TMessageType.CALL, nextSeqid()));
    removeMessageFromMyHome_args args = new removeMessageFromMyHome_args();
    args.messageId = messageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeMessageFromMyHome_result result = new removeMessageFromMyHome_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "removeMessageFromMyHome failed: unknown result");
  }

  Future<String> removeSnsId(int snsIdType) async {
    oprot.writeMessageBegin(new TMessage("removeSnsId", TMessageType.CALL, nextSeqid()));
    removeSnsId_args args = new removeSnsId_args();
    args.snsIdType = snsIdType;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeSnsId_result result = new removeSnsId_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "removeSnsId failed: unknown result");
  }

  Future report(int syncOpRevision, int category, String report) async {
    oprot.writeMessageBegin(new TMessage("report", TMessageType.CALL, nextSeqid()));
    report_args args = new report_args();
    args.syncOpRevision = syncOpRevision;
    args.category = category;
    args.report = report;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    report_result result = new report_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<List<ContactReportResult>> reportContacts(int syncOpRevision, int category, List<ContactReport> contactReports, int actionType) async {
    oprot.writeMessageBegin(new TMessage("reportContacts", TMessageType.CALL, nextSeqid()));
    reportContacts_args args = new reportContacts_args();
    args.syncOpRevision = syncOpRevision;
    args.category = category;
    args.contactReports = contactReports;
    args.actionType = actionType;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportContacts_result result = new reportContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reportContacts failed: unknown result");
  }

  Future reportGroups(int syncOpRevision, List<Group> groups) async {
    oprot.writeMessageBegin(new TMessage("reportGroups", TMessageType.CALL, nextSeqid()));
    reportGroups_args args = new reportGroups_args();
    args.syncOpRevision = syncOpRevision;
    args.groups = groups;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportGroups_result result = new reportGroups_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future reportProfile(int syncOpRevision, Profile profile) async {
    oprot.writeMessageBegin(new TMessage("reportProfile", TMessageType.CALL, nextSeqid()));
    reportProfile_args args = new reportProfile_args();
    args.syncOpRevision = syncOpRevision;
    args.profile = profile;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportProfile_result result = new reportProfile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future reportRooms(int syncOpRevision, List<Room> rooms) async {
    oprot.writeMessageBegin(new TMessage("reportRooms", TMessageType.CALL, nextSeqid()));
    reportRooms_args args = new reportRooms_args();
    args.syncOpRevision = syncOpRevision;
    args.rooms = rooms;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportRooms_result result = new reportRooms_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Contact> findAndAddContactByMetaTag(int reqSeq, String userid, String reference) async {
    oprot.writeMessageBegin(new TMessage("findAndAddContactByMetaTag", TMessageType.CALL, nextSeqid()));
    findAndAddContactByMetaTag_args args = new findAndAddContactByMetaTag_args();
    args.reqSeq = reqSeq;
    args.userid = userid;
    args.reference = reference;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findAndAddContactByMetaTag_result result = new findAndAddContactByMetaTag_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findAndAddContactByMetaTag failed: unknown result");
  }

  Future reportSettings(int syncOpRevision, Settings settings) async {
    oprot.writeMessageBegin(new TMessage("reportSettings", TMessageType.CALL, nextSeqid()));
    reportSettings_args args = new reportSettings_args();
    args.syncOpRevision = syncOpRevision;
    args.settings = settings;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportSettings_result result = new reportSettings_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future reportSpam(String chatMid, List<String> memberMids, List<int> spammerReasons, List<String> senderMids, List<String> spamMessageIds, List<String> spamMessages) async {
    oprot.writeMessageBegin(new TMessage("reportSpam", TMessageType.CALL, nextSeqid()));
    reportSpam_args args = new reportSpam_args();
    args.chatMid = chatMid;
    args.memberMids = memberMids;
    args.spammerReasons = spammerReasons;
    args.senderMids = senderMids;
    args.spamMessageIds = spamMessageIds;
    args.spamMessages = spamMessages;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportSpam_result result = new reportSpam_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future reportSpammer(String spammerMid, List<int> spammerReasons, List<String> spamMessageIds) async {
    oprot.writeMessageBegin(new TMessage("reportSpammer", TMessageType.CALL, nextSeqid()));
    reportSpammer_args args = new reportSpammer_args();
    args.spammerMid = spammerMid;
    args.spammerReasons = spammerReasons;
    args.spamMessageIds = spamMessageIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportSpammer_result result = new reportSpammer_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future requestAccountPasswordReset(int provider, String identifier, String locale) async {
    oprot.writeMessageBegin(new TMessage("requestAccountPasswordReset", TMessageType.CALL, nextSeqid()));
    requestAccountPasswordReset_args args = new requestAccountPasswordReset_args();
    args.provider = provider;
    args.identifier = identifier;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    requestAccountPasswordReset_result result = new requestAccountPasswordReset_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<EmailConfirmationSession> requestEmailConfirmation(EmailConfirmation emailConfirmation) async {
    oprot.writeMessageBegin(new TMessage("requestEmailConfirmation", TMessageType.CALL, nextSeqid()));
    requestEmailConfirmation_args args = new requestEmailConfirmation_args();
    args.emailConfirmation = emailConfirmation;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    requestEmailConfirmation_result result = new requestEmailConfirmation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "requestEmailConfirmation failed: unknown result");
  }

  Future requestIdentityUnbind(int provider, String identifier) async {
    oprot.writeMessageBegin(new TMessage("requestIdentityUnbind", TMessageType.CALL, nextSeqid()));
    requestIdentityUnbind_args args = new requestIdentityUnbind_args();
    args.provider = provider;
    args.identifier = identifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    requestIdentityUnbind_result result = new requestIdentityUnbind_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<EmailConfirmationSession> resendEmailConfirmation(String verifier) async {
    oprot.writeMessageBegin(new TMessage("resendEmailConfirmation", TMessageType.CALL, nextSeqid()));
    resendEmailConfirmation_args args = new resendEmailConfirmation_args();
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    resendEmailConfirmation_result result = new resendEmailConfirmation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "resendEmailConfirmation failed: unknown result");
  }

  Future resendPinCode(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("resendPinCode", TMessageType.CALL, nextSeqid()));
    resendPinCode_args args = new resendPinCode_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    resendPinCode_result result = new resendPinCode_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future resendPinCodeBySMS(String sessionId) async {
    oprot.writeMessageBegin(new TMessage("resendPinCodeBySMS", TMessageType.CALL, nextSeqid()));
    resendPinCodeBySMS_args args = new resendPinCodeBySMS_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    resendPinCodeBySMS_result result = new resendPinCodeBySMS_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future sendChatChecked(int seq, String consumer, String lastMessageId) async {
    oprot.writeMessageBegin(new TMessage("sendChatChecked", TMessageType.CALL, nextSeqid()));
    sendChatChecked_args args = new sendChatChecked_args();
    args.seq = seq;
    args.consumer = consumer;
    args.lastMessageId = lastMessageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendChatChecked_result result = new sendChatChecked_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<CommitMessageResult> sendMessageAwaitCommit(int seq, Message message) async {
    oprot.writeMessageBegin(new TMessage("sendMessageAwaitCommit", TMessageType.CALL, nextSeqid()));
    sendMessageAwaitCommit_args args = new sendMessageAwaitCommit_args();
    args.seq = seq;
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessageAwaitCommit_result result = new sendMessageAwaitCommit_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendMessageAwaitCommit failed: unknown result");
  }

  Future sendChatRemoved(int seq, String consumer, String lastMessageId) async {
    oprot.writeMessageBegin(new TMessage("sendChatRemoved", TMessageType.CALL, nextSeqid()));
    sendChatRemoved_args args = new sendChatRemoved_args();
    args.seq = seq;
    args.consumer = consumer;
    args.lastMessageId = lastMessageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendChatRemoved_result result = new sendChatRemoved_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, String>> sendContentPreviewUpdated(int esq, String messageId, List<String> receiverMids) async {
    oprot.writeMessageBegin(new TMessage("sendContentPreviewUpdated", TMessageType.CALL, nextSeqid()));
    sendContentPreviewUpdated_args args = new sendContentPreviewUpdated_args();
    args.esq = esq;
    args.messageId = messageId;
    args.receiverMids = receiverMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendContentPreviewUpdated_result result = new sendContentPreviewUpdated_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendContentPreviewUpdated failed: unknown result");
  }

  Future sendContentReceipt(int seq, String consumer, String messageId) async {
    oprot.writeMessageBegin(new TMessage("sendContentReceipt", TMessageType.CALL, nextSeqid()));
    sendContentReceipt_args args = new sendContentReceipt_args();
    args.seq = seq;
    args.consumer = consumer;
    args.messageId = messageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendContentReceipt_result result = new sendContentReceipt_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future sendDummyPush() async {
    oprot.writeMessageBegin(new TMessage("sendDummyPush", TMessageType.CALL, nextSeqid()));
    sendDummyPush_args args = new sendDummyPush_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendDummyPush_result result = new sendDummyPush_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future removeE2EEPublicKey(E2EEPublicKey publicKey) async {
    oprot.writeMessageBegin(new TMessage("removeE2EEPublicKey", TMessageType.CALL, nextSeqid()));
    removeE2EEPublicKey_args args = new removeE2EEPublicKey_args();
    args.publicKey = publicKey;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeE2EEPublicKey_result result = new removeE2EEPublicKey_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<E2EENegotiationResult> negotiateE2EEPublicKey(String mid) async {
    oprot.writeMessageBegin(new TMessage("negotiateE2EEPublicKey", TMessageType.CALL, nextSeqid()));
    negotiateE2EEPublicKey_args args = new negotiateE2EEPublicKey_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    negotiateE2EEPublicKey_result result = new negotiateE2EEPublicKey_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "negotiateE2EEPublicKey failed: unknown result");
  }

  Future<E2EEPublicKey> getE2EEPublicKey(String mid, int version, int keyId) async {
    oprot.writeMessageBegin(new TMessage("getE2EEPublicKey", TMessageType.CALL, nextSeqid()));
    getE2EEPublicKey_args args = new getE2EEPublicKey_args();
    args.mid = mid;
    args.version = version;
    args.keyId = keyId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getE2EEPublicKey_result result = new getE2EEPublicKey_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getE2EEPublicKey failed: unknown result");
  }

  Future requestE2EEKeyExchange(int reqSeq, Uint8List temporalPublicKey, E2EEPublicKey publicKey, Uint8List verifier) async {
    oprot.writeMessageBegin(new TMessage("requestE2EEKeyExchange", TMessageType.CALL, nextSeqid()));
    requestE2EEKeyExchange_args args = new requestE2EEKeyExchange_args();
    args.reqSeq = reqSeq;
    args.temporalPublicKey = temporalPublicKey;
    args.publicKey = publicKey;
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    requestE2EEKeyExchange_result result = new requestE2EEKeyExchange_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, E2EEPublicKey>> getLastE2EEPublicKeys(String chatMid) async {
    oprot.writeMessageBegin(new TMessage("getLastE2EEPublicKeys", TMessageType.CALL, nextSeqid()));
    getLastE2EEPublicKeys_args args = new getLastE2EEPublicKeys_args();
    args.chatMid = chatMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getLastE2EEPublicKeys_result result = new getLastE2EEPublicKeys_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getLastE2EEPublicKeys failed: unknown result");
  }

  Future<E2EEPublicKey> registerE2EEPublicKey(int reqSeq, E2EEPublicKey publicKey) async {
    oprot.writeMessageBegin(new TMessage("registerE2EEPublicKey", TMessageType.CALL, nextSeqid()));
    registerE2EEPublicKey_args args = new registerE2EEPublicKey_args();
    args.reqSeq = reqSeq;
    args.publicKey = publicKey;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerE2EEPublicKey_result result = new registerE2EEPublicKey_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerE2EEPublicKey failed: unknown result");
  }

  Future<List<E2EEPublicKey>> getE2EEPublicKeys() async {
    oprot.writeMessageBegin(new TMessage("getE2EEPublicKeys", TMessageType.CALL, nextSeqid()));
    getE2EEPublicKeys_args args = new getE2EEPublicKeys_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getE2EEPublicKeys_result result = new getE2EEPublicKeys_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getE2EEPublicKeys failed: unknown result");
  }

  Future<List<E2EEPublicKey>> getE2EEPublicKeysEx(bool ignoreE2EEStatus) async {
    oprot.writeMessageBegin(new TMessage("getE2EEPublicKeysEx", TMessageType.CALL, nextSeqid()));
    getE2EEPublicKeysEx_args args = new getE2EEPublicKeysEx_args();
    args.ignoreE2EEStatus = ignoreE2EEStatus;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getE2EEPublicKeysEx_result result = new getE2EEPublicKeysEx_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getE2EEPublicKeysEx failed: unknown result");
  }

  Future<List<Operation>> getReadMessageOpsInBulk(List<String> chatIds) async {
    oprot.writeMessageBegin(new TMessage("getReadMessageOpsInBulk", TMessageType.CALL, nextSeqid()));
    getReadMessageOpsInBulk_args args = new getReadMessageOpsInBulk_args();
    args.chatIds = chatIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getReadMessageOpsInBulk_result result = new getReadMessageOpsInBulk_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getReadMessageOpsInBulk failed: unknown result");
  }

  Future<Message> sendEvent(int seq, Message message) async {
    oprot.writeMessageBegin(new TMessage("sendEvent", TMessageType.CALL, nextSeqid()));
    sendEvent_args args = new sendEvent_args();
    args.seq = seq;
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendEvent_result result = new sendEvent_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendEvent failed: unknown result");
  }

  Future<Message> sendMessage(int seq, Message message) async {
    oprot.writeMessageBegin(new TMessage("sendMessage", TMessageType.CALL, nextSeqid()));
    sendMessage_args args = new sendMessage_args();
    args.seq = seq;
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessage_result result = new sendMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendMessage failed: unknown result");
  }

  Future sendMessageIgnored(int seq, String consumer, List<String> messageIds) async {
    oprot.writeMessageBegin(new TMessage("sendMessageIgnored", TMessageType.CALL, nextSeqid()));
    sendMessageIgnored_args args = new sendMessageIgnored_args();
    args.seq = seq;
    args.consumer = consumer;
    args.messageIds = messageIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessageIgnored_result result = new sendMessageIgnored_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future sendMessageReceipt(int seq, String consumer, List<String> messageIds) async {
    oprot.writeMessageBegin(new TMessage("sendMessageReceipt", TMessageType.CALL, nextSeqid()));
    sendMessageReceipt_args args = new sendMessageReceipt_args();
    args.seq = seq;
    args.consumer = consumer;
    args.messageIds = messageIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessageReceipt_result result = new sendMessageReceipt_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Contact> findContactByMetaTag(String userid, String reference) async {
    oprot.writeMessageBegin(new TMessage("findContactByMetaTag", TMessageType.CALL, nextSeqid()));
    findContactByMetaTag_args args = new findContactByMetaTag_args();
    args.userid = userid;
    args.reference = reference;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findContactByMetaTag_result result = new findContactByMetaTag_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findContactByMetaTag failed: unknown result");
  }

  Future<Message> sendMessageToMyHome(int seq, Message message) async {
    oprot.writeMessageBegin(new TMessage("sendMessageToMyHome", TMessageType.CALL, nextSeqid()));
    sendMessageToMyHome_args args = new sendMessageToMyHome_args();
    args.seq = seq;
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessageToMyHome_result result = new sendMessageToMyHome_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendMessageToMyHome failed: unknown result");
  }

  Future setBuddyLocation(String mid, int index, Geolocation location) async {
    oprot.writeMessageBegin(new TMessage("setBuddyLocation", TMessageType.CALL, nextSeqid()));
    setBuddyLocation_args args = new setBuddyLocation_args();
    args.mid = mid;
    args.index = index;
    args.location = location;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    setBuddyLocation_result result = new setBuddyLocation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future setIdentityCredential(String identifier, String verifier, int provider) async {
    oprot.writeMessageBegin(new TMessage("setIdentityCredential", TMessageType.CALL, nextSeqid()));
    setIdentityCredential_args args = new setIdentityCredential_args();
    args.identifier = identifier;
    args.verifier = verifier;
    args.provider = provider;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    setIdentityCredential_result result = new setIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future setNotificationsEnabled(int reqSeq, int type, String target, bool enablement) async {
    oprot.writeMessageBegin(new TMessage("setNotificationsEnabled", TMessageType.CALL, nextSeqid()));
    setNotificationsEnabled_args args = new setNotificationsEnabled_args();
    args.reqSeq = reqSeq;
    args.type = type;
    args.target = target;
    args.enablement = enablement;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    setNotificationsEnabled_result result = new setNotificationsEnabled_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<VerificationSessionData> startUpdateVerification(String region, int carrier, String phone, String udidHash, DeviceInfo deviceInfo, String networkCode, String locale) async {
    oprot.writeMessageBegin(new TMessage("startUpdateVerification", TMessageType.CALL, nextSeqid()));
    startUpdateVerification_args args = new startUpdateVerification_args();
    args.region = region;
    args.carrier = carrier;
    args.phone = phone;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.networkCode = networkCode;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    startUpdateVerification_result result = new startUpdateVerification_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "startUpdateVerification failed: unknown result");
  }

  Future<VerificationSessionData> startVerification(String region, int carrier, String phone, String udidHash, DeviceInfo deviceInfo, String networkCode, String mid, String locale, SIMInfo simInfo, String oldUdidHash) async {
    oprot.writeMessageBegin(new TMessage("startVerification", TMessageType.CALL, nextSeqid()));
    startVerification_args args = new startVerification_args();
    args.region = region;
    args.carrier = carrier;
    args.phone = phone;
    args.udidHash = udidHash;
    args.deviceInfo = deviceInfo;
    args.networkCode = networkCode;
    args.mid = mid;
    args.locale = locale;
    args.simInfo = simInfo;
    args.oldUdidHash = oldUdidHash;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    startVerification_result result = new startVerification_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "startVerification failed: unknown result");
  }

  Future updateGroupPreferenceAttribute(int reqSeq, String groupMid, Map<int, String> updatedAttrs) async {
    oprot.writeMessageBegin(new TMessage("updateGroupPreferenceAttribute", TMessageType.CALL, nextSeqid()));
    updateGroupPreferenceAttribute_args args = new updateGroupPreferenceAttribute_args();
    args.reqSeq = reqSeq;
    args.groupMid = groupMid;
    args.updatedAttrs = updatedAttrs;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateGroupPreferenceAttribute_result result = new updateGroupPreferenceAttribute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Room> createRoomV2(int reqSeq, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("createRoomV2", TMessageType.CALL, nextSeqid()));
    createRoomV2_args args = new createRoomV2_args();
    args.reqSeq = reqSeq;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createRoomV2_result result = new createRoomV2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createRoomV2 failed: unknown result");
  }

  Future storeUpdateProfileAttribute(int seq, int profileAttribute, String value) async {
    oprot.writeMessageBegin(new TMessage("storeUpdateProfileAttribute", TMessageType.CALL, nextSeqid()));
    storeUpdateProfileAttribute_args args = new storeUpdateProfileAttribute_args();
    args.seq = seq;
    args.profileAttribute = profileAttribute;
    args.value = value;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    storeUpdateProfileAttribute_result result = new storeUpdateProfileAttribute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<List<SnsFriendContactRegistration>> syncContactBySnsIds(int reqSeq, List<SnsFriendModification> modifications) async {
    oprot.writeMessageBegin(new TMessage("syncContactBySnsIds", TMessageType.CALL, nextSeqid()));
    syncContactBySnsIds_args args = new syncContactBySnsIds_args();
    args.reqSeq = reqSeq;
    args.modifications = modifications;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    syncContactBySnsIds_result result = new syncContactBySnsIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "syncContactBySnsIds failed: unknown result");
  }

  Future<Map<String, ContactRegistration>> syncContacts(int reqSeq, List<ContactModification> localContacts) async {
    oprot.writeMessageBegin(new TMessage("syncContacts", TMessageType.CALL, nextSeqid()));
    syncContacts_args args = new syncContacts_args();
    args.reqSeq = reqSeq;
    args.localContacts = localContacts;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    syncContacts_result result = new syncContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "syncContacts failed: unknown result");
  }

  Future<Message> trySendMessage(int seq, Message message) async {
    oprot.writeMessageBegin(new TMessage("trySendMessage", TMessageType.CALL, nextSeqid()));
    trySendMessage_args args = new trySendMessage_args();
    args.seq = seq;
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    trySendMessage_result result = new trySendMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "trySendMessage failed: unknown result");
  }

  Future<List<Message>> getNextMessagesV2(String messageBoxId, MessageBoxV2MessageId startMessageId, int messagesCount) async {
    oprot.writeMessageBegin(new TMessage("getNextMessagesV2", TMessageType.CALL, nextSeqid()));
    getNextMessagesV2_args args = new getNextMessagesV2_args();
    args.messageBoxId = messageBoxId;
    args.startMessageId = startMessageId;
    args.messagesCount = messagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getNextMessagesV2_result result = new getNextMessagesV2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getNextMessagesV2 failed: unknown result");
  }

  Future<TMessageBoxWrapUp> getMessageBoxCompactWrapUpV2(String messageBoxId) async {
    oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUpV2", TMessageType.CALL, nextSeqid()));
    getMessageBoxCompactWrapUpV2_args args = new getMessageBoxCompactWrapUpV2_args();
    args.messageBoxId = messageBoxId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMessageBoxCompactWrapUpV2_result result = new getMessageBoxCompactWrapUpV2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMessageBoxCompactWrapUpV2 failed: unknown result");
  }

  Future<List<Message>> getRecentMessagesV2(String messageBoxId, int messagesCount) async {
    oprot.writeMessageBegin(new TMessage("getRecentMessagesV2", TMessageType.CALL, nextSeqid()));
    getRecentMessagesV2_args args = new getRecentMessagesV2_args();
    args.messageBoxId = messageBoxId;
    args.messagesCount = messagesCount;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRecentMessagesV2_result result = new getRecentMessagesV2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRecentMessagesV2 failed: unknown result");
  }

  Future<Map<String, String>> validateContactsOnBot(List<String> contacts) async {
    oprot.writeMessageBegin(new TMessage("validateContactsOnBot", TMessageType.CALL, nextSeqid()));
    validateContactsOnBot_args args = new validateContactsOnBot_args();
    args.contacts = contacts;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    validateContactsOnBot_result result = new validateContactsOnBot_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "validateContactsOnBot failed: unknown result");
  }

  Future tryFriendRequest(String midOrEMid, int method, String friendRequestParams) async {
    oprot.writeMessageBegin(new TMessage("tryFriendRequest", TMessageType.CALL, nextSeqid()));
    tryFriendRequest_args args = new tryFriendRequest_args();
    args.midOrEMid = midOrEMid;
    args.method = method;
    args.friendRequestParams = friendRequestParams;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    tryFriendRequest_result result = new tryFriendRequest_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future unblockContact(int reqSeq, String id) async {
    oprot.writeMessageBegin(new TMessage("unblockContact", TMessageType.CALL, nextSeqid()));
    unblockContact_args args = new unblockContact_args();
    args.reqSeq = reqSeq;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    unblockContact_result result = new unblockContact_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future unblockRecommendation(int reqSeq, String id) async {
    oprot.writeMessageBegin(new TMessage("unblockRecommendation", TMessageType.CALL, nextSeqid()));
    unblockRecommendation_args args = new unblockRecommendation_args();
    args.reqSeq = reqSeq;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    unblockRecommendation_result result = new unblockRecommendation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> unregisterUserAndDevice() async {
    oprot.writeMessageBegin(new TMessage("unregisterUserAndDevice", TMessageType.CALL, nextSeqid()));
    unregisterUserAndDevice_args args = new unregisterUserAndDevice_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    unregisterUserAndDevice_result result = new unregisterUserAndDevice_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "unregisterUserAndDevice failed: unknown result");
  }

  Future updateApnsDeviceToken(Uint8List apnsDeviceToken) async {
    oprot.writeMessageBegin(new TMessage("updateApnsDeviceToken", TMessageType.CALL, nextSeqid()));
    updateApnsDeviceToken_args args = new updateApnsDeviceToken_args();
    args.apnsDeviceToken = apnsDeviceToken;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateApnsDeviceToken_result result = new updateApnsDeviceToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateBuddySetting(String key, String value) async {
    oprot.writeMessageBegin(new TMessage("updateBuddySetting", TMessageType.CALL, nextSeqid()));
    updateBuddySetting_args args = new updateBuddySetting_args();
    args.key = key;
    args.value = value;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateBuddySetting_result result = new updateBuddySetting_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateC2DMRegistrationId(String registrationId) async {
    oprot.writeMessageBegin(new TMessage("updateC2DMRegistrationId", TMessageType.CALL, nextSeqid()));
    updateC2DMRegistrationId_args args = new updateC2DMRegistrationId_args();
    args.registrationId = registrationId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateC2DMRegistrationId_result result = new updateC2DMRegistrationId_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateContactSetting(int reqSeq, String mid, int flag, String value) async {
    oprot.writeMessageBegin(new TMessage("updateContactSetting", TMessageType.CALL, nextSeqid()));
    updateContactSetting_args args = new updateContactSetting_args();
    args.reqSeq = reqSeq;
    args.mid = mid;
    args.flag = flag;
    args.value = value;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateContactSetting_result result = new updateContactSetting_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateCustomModeSettings(int customMode, Map<String, String> paramMap) async {
    oprot.writeMessageBegin(new TMessage("updateCustomModeSettings", TMessageType.CALL, nextSeqid()));
    updateCustomModeSettings_args args = new updateCustomModeSettings_args();
    args.customMode = customMode;
    args.paramMap = paramMap;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateCustomModeSettings_result result = new updateCustomModeSettings_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateDeviceInfo(String deviceUid, DeviceInfo deviceInfo) async {
    oprot.writeMessageBegin(new TMessage("updateDeviceInfo", TMessageType.CALL, nextSeqid()));
    updateDeviceInfo_args args = new updateDeviceInfo_args();
    args.deviceUid = deviceUid;
    args.deviceInfo = deviceInfo;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateDeviceInfo_result result = new updateDeviceInfo_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateGroup(int reqSeq, Group group) async {
    oprot.writeMessageBegin(new TMessage("updateGroup", TMessageType.CALL, nextSeqid()));
    updateGroup_args args = new updateGroup_args();
    args.reqSeq = reqSeq;
    args.group = group;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateGroup_result result = new updateGroup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateNotificationToken(int type, String token) async {
    oprot.writeMessageBegin(new TMessage("updateNotificationToken", TMessageType.CALL, nextSeqid()));
    updateNotificationToken_args args = new updateNotificationToken_args();
    args.type = type;
    args.token = token;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateNotificationToken_result result = new updateNotificationToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateNotificationTokenWithBytes(int type, Uint8List token) async {
    oprot.writeMessageBegin(new TMessage("updateNotificationTokenWithBytes", TMessageType.CALL, nextSeqid()));
    updateNotificationTokenWithBytes_args args = new updateNotificationTokenWithBytes_args();
    args.type = type;
    args.token = token;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateNotificationTokenWithBytes_result result = new updateNotificationTokenWithBytes_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateProfile(int reqSeq, Profile profile) async {
    oprot.writeMessageBegin(new TMessage("updateProfile", TMessageType.CALL, nextSeqid()));
    updateProfile_args args = new updateProfile_args();
    args.reqSeq = reqSeq;
    args.profile = profile;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateProfile_result result = new updateProfile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateProfileAttribute(int reqSeq, int attr, String value) async {
    oprot.writeMessageBegin(new TMessage("updateProfileAttribute", TMessageType.CALL, nextSeqid()));
    updateProfileAttribute_args args = new updateProfileAttribute_args();
    args.reqSeq = reqSeq;
    args.attr = attr;
    args.value = value;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateProfileAttribute_result result = new updateProfileAttribute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateRegion(String region) async {
    oprot.writeMessageBegin(new TMessage("updateRegion", TMessageType.CALL, nextSeqid()));
    updateRegion_args args = new updateRegion_args();
    args.region = region;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateRegion_result result = new updateRegion_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateSettings(int reqSeq, Settings settings) async {
    oprot.writeMessageBegin(new TMessage("updateSettings", TMessageType.CALL, nextSeqid()));
    updateSettings_args args = new updateSettings_args();
    args.reqSeq = reqSeq;
    args.settings = settings;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateSettings_result result = new updateSettings_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<int> updateSettings2(int reqSeq, Settings settings) async {
    oprot.writeMessageBegin(new TMessage("updateSettings2", TMessageType.CALL, nextSeqid()));
    updateSettings2_args args = new updateSettings2_args();
    args.reqSeq = reqSeq;
    args.settings = settings;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateSettings2_result result = new updateSettings2_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "updateSettings2 failed: unknown result");
  }

  Future updateSettingsAttribute(int reqSeq, int attr, String value) async {
    oprot.writeMessageBegin(new TMessage("updateSettingsAttribute", TMessageType.CALL, nextSeqid()));
    updateSettingsAttribute_args args = new updateSettingsAttribute_args();
    args.reqSeq = reqSeq;
    args.attr = attr;
    args.value = value;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateSettingsAttribute_result result = new updateSettingsAttribute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<int> updateSettingsAttributes(int reqSeq, int attrBitset, Settings settings) async {
    oprot.writeMessageBegin(new TMessage("updateSettingsAttributes", TMessageType.CALL, nextSeqid()));
    updateSettingsAttributes_args args = new updateSettingsAttributes_args();
    args.reqSeq = reqSeq;
    args.attrBitset = attrBitset;
    args.settings = settings;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateSettingsAttributes_result result = new updateSettingsAttributes_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "updateSettingsAttributes failed: unknown result");
  }

  Future verifyIdentityCredential(int identityProvider, String identifier, String password) async {
    oprot.writeMessageBegin(new TMessage("verifyIdentityCredential", TMessageType.CALL, nextSeqid()));
    verifyIdentityCredential_args args = new verifyIdentityCredential_args();
    args.identityProvider = identityProvider;
    args.identifier = identifier;
    args.password = password;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyIdentityCredential_result result = new verifyIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<UserAuthStatus> verifyIdentityCredentialWithResult(IdentityCredential identityCredential) async {
    oprot.writeMessageBegin(new TMessage("verifyIdentityCredentialWithResult", TMessageType.CALL, nextSeqid()));
    verifyIdentityCredentialWithResult_args args = new verifyIdentityCredentialWithResult_args();
    args.identityCredential = identityCredential;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyIdentityCredentialWithResult_result result = new verifyIdentityCredentialWithResult_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "verifyIdentityCredentialWithResult failed: unknown result");
  }

  Future<int> verifyPhone(String sessionId, String pinCode, String udidHash) async {
    oprot.writeMessageBegin(new TMessage("verifyPhone", TMessageType.CALL, nextSeqid()));
    verifyPhone_args args = new verifyPhone_args();
    args.sessionId = sessionId;
    args.pinCode = pinCode;
    args.udidHash = udidHash;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyPhone_result result = new verifyPhone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "verifyPhone failed: unknown result");
  }

  Future<String> verifyQrcode(String verifier, String pinCode) async {
    oprot.writeMessageBegin(new TMessage("verifyQrcode", TMessageType.CALL, nextSeqid()));
    verifyQrcode_args args = new verifyQrcode_args();
    args.verifier = verifier;
    args.pinCode = pinCode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyQrcode_result result = new verifyQrcode_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "verifyQrcode failed: unknown result");
  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class TalkServiceProcessor implements TProcessor {
  TalkServiceProcessor(TalkService iface) {
    iface_ = iface;
    PROCESS_MAP["getChatRoomAnnouncementsBulk"] = getChatRoomAnnouncementsBulk;
    PROCESS_MAP["getChatRoomAnnouncements"] = getChatRoomAnnouncements;
    PROCESS_MAP["createChatRoomAnnouncement"] = createChatRoomAnnouncement;
    PROCESS_MAP["removeChatRoomAnnouncement"] = removeChatRoomAnnouncement;
    PROCESS_MAP["unsendMessage"] = unsendMessage;
    PROCESS_MAP["getGroupWithoutMembers"] = getGroupWithoutMembers;
    PROCESS_MAP["requestResendMessage"] = requestResendMessage;
    PROCESS_MAP["respondResendMessage"] = respondResendMessage;
    PROCESS_MAP["acceptGroupInvitation"] = acceptGroupInvitation;
    PROCESS_MAP["acceptGroupInvitationByTicket"] = acceptGroupInvitationByTicket;
    PROCESS_MAP["acceptProximityMatches"] = acceptProximityMatches;
    PROCESS_MAP["acquireCallRoute"] = acquireCallRoute;
    PROCESS_MAP["acquireCallTicket"] = acquireCallTicket;
    PROCESS_MAP["acquireEncryptedAccessToken"] = acquireEncryptedAccessToken;
    PROCESS_MAP["addSnsId"] = addSnsId;
    PROCESS_MAP["blockContact"] = blockContact;
    PROCESS_MAP["blockRecommendation"] = blockRecommendation;
    PROCESS_MAP["cancelGroupInvitation"] = cancelGroupInvitation;
    PROCESS_MAP["changeVerificationMethod"] = changeVerificationMethod;
    PROCESS_MAP["clearIdentityCredential"] = clearIdentityCredential;
    PROCESS_MAP["clearMessageBox"] = clearMessageBox;
    PROCESS_MAP["closeProximityMatch"] = closeProximityMatch;
    PROCESS_MAP["commitSendMessage"] = commitSendMessage;
    PROCESS_MAP["commitSendMessages"] = commitSendMessages;
    PROCESS_MAP["commitUpdateProfile"] = commitUpdateProfile;
    PROCESS_MAP["confirmEmail"] = confirmEmail;
    PROCESS_MAP["createGroup"] = createGroup;
    PROCESS_MAP["createQrcodeBase64Image"] = createQrcodeBase64Image;
    PROCESS_MAP["createRoom"] = createRoom;
    PROCESS_MAP["createSession"] = createSession;
    PROCESS_MAP["fetchAnnouncements"] = fetchAnnouncements;
    PROCESS_MAP["fetchMessages"] = fetchMessages;
    PROCESS_MAP["fetchOperations"] = fetchOperations;
    PROCESS_MAP["fetchOps"] = fetchOps;
    PROCESS_MAP["findAndAddContactsByEmail"] = findAndAddContactsByEmail;
    PROCESS_MAP["findAndAddContactsByMid"] = findAndAddContactsByMid;
    PROCESS_MAP["findGroupByTicketV2"] = findGroupByTicketV2;
    PROCESS_MAP["findAndAddContactsByPhone"] = findAndAddContactsByPhone;
    PROCESS_MAP["getFriendRequests"] = getFriendRequests;
    PROCESS_MAP["removeFriendRequest"] = removeFriendRequest;
    PROCESS_MAP["findAndAddContactsByUserid"] = findAndAddContactsByUserid;
    PROCESS_MAP["findContactByUserid"] = findContactByUserid;
    PROCESS_MAP["findContactByUserTicket"] = findContactByUserTicket;
    PROCESS_MAP["findContactsByEmail"] = findContactsByEmail;
    PROCESS_MAP["findContactsByPhone"] = findContactsByPhone;
    PROCESS_MAP["findSnsIdUserStatus"] = findSnsIdUserStatus;
    PROCESS_MAP["finishUpdateVerification"] = finishUpdateVerification;
    PROCESS_MAP["generateUserTicket"] = generateUserTicket;
    PROCESS_MAP["destroyMessage"] = destroyMessage;
    PROCESS_MAP["getAcceptedProximityMatches"] = getAcceptedProximityMatches;
    PROCESS_MAP["getActiveBuddySubscriberIds"] = getActiveBuddySubscriberIds;
    PROCESS_MAP["getAllContactIds"] = getAllContactIds;
    PROCESS_MAP["getAuthQrcode"] = getAuthQrcode;
    PROCESS_MAP["getBlockedContactIds"] = getBlockedContactIds;
    PROCESS_MAP["registerWithPhoneNumber"] = registerWithPhoneNumber;
    PROCESS_MAP["registerWithPhoneNumberAndPassword"] = registerWithPhoneNumberAndPassword;
    PROCESS_MAP["getAnalyticsInfo"] = getAnalyticsInfo;
    PROCESS_MAP["reportClientStatistics"] = reportClientStatistics;
    PROCESS_MAP["verifyPhoneNumberForLogin"] = verifyPhoneNumberForLogin;
    PROCESS_MAP["verifyPhoneNumber"] = verifyPhoneNumber;
    PROCESS_MAP["getBlockedContactIdsByRange"] = getBlockedContactIdsByRange;
    PROCESS_MAP["getBlockedRecommendationIds"] = getBlockedRecommendationIds;
    PROCESS_MAP["getBuddyBlockerIds"] = getBuddyBlockerIds;
    PROCESS_MAP["getBuddyLocation"] = getBuddyLocation;
    PROCESS_MAP["getCompactContactsModifiedSince"] = getCompactContactsModifiedSince;
    PROCESS_MAP["getCompactGroup"] = getCompactGroup;
    PROCESS_MAP["getCompactRoom"] = getCompactRoom;
    PROCESS_MAP["getContact"] = getContact;
    PROCESS_MAP["getContacts"] = getContacts;
    PROCESS_MAP["getContactWithFriendRequestStatus"] = getContactWithFriendRequestStatus;
    PROCESS_MAP["getCountryWithRequestIp"] = getCountryWithRequestIp;
    PROCESS_MAP["getFavoriteMids"] = getFavoriteMids;
    PROCESS_MAP["getGroup"] = getGroup;
    PROCESS_MAP["getGroupIdsInvited"] = getGroupIdsInvited;
    PROCESS_MAP["getGroupIdsJoined"] = getGroupIdsJoined;
    PROCESS_MAP["getGroups"] = getGroups;
    PROCESS_MAP["getHiddenContactMids"] = getHiddenContactMids;
    PROCESS_MAP["getIdentityIdentifier"] = getIdentityIdentifier;
    PROCESS_MAP["getLastAnnouncementIndex"] = getLastAnnouncementIndex;
    PROCESS_MAP["getLastOpRevision"] = getLastOpRevision;
    PROCESS_MAP["getSuggestRevisions"] = getSuggestRevisions;
    PROCESS_MAP["getPreviousMessagesV2WithReadCount"] = getPreviousMessagesV2WithReadCount;
    PROCESS_MAP["getMessageBox"] = getMessageBox;
    PROCESS_MAP["getMessageBoxCompactWrapUp"] = getMessageBoxCompactWrapUp;
    PROCESS_MAP["getMessageBoxCompactWrapUpList"] = getMessageBoxCompactWrapUpList;
    PROCESS_MAP["getMessageBoxList"] = getMessageBoxList;
    PROCESS_MAP["getMessageBoxListByStatus"] = getMessageBoxListByStatus;
    PROCESS_MAP["getMessageBoxWrapUp"] = getMessageBoxWrapUp;
    PROCESS_MAP["getMessageBoxWrapUpList"] = getMessageBoxWrapUpList;
    PROCESS_MAP["getMessagesBySequenceNumber"] = getMessagesBySequenceNumber;
    PROCESS_MAP["getNextMessages"] = getNextMessages;
    PROCESS_MAP["getNotificationPolicy"] = getNotificationPolicy;
    PROCESS_MAP["getPreviousMessages"] = getPreviousMessages;
    PROCESS_MAP["getProfile"] = getProfile;
    PROCESS_MAP["getProximityMatchCandidateList"] = getProximityMatchCandidateList;
    PROCESS_MAP["getProximityMatchCandidates"] = getProximityMatchCandidates;
    PROCESS_MAP["getRecentMessages"] = getRecentMessages;
    PROCESS_MAP["getRecommendationIds"] = getRecommendationIds;
    PROCESS_MAP["getRoom"] = getRoom;
    PROCESS_MAP["getRSAKeyInfo"] = getRSAKeyInfo;
    PROCESS_MAP["getServerTime"] = getServerTime;
    PROCESS_MAP["getSessions"] = getSessions;
    PROCESS_MAP["getSettings"] = getSettings;
    PROCESS_MAP["getGroupsV2"] = getGroupsV2;
    PROCESS_MAP["getSettingsAttributes"] = getSettingsAttributes;
    PROCESS_MAP["getSystemConfiguration"] = getSystemConfiguration;
    PROCESS_MAP["getUserTicket"] = getUserTicket;
    PROCESS_MAP["getWapInvitation"] = getWapInvitation;
    PROCESS_MAP["invalidateUserTicket"] = invalidateUserTicket;
    PROCESS_MAP["inviteFriendsBySms"] = inviteFriendsBySms;
    PROCESS_MAP["inviteIntoGroup"] = inviteIntoGroup;
    PROCESS_MAP["inviteIntoRoom"] = inviteIntoRoom;
    PROCESS_MAP["inviteViaEmail"] = inviteViaEmail;
    PROCESS_MAP["isIdentityIdentifierAvailable"] = isIdentityIdentifierAvailable;
    PROCESS_MAP["isUseridAvailable"] = isUseridAvailable;
    PROCESS_MAP["kickoutFromGroup"] = kickoutFromGroup;
    PROCESS_MAP["reissueGroupTicket"] = reissueGroupTicket;
    PROCESS_MAP["findGroupByTicket"] = findGroupByTicket;
    PROCESS_MAP["leaveGroup"] = leaveGroup;
    PROCESS_MAP["leaveRoom"] = leaveRoom;
    PROCESS_MAP["loginWithIdentityCredential"] = loginWithIdentityCredential;
    PROCESS_MAP["loginWithIdentityCredentialForCertificate"] = loginWithIdentityCredentialForCertificate;
    PROCESS_MAP["loginWithVerifier"] = loginWithVerifier;
    PROCESS_MAP["loginWithVerifierForCerificate"] = loginWithVerifierForCerificate;
    PROCESS_MAP["loginWithVerifierForCertificate"] = loginWithVerifierForCertificate;
    PROCESS_MAP["logout"] = logout;
    PROCESS_MAP["logoutSession"] = logoutSession;
    PROCESS_MAP["noop"] = noop;
    PROCESS_MAP["notifiedRedirect"] = notifiedRedirect;
    PROCESS_MAP["notifyBuddyOnAir"] = notifyBuddyOnAir;
    PROCESS_MAP["notifyIndividualEvent"] = notifyIndividualEvent;
    PROCESS_MAP["notifyInstalled"] = notifyInstalled;
    PROCESS_MAP["notifyRegistrationComplete"] = notifyRegistrationComplete;
    PROCESS_MAP["notifySleep"] = notifySleep;
    PROCESS_MAP["notifyUpdated"] = notifyUpdated;
    PROCESS_MAP["openProximityMatch"] = openProximityMatch;
    PROCESS_MAP["registerBuddyUser"] = registerBuddyUser;
    PROCESS_MAP["registerBuddyUserid"] = registerBuddyUserid;
    PROCESS_MAP["registerDevice"] = registerDevice;
    PROCESS_MAP["registerDeviceWithIdentityCredential"] = registerDeviceWithIdentityCredential;
    PROCESS_MAP["registerDeviceWithoutPhoneNumber"] = registerDeviceWithoutPhoneNumber;
    PROCESS_MAP["registerDeviceWithoutPhoneNumberWithIdentityCredential"] = registerDeviceWithoutPhoneNumberWithIdentityCredential;
    PROCESS_MAP["registerUserid"] = registerUserid;
    PROCESS_MAP["registerWapDevice"] = registerWapDevice;
    PROCESS_MAP["registerWithExistingSnsIdAndIdentityCredential"] = registerWithExistingSnsIdAndIdentityCredential;
    PROCESS_MAP["registerWithSnsId"] = registerWithSnsId;
    PROCESS_MAP["registerWithSnsIdAndIdentityCredential"] = registerWithSnsIdAndIdentityCredential;
    PROCESS_MAP["reissueDeviceCredential"] = reissueDeviceCredential;
    PROCESS_MAP["reissueUserTicket"] = reissueUserTicket;
    PROCESS_MAP["getMessageReadRange"] = getMessageReadRange;
    PROCESS_MAP["rejectGroupInvitation"] = rejectGroupInvitation;
    PROCESS_MAP["releaseSession"] = releaseSession;
    PROCESS_MAP["removeAllMessages"] = removeAllMessages;
    PROCESS_MAP["removeBuddyLocation"] = removeBuddyLocation;
    PROCESS_MAP["removeMessage"] = removeMessage;
    PROCESS_MAP["makeUserAddMyselfAsContact"] = makeUserAddMyselfAsContact;
    PROCESS_MAP["removeMessageFromMyHome"] = removeMessageFromMyHome;
    PROCESS_MAP["removeSnsId"] = removeSnsId;
    PROCESS_MAP["report"] = report;
    PROCESS_MAP["reportContacts"] = reportContacts;
    PROCESS_MAP["reportGroups"] = reportGroups;
    PROCESS_MAP["reportProfile"] = reportProfile;
    PROCESS_MAP["reportRooms"] = reportRooms;
    PROCESS_MAP["findAndAddContactByMetaTag"] = findAndAddContactByMetaTag;
    PROCESS_MAP["reportSettings"] = reportSettings;
    PROCESS_MAP["reportSpam"] = reportSpam;
    PROCESS_MAP["reportSpammer"] = reportSpammer;
    PROCESS_MAP["requestAccountPasswordReset"] = requestAccountPasswordReset;
    PROCESS_MAP["requestEmailConfirmation"] = requestEmailConfirmation;
    PROCESS_MAP["requestIdentityUnbind"] = requestIdentityUnbind;
    PROCESS_MAP["resendEmailConfirmation"] = resendEmailConfirmation;
    PROCESS_MAP["resendPinCode"] = resendPinCode;
    PROCESS_MAP["resendPinCodeBySMS"] = resendPinCodeBySMS;
    PROCESS_MAP["sendChatChecked"] = sendChatChecked;
    PROCESS_MAP["sendMessageAwaitCommit"] = sendMessageAwaitCommit;
    PROCESS_MAP["sendChatRemoved"] = sendChatRemoved;
    PROCESS_MAP["sendContentPreviewUpdated"] = sendContentPreviewUpdated;
    PROCESS_MAP["sendContentReceipt"] = sendContentReceipt;
    PROCESS_MAP["sendDummyPush"] = sendDummyPush;
    PROCESS_MAP["removeE2EEPublicKey"] = removeE2EEPublicKey;
    PROCESS_MAP["negotiateE2EEPublicKey"] = negotiateE2EEPublicKey;
    PROCESS_MAP["getE2EEPublicKey"] = getE2EEPublicKey;
    PROCESS_MAP["requestE2EEKeyExchange"] = requestE2EEKeyExchange;
    PROCESS_MAP["getLastE2EEPublicKeys"] = getLastE2EEPublicKeys;
    PROCESS_MAP["registerE2EEPublicKey"] = registerE2EEPublicKey;
    PROCESS_MAP["getE2EEPublicKeys"] = getE2EEPublicKeys;
    PROCESS_MAP["getE2EEPublicKeysEx"] = getE2EEPublicKeysEx;
    PROCESS_MAP["getReadMessageOpsInBulk"] = getReadMessageOpsInBulk;
    PROCESS_MAP["sendEvent"] = sendEvent;
    PROCESS_MAP["sendMessage"] = sendMessage;
    PROCESS_MAP["sendMessageIgnored"] = sendMessageIgnored;
    PROCESS_MAP["sendMessageReceipt"] = sendMessageReceipt;
    PROCESS_MAP["findContactByMetaTag"] = findContactByMetaTag;
    PROCESS_MAP["sendMessageToMyHome"] = sendMessageToMyHome;
    PROCESS_MAP["setBuddyLocation"] = setBuddyLocation;
    PROCESS_MAP["setIdentityCredential"] = setIdentityCredential;
    PROCESS_MAP["setNotificationsEnabled"] = setNotificationsEnabled;
    PROCESS_MAP["startUpdateVerification"] = startUpdateVerification;
    PROCESS_MAP["startVerification"] = startVerification;
    PROCESS_MAP["updateGroupPreferenceAttribute"] = updateGroupPreferenceAttribute;
    PROCESS_MAP["createRoomV2"] = createRoomV2;
    PROCESS_MAP["storeUpdateProfileAttribute"] = storeUpdateProfileAttribute;
    PROCESS_MAP["syncContactBySnsIds"] = syncContactBySnsIds;
    PROCESS_MAP["syncContacts"] = syncContacts;
    PROCESS_MAP["trySendMessage"] = trySendMessage;
    PROCESS_MAP["getNextMessagesV2"] = getNextMessagesV2;
    PROCESS_MAP["getMessageBoxCompactWrapUpV2"] = getMessageBoxCompactWrapUpV2;
    PROCESS_MAP["getRecentMessagesV2"] = getRecentMessagesV2;
    PROCESS_MAP["validateContactsOnBot"] = validateContactsOnBot;
    PROCESS_MAP["tryFriendRequest"] = tryFriendRequest;
    PROCESS_MAP["unblockContact"] = unblockContact;
    PROCESS_MAP["unblockRecommendation"] = unblockRecommendation;
    PROCESS_MAP["unregisterUserAndDevice"] = unregisterUserAndDevice;
    PROCESS_MAP["updateApnsDeviceToken"] = updateApnsDeviceToken;
    PROCESS_MAP["updateBuddySetting"] = updateBuddySetting;
    PROCESS_MAP["updateC2DMRegistrationId"] = updateC2DMRegistrationId;
    PROCESS_MAP["updateContactSetting"] = updateContactSetting;
    PROCESS_MAP["updateCustomModeSettings"] = updateCustomModeSettings;
    PROCESS_MAP["updateDeviceInfo"] = updateDeviceInfo;
    PROCESS_MAP["updateGroup"] = updateGroup;
    PROCESS_MAP["updateNotificationToken"] = updateNotificationToken;
    PROCESS_MAP["updateNotificationTokenWithBytes"] = updateNotificationTokenWithBytes;
    PROCESS_MAP["updateProfile"] = updateProfile;
    PROCESS_MAP["updateProfileAttribute"] = updateProfileAttribute;
    PROCESS_MAP["updateRegion"] = updateRegion;
    PROCESS_MAP["updateSettings"] = updateSettings;
    PROCESS_MAP["updateSettings2"] = updateSettings2;
    PROCESS_MAP["updateSettingsAttribute"] = updateSettingsAttribute;
    PROCESS_MAP["updateSettingsAttributes"] = updateSettingsAttributes;
    PROCESS_MAP["verifyIdentityCredential"] = verifyIdentityCredential;
    PROCESS_MAP["verifyIdentityCredentialWithResult"] = verifyIdentityCredentialWithResult;
    PROCESS_MAP["verifyPhone"] = verifyPhone;
    PROCESS_MAP["verifyQrcode"] = verifyQrcode;
  }

  TalkService iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  getChatRoomAnnouncementsBulk(int seqid, TProtocol iprot, TProtocol oprot) async {
    getChatRoomAnnouncementsBulk_args args = new getChatRoomAnnouncementsBulk_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getChatRoomAnnouncementsBulk_result result = new getChatRoomAnnouncementsBulk_result();
    try {
      result.success = await iface_.getChatRoomAnnouncementsBulk(args.chatRoomMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getChatRoomAnnouncementsBulk");
      oprot.writeMessageBegin(new TMessage("getChatRoomAnnouncementsBulk", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getChatRoomAnnouncementsBulk", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getChatRoomAnnouncements(int seqid, TProtocol iprot, TProtocol oprot) async {
    getChatRoomAnnouncements_args args = new getChatRoomAnnouncements_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getChatRoomAnnouncements_result result = new getChatRoomAnnouncements_result();
    try {
      result.success = await iface_.getChatRoomAnnouncements(args.chatRoomMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getChatRoomAnnouncements");
      oprot.writeMessageBegin(new TMessage("getChatRoomAnnouncements", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getChatRoomAnnouncements", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createChatRoomAnnouncement(int seqid, TProtocol iprot, TProtocol oprot) async {
    createChatRoomAnnouncement_args args = new createChatRoomAnnouncement_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createChatRoomAnnouncement_result result = new createChatRoomAnnouncement_result();
    try {
      result.success = await iface_.createChatRoomAnnouncement(args.reqSeq, args.chatRoomMid, args.type, args.contents);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createChatRoomAnnouncement");
      oprot.writeMessageBegin(new TMessage("createChatRoomAnnouncement", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createChatRoomAnnouncement", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeChatRoomAnnouncement(int seqid, TProtocol iprot, TProtocol oprot) {
    removeChatRoomAnnouncement_args args = new removeChatRoomAnnouncement_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeChatRoomAnnouncement_result result = new removeChatRoomAnnouncement_result();
    try {
      iface_.removeChatRoomAnnouncement(args.reqSeq, args.chatRoomMid, args.announcementSeq);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeChatRoomAnnouncement");
      oprot.writeMessageBegin(new TMessage("removeChatRoomAnnouncement", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeChatRoomAnnouncement", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  unsendMessage(int seqid, TProtocol iprot, TProtocol oprot) {
    unsendMessage_args args = new unsendMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    unsendMessage_result result = new unsendMessage_result();
    try {
      iface_.unsendMessage(args.seq, args.messageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing unsendMessage");
      oprot.writeMessageBegin(new TMessage("unsendMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("unsendMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupWithoutMembers(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupWithoutMembers_args args = new getGroupWithoutMembers_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupWithoutMembers_result result = new getGroupWithoutMembers_result();
    try {
      result.success = await iface_.getGroupWithoutMembers(args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupWithoutMembers");
      oprot.writeMessageBegin(new TMessage("getGroupWithoutMembers", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupWithoutMembers", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  requestResendMessage(int seqid, TProtocol iprot, TProtocol oprot) {
    requestResendMessage_args args = new requestResendMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    requestResendMessage_result result = new requestResendMessage_result();
    try {
      iface_.requestResendMessage(args.reqSeq, args.senderMid, args.messageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing requestResendMessage");
      oprot.writeMessageBegin(new TMessage("requestResendMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("requestResendMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  respondResendMessage(int seqid, TProtocol iprot, TProtocol oprot) {
    respondResendMessage_args args = new respondResendMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    respondResendMessage_result result = new respondResendMessage_result();
    try {
      iface_.respondResendMessage(args.reqSeq, args.receiverMid, args.originalMessageId, args.resendMessage, args.errorCode);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing respondResendMessage");
      oprot.writeMessageBegin(new TMessage("respondResendMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("respondResendMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acceptGroupInvitation(int seqid, TProtocol iprot, TProtocol oprot) {
    acceptGroupInvitation_args args = new acceptGroupInvitation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acceptGroupInvitation_result result = new acceptGroupInvitation_result();
    try {
      iface_.acceptGroupInvitation(args.reqSeq, args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acceptGroupInvitation");
      oprot.writeMessageBegin(new TMessage("acceptGroupInvitation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acceptGroupInvitation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acceptGroupInvitationByTicket(int seqid, TProtocol iprot, TProtocol oprot) {
    acceptGroupInvitationByTicket_args args = new acceptGroupInvitationByTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acceptGroupInvitationByTicket_result result = new acceptGroupInvitationByTicket_result();
    try {
      iface_.acceptGroupInvitationByTicket(args.reqSeq, args.groupMid, args.ticketId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acceptGroupInvitationByTicket");
      oprot.writeMessageBegin(new TMessage("acceptGroupInvitationByTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acceptGroupInvitationByTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acceptProximityMatches(int seqid, TProtocol iprot, TProtocol oprot) {
    acceptProximityMatches_args args = new acceptProximityMatches_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acceptProximityMatches_result result = new acceptProximityMatches_result();
    try {
      iface_.acceptProximityMatches(args.sessionId, args.ids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acceptProximityMatches");
      oprot.writeMessageBegin(new TMessage("acceptProximityMatches", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acceptProximityMatches", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acquireCallRoute(int seqid, TProtocol iprot, TProtocol oprot) async {
    acquireCallRoute_args args = new acquireCallRoute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acquireCallRoute_result result = new acquireCallRoute_result();
    try {
      result.success = await iface_.acquireCallRoute(args.to);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acquireCallRoute");
      oprot.writeMessageBegin(new TMessage("acquireCallRoute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acquireCallRoute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acquireCallTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    acquireCallTicket_args args = new acquireCallTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acquireCallTicket_result result = new acquireCallTicket_result();
    try {
      result.success = await iface_.acquireCallTicket(args.to);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acquireCallTicket");
      oprot.writeMessageBegin(new TMessage("acquireCallTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acquireCallTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acquireEncryptedAccessToken(int seqid, TProtocol iprot, TProtocol oprot) async {
    acquireEncryptedAccessToken_args args = new acquireEncryptedAccessToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acquireEncryptedAccessToken_result result = new acquireEncryptedAccessToken_result();
    try {
      result.success = await iface_.acquireEncryptedAccessToken(args.featureType);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acquireEncryptedAccessToken");
      oprot.writeMessageBegin(new TMessage("acquireEncryptedAccessToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acquireEncryptedAccessToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  addSnsId(int seqid, TProtocol iprot, TProtocol oprot) async {
    addSnsId_args args = new addSnsId_args();
    args.read(iprot);
    iprot.readMessageEnd();
    addSnsId_result result = new addSnsId_result();
    try {
      result.success = await iface_.addSnsId(args.snsIdType, args.snsAccessToken);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing addSnsId");
      oprot.writeMessageBegin(new TMessage("addSnsId", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("addSnsId", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  blockContact(int seqid, TProtocol iprot, TProtocol oprot) {
    blockContact_args args = new blockContact_args();
    args.read(iprot);
    iprot.readMessageEnd();
    blockContact_result result = new blockContact_result();
    try {
      iface_.blockContact(args.reqSeq, args.id);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing blockContact");
      oprot.writeMessageBegin(new TMessage("blockContact", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("blockContact", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  blockRecommendation(int seqid, TProtocol iprot, TProtocol oprot) {
    blockRecommendation_args args = new blockRecommendation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    blockRecommendation_result result = new blockRecommendation_result();
    try {
      iface_.blockRecommendation(args.reqSeq, args.id);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing blockRecommendation");
      oprot.writeMessageBegin(new TMessage("blockRecommendation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("blockRecommendation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  cancelGroupInvitation(int seqid, TProtocol iprot, TProtocol oprot) {
    cancelGroupInvitation_args args = new cancelGroupInvitation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    cancelGroupInvitation_result result = new cancelGroupInvitation_result();
    try {
      iface_.cancelGroupInvitation(args.reqSeq, args.groupId, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing cancelGroupInvitation");
      oprot.writeMessageBegin(new TMessage("cancelGroupInvitation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("cancelGroupInvitation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  changeVerificationMethod(int seqid, TProtocol iprot, TProtocol oprot) async {
    changeVerificationMethod_args args = new changeVerificationMethod_args();
    args.read(iprot);
    iprot.readMessageEnd();
    changeVerificationMethod_result result = new changeVerificationMethod_result();
    try {
      result.success = await iface_.changeVerificationMethod(args.sessionId, args.method);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing changeVerificationMethod");
      oprot.writeMessageBegin(new TMessage("changeVerificationMethod", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("changeVerificationMethod", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  clearIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) {
    clearIdentityCredential_args args = new clearIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    clearIdentityCredential_result result = new clearIdentityCredential_result();
    try {
      iface_.clearIdentityCredential();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing clearIdentityCredential");
      oprot.writeMessageBegin(new TMessage("clearIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("clearIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  clearMessageBox(int seqid, TProtocol iprot, TProtocol oprot) {
    clearMessageBox_args args = new clearMessageBox_args();
    args.read(iprot);
    iprot.readMessageEnd();
    clearMessageBox_result result = new clearMessageBox_result();
    try {
      iface_.clearMessageBox(args.channelId, args.messageBoxId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing clearMessageBox");
      oprot.writeMessageBegin(new TMessage("clearMessageBox", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("clearMessageBox", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  closeProximityMatch(int seqid, TProtocol iprot, TProtocol oprot) {
    closeProximityMatch_args args = new closeProximityMatch_args();
    args.read(iprot);
    iprot.readMessageEnd();
    closeProximityMatch_result result = new closeProximityMatch_result();
    try {
      iface_.closeProximityMatch(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing closeProximityMatch");
      oprot.writeMessageBegin(new TMessage("closeProximityMatch", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("closeProximityMatch", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  commitSendMessage(int seqid, TProtocol iprot, TProtocol oprot) async {
    commitSendMessage_args args = new commitSendMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    commitSendMessage_result result = new commitSendMessage_result();
    try {
      result.success = await iface_.commitSendMessage(args.seq, args.messageId, args.receiverMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing commitSendMessage");
      oprot.writeMessageBegin(new TMessage("commitSendMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("commitSendMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  commitSendMessages(int seqid, TProtocol iprot, TProtocol oprot) async {
    commitSendMessages_args args = new commitSendMessages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    commitSendMessages_result result = new commitSendMessages_result();
    try {
      result.success = await iface_.commitSendMessages(args.seq, args.messageIds, args.receiverMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing commitSendMessages");
      oprot.writeMessageBegin(new TMessage("commitSendMessages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("commitSendMessages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  commitUpdateProfile(int seqid, TProtocol iprot, TProtocol oprot) async {
    commitUpdateProfile_args args = new commitUpdateProfile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    commitUpdateProfile_result result = new commitUpdateProfile_result();
    try {
      result.success = await iface_.commitUpdateProfile(args.seq, args.attrs, args.receiverMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing commitUpdateProfile");
      oprot.writeMessageBegin(new TMessage("commitUpdateProfile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("commitUpdateProfile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  confirmEmail(int seqid, TProtocol iprot, TProtocol oprot) {
    confirmEmail_args args = new confirmEmail_args();
    args.read(iprot);
    iprot.readMessageEnd();
    confirmEmail_result result = new confirmEmail_result();
    try {
      iface_.confirmEmail(args.verifier, args.pinCode);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing confirmEmail");
      oprot.writeMessageBegin(new TMessage("confirmEmail", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("confirmEmail", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createGroup(int seqid, TProtocol iprot, TProtocol oprot) async {
    createGroup_args args = new createGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createGroup_result result = new createGroup_result();
    try {
      result.success = await iface_.createGroup(args.seq, args.name, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createGroup");
      oprot.writeMessageBegin(new TMessage("createGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createQrcodeBase64Image(int seqid, TProtocol iprot, TProtocol oprot) async {
    createQrcodeBase64Image_args args = new createQrcodeBase64Image_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createQrcodeBase64Image_result result = new createQrcodeBase64Image_result();
    try {
      result.success = await iface_.createQrcodeBase64Image(args.url, args.characterSet, args.imageSize, args.x, args.y, args.width, args.height);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createQrcodeBase64Image");
      oprot.writeMessageBegin(new TMessage("createQrcodeBase64Image", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createQrcodeBase64Image", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createRoom(int seqid, TProtocol iprot, TProtocol oprot) async {
    createRoom_args args = new createRoom_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createRoom_result result = new createRoom_result();
    try {
      result.success = await iface_.createRoom(args.reqSeq, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createRoom");
      oprot.writeMessageBegin(new TMessage("createRoom", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createRoom", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createSession(int seqid, TProtocol iprot, TProtocol oprot) async {
    createSession_args args = new createSession_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createSession_result result = new createSession_result();
    try {
      result.success = await iface_.createSession();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createSession");
      oprot.writeMessageBegin(new TMessage("createSession", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createSession", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  fetchAnnouncements(int seqid, TProtocol iprot, TProtocol oprot) async {
    fetchAnnouncements_args args = new fetchAnnouncements_args();
    args.read(iprot);
    iprot.readMessageEnd();
    fetchAnnouncements_result result = new fetchAnnouncements_result();
    try {
      result.success = await iface_.fetchAnnouncements(args.lastFetchedIndex);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing fetchAnnouncements");
      oprot.writeMessageBegin(new TMessage("fetchAnnouncements", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("fetchAnnouncements", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  fetchMessages(int seqid, TProtocol iprot, TProtocol oprot) async {
    fetchMessages_args args = new fetchMessages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    fetchMessages_result result = new fetchMessages_result();
    try {
      result.success = await iface_.fetchMessages(args.localTs, args.count);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing fetchMessages");
      oprot.writeMessageBegin(new TMessage("fetchMessages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("fetchMessages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  fetchOperations(int seqid, TProtocol iprot, TProtocol oprot) async {
    fetchOperations_args args = new fetchOperations_args();
    args.read(iprot);
    iprot.readMessageEnd();
    fetchOperations_result result = new fetchOperations_result();
    try {
      result.success = await iface_.fetchOperations(args.localRev, args.count);
    } on ShouldSyncException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing fetchOperations");
      oprot.writeMessageBegin(new TMessage("fetchOperations", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("fetchOperations", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  fetchOps(int seqid, TProtocol iprot, TProtocol oprot) async {
    fetchOps_args args = new fetchOps_args();
    args.read(iprot);
    iprot.readMessageEnd();
    fetchOps_result result = new fetchOps_result();
    try {
      result.success = await iface_.fetchOps(args.localRev, args.count, args.globalRev, args.individualRev);
    } on ShouldSyncException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing fetchOps");
      oprot.writeMessageBegin(new TMessage("fetchOps", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("fetchOps", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findAndAddContactsByEmail(int seqid, TProtocol iprot, TProtocol oprot) async {
    findAndAddContactsByEmail_args args = new findAndAddContactsByEmail_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findAndAddContactsByEmail_result result = new findAndAddContactsByEmail_result();
    try {
      result.success = await iface_.findAndAddContactsByEmail(args.reqSeq, args.emails);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findAndAddContactsByEmail");
      oprot.writeMessageBegin(new TMessage("findAndAddContactsByEmail", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByEmail", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findAndAddContactsByMid(int seqid, TProtocol iprot, TProtocol oprot) async {
    findAndAddContactsByMid_args args = new findAndAddContactsByMid_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findAndAddContactsByMid_result result = new findAndAddContactsByMid_result();
    try {
      result.success = await iface_.findAndAddContactsByMid(args.reqSeq, args.mid, args.type, args.reference);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findAndAddContactsByMid");
      oprot.writeMessageBegin(new TMessage("findAndAddContactsByMid", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByMid", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findGroupByTicketV2(int seqid, TProtocol iprot, TProtocol oprot) async {
    findGroupByTicketV2_args args = new findGroupByTicketV2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findGroupByTicketV2_result result = new findGroupByTicketV2_result();
    try {
      result.success = await iface_.findGroupByTicketV2(args.ticketId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findGroupByTicketV2");
      oprot.writeMessageBegin(new TMessage("findGroupByTicketV2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findGroupByTicketV2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findAndAddContactsByPhone(int seqid, TProtocol iprot, TProtocol oprot) async {
    findAndAddContactsByPhone_args args = new findAndAddContactsByPhone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findAndAddContactsByPhone_result result = new findAndAddContactsByPhone_result();
    try {
      result.success = await iface_.findAndAddContactsByPhone(args.reqSeq, args.phones);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findAndAddContactsByPhone");
      oprot.writeMessageBegin(new TMessage("findAndAddContactsByPhone", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByPhone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getFriendRequests(int seqid, TProtocol iprot, TProtocol oprot) async {
    getFriendRequests_args args = new getFriendRequests_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getFriendRequests_result result = new getFriendRequests_result();
    try {
      result.success = await iface_.getFriendRequests(args.direction, args.lastSeenSeqId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getFriendRequests");
      oprot.writeMessageBegin(new TMessage("getFriendRequests", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getFriendRequests", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeFriendRequest(int seqid, TProtocol iprot, TProtocol oprot) {
    removeFriendRequest_args args = new removeFriendRequest_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeFriendRequest_result result = new removeFriendRequest_result();
    try {
      iface_.removeFriendRequest(args.direction, args.midOrEMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeFriendRequest");
      oprot.writeMessageBegin(new TMessage("removeFriendRequest", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeFriendRequest", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findAndAddContactsByUserid(int seqid, TProtocol iprot, TProtocol oprot) async {
    findAndAddContactsByUserid_args args = new findAndAddContactsByUserid_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findAndAddContactsByUserid_result result = new findAndAddContactsByUserid_result();
    try {
      result.success = await iface_.findAndAddContactsByUserid(args.reqSeq, args.userid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findAndAddContactsByUserid");
      oprot.writeMessageBegin(new TMessage("findAndAddContactsByUserid", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findAndAddContactsByUserid", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findContactByUserid(int seqid, TProtocol iprot, TProtocol oprot) async {
    findContactByUserid_args args = new findContactByUserid_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findContactByUserid_result result = new findContactByUserid_result();
    try {
      result.success = await iface_.findContactByUserid(args.userid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findContactByUserid");
      oprot.writeMessageBegin(new TMessage("findContactByUserid", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findContactByUserid", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findContactByUserTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    findContactByUserTicket_args args = new findContactByUserTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findContactByUserTicket_result result = new findContactByUserTicket_result();
    try {
      result.success = await iface_.findContactByUserTicket(args.ticketIdWithTag);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findContactByUserTicket");
      oprot.writeMessageBegin(new TMessage("findContactByUserTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findContactByUserTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findContactsByEmail(int seqid, TProtocol iprot, TProtocol oprot) async {
    findContactsByEmail_args args = new findContactsByEmail_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findContactsByEmail_result result = new findContactsByEmail_result();
    try {
      result.success = await iface_.findContactsByEmail(args.emails);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findContactsByEmail");
      oprot.writeMessageBegin(new TMessage("findContactsByEmail", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findContactsByEmail", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findContactsByPhone(int seqid, TProtocol iprot, TProtocol oprot) async {
    findContactsByPhone_args args = new findContactsByPhone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findContactsByPhone_result result = new findContactsByPhone_result();
    try {
      result.success = await iface_.findContactsByPhone(args.phones);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findContactsByPhone");
      oprot.writeMessageBegin(new TMessage("findContactsByPhone", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findContactsByPhone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findSnsIdUserStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    findSnsIdUserStatus_args args = new findSnsIdUserStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findSnsIdUserStatus_result result = new findSnsIdUserStatus_result();
    try {
      result.success = await iface_.findSnsIdUserStatus(args.snsIdType, args.snsAccessToken, args.udidHash);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findSnsIdUserStatus");
      oprot.writeMessageBegin(new TMessage("findSnsIdUserStatus", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findSnsIdUserStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  finishUpdateVerification(int seqid, TProtocol iprot, TProtocol oprot) {
    finishUpdateVerification_args args = new finishUpdateVerification_args();
    args.read(iprot);
    iprot.readMessageEnd();
    finishUpdateVerification_result result = new finishUpdateVerification_result();
    try {
      iface_.finishUpdateVerification(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing finishUpdateVerification");
      oprot.writeMessageBegin(new TMessage("finishUpdateVerification", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("finishUpdateVerification", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  generateUserTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    generateUserTicket_args args = new generateUserTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    generateUserTicket_result result = new generateUserTicket_result();
    try {
      result.success = await iface_.generateUserTicket(args.expirationTime, args.maxUseCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing generateUserTicket");
      oprot.writeMessageBegin(new TMessage("generateUserTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("generateUserTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  destroyMessage(int seqid, TProtocol iprot, TProtocol oprot) {
    destroyMessage_args args = new destroyMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    destroyMessage_result result = new destroyMessage_result();
    try {
      iface_.destroyMessage(args.seq, args.chatId, args.messageId, args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing destroyMessage");
      oprot.writeMessageBegin(new TMessage("destroyMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("destroyMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getAcceptedProximityMatches(int seqid, TProtocol iprot, TProtocol oprot) async {
    getAcceptedProximityMatches_args args = new getAcceptedProximityMatches_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getAcceptedProximityMatches_result result = new getAcceptedProximityMatches_result();
    try {
      result.success = await iface_.getAcceptedProximityMatches(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getAcceptedProximityMatches");
      oprot.writeMessageBegin(new TMessage("getAcceptedProximityMatches", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getAcceptedProximityMatches", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getActiveBuddySubscriberIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getActiveBuddySubscriberIds_args args = new getActiveBuddySubscriberIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getActiveBuddySubscriberIds_result result = new getActiveBuddySubscriberIds_result();
    try {
      result.success = await iface_.getActiveBuddySubscriberIds();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getActiveBuddySubscriberIds");
      oprot.writeMessageBegin(new TMessage("getActiveBuddySubscriberIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getActiveBuddySubscriberIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getAllContactIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getAllContactIds_args args = new getAllContactIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getAllContactIds_result result = new getAllContactIds_result();
    try {
      result.success = await iface_.getAllContactIds();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getAllContactIds");
      oprot.writeMessageBegin(new TMessage("getAllContactIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getAllContactIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getAuthQrcode(int seqid, TProtocol iprot, TProtocol oprot) async {
    getAuthQrcode_args args = new getAuthQrcode_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getAuthQrcode_result result = new getAuthQrcode_result();
    try {
      result.success = await iface_.getAuthQrcode(args.keepLoggedIn, args.systemName);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getAuthQrcode");
      oprot.writeMessageBegin(new TMessage("getAuthQrcode", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getAuthQrcode", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getBlockedContactIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getBlockedContactIds_args args = new getBlockedContactIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getBlockedContactIds_result result = new getBlockedContactIds_result();
    try {
      result.success = await iface_.getBlockedContactIds();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getBlockedContactIds");
      oprot.writeMessageBegin(new TMessage("getBlockedContactIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getBlockedContactIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerWithPhoneNumber(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerWithPhoneNumber_args args = new registerWithPhoneNumber_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerWithPhoneNumber_result result = new registerWithPhoneNumber_result();
    try {
      result.success = await iface_.registerWithPhoneNumber(args.sessionId, args.migrationPincodeSessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerWithPhoneNumber");
      oprot.writeMessageBegin(new TMessage("registerWithPhoneNumber", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerWithPhoneNumber", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerWithPhoneNumberAndPassword(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerWithPhoneNumberAndPassword_args args = new registerWithPhoneNumberAndPassword_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerWithPhoneNumberAndPassword_result result = new registerWithPhoneNumberAndPassword_result();
    try {
      result.success = await iface_.registerWithPhoneNumberAndPassword(args.sessionId, args.keynm, args.encrypted);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerWithPhoneNumberAndPassword");
      oprot.writeMessageBegin(new TMessage("registerWithPhoneNumberAndPassword", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerWithPhoneNumberAndPassword", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getAnalyticsInfo(int seqid, TProtocol iprot, TProtocol oprot) async {
    getAnalyticsInfo_args args = new getAnalyticsInfo_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getAnalyticsInfo_result result = new getAnalyticsInfo_result();
    try {
      result.success = await iface_.getAnalyticsInfo();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getAnalyticsInfo");
      oprot.writeMessageBegin(new TMessage("getAnalyticsInfo", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getAnalyticsInfo", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportClientStatistics(int seqid, TProtocol iprot, TProtocol oprot) {
    reportClientStatistics_args args = new reportClientStatistics_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportClientStatistics_result result = new reportClientStatistics_result();
    try {
      iface_.reportClientStatistics(args.reqSeq, args.category, args.count);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportClientStatistics");
      oprot.writeMessageBegin(new TMessage("reportClientStatistics", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportClientStatistics", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  verifyPhoneNumberForLogin(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyPhoneNumberForLogin_args args = new verifyPhoneNumberForLogin_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyPhoneNumberForLogin_result result = new verifyPhoneNumberForLogin_result();
    try {
      result.success = await iface_.verifyPhoneNumberForLogin(args.verifierFromPhone, args.pinCodeForPhone, args.verifierFromLogin);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing verifyPhoneNumberForLogin");
      oprot.writeMessageBegin(new TMessage("verifyPhoneNumberForLogin", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("verifyPhoneNumberForLogin", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  verifyPhoneNumber(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyPhoneNumber_args args = new verifyPhoneNumber_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyPhoneNumber_result result = new verifyPhoneNumber_result();
    try {
      result.success = await iface_.verifyPhoneNumber(args.sessionId, args.pinCode, args.udidHash, args.migrationPincodeSessionId, args.oldUdidHash);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing verifyPhoneNumber");
      oprot.writeMessageBegin(new TMessage("verifyPhoneNumber", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("verifyPhoneNumber", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getBlockedContactIdsByRange(int seqid, TProtocol iprot, TProtocol oprot) async {
    getBlockedContactIdsByRange_args args = new getBlockedContactIdsByRange_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getBlockedContactIdsByRange_result result = new getBlockedContactIdsByRange_result();
    try {
      result.success = await iface_.getBlockedContactIdsByRange(args.start, args.count);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getBlockedContactIdsByRange");
      oprot.writeMessageBegin(new TMessage("getBlockedContactIdsByRange", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getBlockedContactIdsByRange", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getBlockedRecommendationIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getBlockedRecommendationIds_args args = new getBlockedRecommendationIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getBlockedRecommendationIds_result result = new getBlockedRecommendationIds_result();
    try {
      result.success = await iface_.getBlockedRecommendationIds();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getBlockedRecommendationIds");
      oprot.writeMessageBegin(new TMessage("getBlockedRecommendationIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getBlockedRecommendationIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getBuddyBlockerIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getBuddyBlockerIds_args args = new getBuddyBlockerIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getBuddyBlockerIds_result result = new getBuddyBlockerIds_result();
    try {
      result.success = await iface_.getBuddyBlockerIds();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getBuddyBlockerIds");
      oprot.writeMessageBegin(new TMessage("getBuddyBlockerIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getBuddyBlockerIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getBuddyLocation(int seqid, TProtocol iprot, TProtocol oprot) async {
    getBuddyLocation_args args = new getBuddyLocation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getBuddyLocation_result result = new getBuddyLocation_result();
    try {
      result.success = await iface_.getBuddyLocation(args.mid, args.index);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getBuddyLocation");
      oprot.writeMessageBegin(new TMessage("getBuddyLocation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getBuddyLocation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCompactContactsModifiedSince(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCompactContactsModifiedSince_args args = new getCompactContactsModifiedSince_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCompactContactsModifiedSince_result result = new getCompactContactsModifiedSince_result();
    try {
      result.success = await iface_.getCompactContactsModifiedSince(args.timestamp);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCompactContactsModifiedSince");
      oprot.writeMessageBegin(new TMessage("getCompactContactsModifiedSince", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCompactContactsModifiedSince", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCompactGroup(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCompactGroup_args args = new getCompactGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCompactGroup_result result = new getCompactGroup_result();
    try {
      result.success = await iface_.getCompactGroup(args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCompactGroup");
      oprot.writeMessageBegin(new TMessage("getCompactGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCompactGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCompactRoom(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCompactRoom_args args = new getCompactRoom_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCompactRoom_result result = new getCompactRoom_result();
    try {
      result.success = await iface_.getCompactRoom(args.roomId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCompactRoom");
      oprot.writeMessageBegin(new TMessage("getCompactRoom", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCompactRoom", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getContact(int seqid, TProtocol iprot, TProtocol oprot) async {
    getContact_args args = new getContact_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getContact_result result = new getContact_result();
    try {
      result.success = await iface_.getContact(args.id);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getContact");
      oprot.writeMessageBegin(new TMessage("getContact", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getContact", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getContacts_args args = new getContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getContacts_result result = new getContacts_result();
    try {
      result.success = await iface_.getContacts(args.ids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getContacts");
      oprot.writeMessageBegin(new TMessage("getContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getContactWithFriendRequestStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    getContactWithFriendRequestStatus_args args = new getContactWithFriendRequestStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getContactWithFriendRequestStatus_result result = new getContactWithFriendRequestStatus_result();
    try {
      result.success = await iface_.getContactWithFriendRequestStatus(args.id);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getContactWithFriendRequestStatus");
      oprot.writeMessageBegin(new TMessage("getContactWithFriendRequestStatus", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getContactWithFriendRequestStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCountryWithRequestIp(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCountryWithRequestIp_args args = new getCountryWithRequestIp_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCountryWithRequestIp_result result = new getCountryWithRequestIp_result();
    try {
      result.success = await iface_.getCountryWithRequestIp();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCountryWithRequestIp");
      oprot.writeMessageBegin(new TMessage("getCountryWithRequestIp", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCountryWithRequestIp", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getFavoriteMids(int seqid, TProtocol iprot, TProtocol oprot) async {
    getFavoriteMids_args args = new getFavoriteMids_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getFavoriteMids_result result = new getFavoriteMids_result();
    try {
      result.success = await iface_.getFavoriteMids();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getFavoriteMids");
      oprot.writeMessageBegin(new TMessage("getFavoriteMids", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getFavoriteMids", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroup(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroup_args args = new getGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroup_result result = new getGroup_result();
    try {
      result.success = await iface_.getGroup(args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroup");
      oprot.writeMessageBegin(new TMessage("getGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupIdsInvited(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupIdsInvited_args args = new getGroupIdsInvited_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupIdsInvited_result result = new getGroupIdsInvited_result();
    try {
      result.success = await iface_.getGroupIdsInvited();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupIdsInvited");
      oprot.writeMessageBegin(new TMessage("getGroupIdsInvited", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupIdsInvited", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupIdsJoined(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupIdsJoined_args args = new getGroupIdsJoined_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupIdsJoined_result result = new getGroupIdsJoined_result();
    try {
      result.success = await iface_.getGroupIdsJoined();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupIdsJoined");
      oprot.writeMessageBegin(new TMessage("getGroupIdsJoined", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupIdsJoined", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroups(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroups_args args = new getGroups_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroups_result result = new getGroups_result();
    try {
      result.success = await iface_.getGroups(args.groupIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroups");
      oprot.writeMessageBegin(new TMessage("getGroups", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroups", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getHiddenContactMids(int seqid, TProtocol iprot, TProtocol oprot) async {
    getHiddenContactMids_args args = new getHiddenContactMids_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getHiddenContactMids_result result = new getHiddenContactMids_result();
    try {
      result.success = await iface_.getHiddenContactMids();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getHiddenContactMids");
      oprot.writeMessageBegin(new TMessage("getHiddenContactMids", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getHiddenContactMids", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getIdentityIdentifier(int seqid, TProtocol iprot, TProtocol oprot) async {
    getIdentityIdentifier_args args = new getIdentityIdentifier_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getIdentityIdentifier_result result = new getIdentityIdentifier_result();
    try {
      result.success = await iface_.getIdentityIdentifier();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getIdentityIdentifier");
      oprot.writeMessageBegin(new TMessage("getIdentityIdentifier", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getIdentityIdentifier", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getLastAnnouncementIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    getLastAnnouncementIndex_args args = new getLastAnnouncementIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getLastAnnouncementIndex_result result = new getLastAnnouncementIndex_result();
    try {
      result.success = await iface_.getLastAnnouncementIndex();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getLastAnnouncementIndex");
      oprot.writeMessageBegin(new TMessage("getLastAnnouncementIndex", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getLastAnnouncementIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getLastOpRevision(int seqid, TProtocol iprot, TProtocol oprot) async {
    getLastOpRevision_args args = new getLastOpRevision_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getLastOpRevision_result result = new getLastOpRevision_result();
    try {
      result.success = await iface_.getLastOpRevision();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getLastOpRevision");
      oprot.writeMessageBegin(new TMessage("getLastOpRevision", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getLastOpRevision", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getSuggestRevisions(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSuggestRevisions_args args = new getSuggestRevisions_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSuggestRevisions_result result = new getSuggestRevisions_result();
    try {
      result.success = await iface_.getSuggestRevisions();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getSuggestRevisions");
      oprot.writeMessageBegin(new TMessage("getSuggestRevisions", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getSuggestRevisions", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPreviousMessagesV2WithReadCount(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPreviousMessagesV2WithReadCount_args args = new getPreviousMessagesV2WithReadCount_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPreviousMessagesV2WithReadCount_result result = new getPreviousMessagesV2WithReadCount_result();
    try {
      result.success = await iface_.getPreviousMessagesV2WithReadCount(args.messageBoxId, args.endMessageId, args.messagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPreviousMessagesV2WithReadCount");
      oprot.writeMessageBegin(new TMessage("getPreviousMessagesV2WithReadCount", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPreviousMessagesV2WithReadCount", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBox(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBox_args args = new getMessageBox_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBox_result result = new getMessageBox_result();
    try {
      result.success = await iface_.getMessageBox(args.channelId, args.messageBoxId, args.lastMessagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBox");
      oprot.writeMessageBegin(new TMessage("getMessageBox", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBox", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxCompactWrapUp(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxCompactWrapUp_args args = new getMessageBoxCompactWrapUp_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxCompactWrapUp_result result = new getMessageBoxCompactWrapUp_result();
    try {
      result.success = await iface_.getMessageBoxCompactWrapUp(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxCompactWrapUp");
      oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUp", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUp", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxCompactWrapUpList(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxCompactWrapUpList_args args = new getMessageBoxCompactWrapUpList_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxCompactWrapUpList_result result = new getMessageBoxCompactWrapUpList_result();
    try {
      result.success = await iface_.getMessageBoxCompactWrapUpList(args.start, args.messageBoxCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxCompactWrapUpList");
      oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUpList", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUpList", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxList(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxList_args args = new getMessageBoxList_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxList_result result = new getMessageBoxList_result();
    try {
      result.success = await iface_.getMessageBoxList(args.channelId, args.lastMessagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxList");
      oprot.writeMessageBegin(new TMessage("getMessageBoxList", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxList", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxListByStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxListByStatus_args args = new getMessageBoxListByStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxListByStatus_result result = new getMessageBoxListByStatus_result();
    try {
      result.success = await iface_.getMessageBoxListByStatus(args.channelId, args.lastMessagesCount, args.status);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxListByStatus");
      oprot.writeMessageBegin(new TMessage("getMessageBoxListByStatus", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxListByStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxWrapUp(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxWrapUp_args args = new getMessageBoxWrapUp_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxWrapUp_result result = new getMessageBoxWrapUp_result();
    try {
      result.success = await iface_.getMessageBoxWrapUp(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxWrapUp");
      oprot.writeMessageBegin(new TMessage("getMessageBoxWrapUp", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxWrapUp", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxWrapUpList(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxWrapUpList_args args = new getMessageBoxWrapUpList_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxWrapUpList_result result = new getMessageBoxWrapUpList_result();
    try {
      result.success = await iface_.getMessageBoxWrapUpList(args.start, args.messageBoxCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxWrapUpList");
      oprot.writeMessageBegin(new TMessage("getMessageBoxWrapUpList", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxWrapUpList", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessagesBySequenceNumber(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessagesBySequenceNumber_args args = new getMessagesBySequenceNumber_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessagesBySequenceNumber_result result = new getMessagesBySequenceNumber_result();
    try {
      result.success = await iface_.getMessagesBySequenceNumber(args.channelId, args.messageBoxId, args.startSeq, args.endSeq);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessagesBySequenceNumber");
      oprot.writeMessageBegin(new TMessage("getMessagesBySequenceNumber", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessagesBySequenceNumber", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getNextMessages(int seqid, TProtocol iprot, TProtocol oprot) async {
    getNextMessages_args args = new getNextMessages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getNextMessages_result result = new getNextMessages_result();
    try {
      result.success = await iface_.getNextMessages(args.messageBoxId, args.startSeq, args.messagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getNextMessages");
      oprot.writeMessageBegin(new TMessage("getNextMessages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getNextMessages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getNotificationPolicy(int seqid, TProtocol iprot, TProtocol oprot) async {
    getNotificationPolicy_args args = new getNotificationPolicy_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getNotificationPolicy_result result = new getNotificationPolicy_result();
    try {
      result.success = await iface_.getNotificationPolicy(args.carrier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getNotificationPolicy");
      oprot.writeMessageBegin(new TMessage("getNotificationPolicy", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getNotificationPolicy", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPreviousMessages(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPreviousMessages_args args = new getPreviousMessages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPreviousMessages_result result = new getPreviousMessages_result();
    try {
      result.success = await iface_.getPreviousMessages(args.messageBoxId, args.endSeq, args.messagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPreviousMessages");
      oprot.writeMessageBegin(new TMessage("getPreviousMessages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPreviousMessages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProfile(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProfile_args args = new getProfile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProfile_result result = new getProfile_result();
    try {
      result.success = await iface_.getProfile();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProfile");
      oprot.writeMessageBegin(new TMessage("getProfile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProfile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProximityMatchCandidateList(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProximityMatchCandidateList_args args = new getProximityMatchCandidateList_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProximityMatchCandidateList_result result = new getProximityMatchCandidateList_result();
    try {
      result.success = await iface_.getProximityMatchCandidateList(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProximityMatchCandidateList");
      oprot.writeMessageBegin(new TMessage("getProximityMatchCandidateList", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProximityMatchCandidateList", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProximityMatchCandidates(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProximityMatchCandidates_args args = new getProximityMatchCandidates_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProximityMatchCandidates_result result = new getProximityMatchCandidates_result();
    try {
      result.success = await iface_.getProximityMatchCandidates(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProximityMatchCandidates");
      oprot.writeMessageBegin(new TMessage("getProximityMatchCandidates", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProximityMatchCandidates", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRecentMessages(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRecentMessages_args args = new getRecentMessages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRecentMessages_result result = new getRecentMessages_result();
    try {
      result.success = await iface_.getRecentMessages(args.messageBoxId, args.messagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRecentMessages");
      oprot.writeMessageBegin(new TMessage("getRecentMessages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRecentMessages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRecommendationIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRecommendationIds_args args = new getRecommendationIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRecommendationIds_result result = new getRecommendationIds_result();
    try {
      result.success = await iface_.getRecommendationIds();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRecommendationIds");
      oprot.writeMessageBegin(new TMessage("getRecommendationIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRecommendationIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRoom(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRoom_args args = new getRoom_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRoom_result result = new getRoom_result();
    try {
      result.success = await iface_.getRoom(args.roomId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRoom");
      oprot.writeMessageBegin(new TMessage("getRoom", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRoom", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRSAKeyInfo(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRSAKeyInfo_args args = new getRSAKeyInfo_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRSAKeyInfo_result result = new getRSAKeyInfo_result();
    try {
      result.success = await iface_.getRSAKeyInfo(args.provider);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRSAKeyInfo");
      oprot.writeMessageBegin(new TMessage("getRSAKeyInfo", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRSAKeyInfo", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getServerTime(int seqid, TProtocol iprot, TProtocol oprot) async {
    getServerTime_args args = new getServerTime_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getServerTime_result result = new getServerTime_result();
    try {
      result.success = await iface_.getServerTime();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getServerTime");
      oprot.writeMessageBegin(new TMessage("getServerTime", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getServerTime", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getSessions(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSessions_args args = new getSessions_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSessions_result result = new getSessions_result();
    try {
      result.success = await iface_.getSessions();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getSessions");
      oprot.writeMessageBegin(new TMessage("getSessions", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getSessions", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getSettings(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSettings_args args = new getSettings_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSettings_result result = new getSettings_result();
    try {
      result.success = await iface_.getSettings();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getSettings");
      oprot.writeMessageBegin(new TMessage("getSettings", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getSettings", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupsV2(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupsV2_args args = new getGroupsV2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupsV2_result result = new getGroupsV2_result();
    try {
      result.success = await iface_.getGroupsV2(args.groupIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupsV2");
      oprot.writeMessageBegin(new TMessage("getGroupsV2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupsV2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getSettingsAttributes(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSettingsAttributes_args args = new getSettingsAttributes_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSettingsAttributes_result result = new getSettingsAttributes_result();
    try {
      result.success = await iface_.getSettingsAttributes(args.attrBitset);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getSettingsAttributes");
      oprot.writeMessageBegin(new TMessage("getSettingsAttributes", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getSettingsAttributes", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getSystemConfiguration(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSystemConfiguration_args args = new getSystemConfiguration_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSystemConfiguration_result result = new getSystemConfiguration_result();
    try {
      result.success = await iface_.getSystemConfiguration();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getSystemConfiguration");
      oprot.writeMessageBegin(new TMessage("getSystemConfiguration", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getSystemConfiguration", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserTicket_args args = new getUserTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserTicket_result result = new getUserTicket_result();
    try {
      result.success = await iface_.getUserTicket();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserTicket");
      oprot.writeMessageBegin(new TMessage("getUserTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getWapInvitation(int seqid, TProtocol iprot, TProtocol oprot) async {
    getWapInvitation_args args = new getWapInvitation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getWapInvitation_result result = new getWapInvitation_result();
    try {
      result.success = await iface_.getWapInvitation(args.invitationHash);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getWapInvitation");
      oprot.writeMessageBegin(new TMessage("getWapInvitation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getWapInvitation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  invalidateUserTicket(int seqid, TProtocol iprot, TProtocol oprot) {
    invalidateUserTicket_args args = new invalidateUserTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    invalidateUserTicket_result result = new invalidateUserTicket_result();
    try {
      iface_.invalidateUserTicket();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing invalidateUserTicket");
      oprot.writeMessageBegin(new TMessage("invalidateUserTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("invalidateUserTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  inviteFriendsBySms(int seqid, TProtocol iprot, TProtocol oprot) {
    inviteFriendsBySms_args args = new inviteFriendsBySms_args();
    args.read(iprot);
    iprot.readMessageEnd();
    inviteFriendsBySms_result result = new inviteFriendsBySms_result();
    try {
      iface_.inviteFriendsBySms(args.phoneNumberList);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing inviteFriendsBySms");
      oprot.writeMessageBegin(new TMessage("inviteFriendsBySms", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("inviteFriendsBySms", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  inviteIntoGroup(int seqid, TProtocol iprot, TProtocol oprot) {
    inviteIntoGroup_args args = new inviteIntoGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    inviteIntoGroup_result result = new inviteIntoGroup_result();
    try {
      iface_.inviteIntoGroup(args.reqSeq, args.groupId, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing inviteIntoGroup");
      oprot.writeMessageBegin(new TMessage("inviteIntoGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("inviteIntoGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  inviteIntoRoom(int seqid, TProtocol iprot, TProtocol oprot) {
    inviteIntoRoom_args args = new inviteIntoRoom_args();
    args.read(iprot);
    iprot.readMessageEnd();
    inviteIntoRoom_result result = new inviteIntoRoom_result();
    try {
      iface_.inviteIntoRoom(args.reqSeq, args.roomId, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing inviteIntoRoom");
      oprot.writeMessageBegin(new TMessage("inviteIntoRoom", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("inviteIntoRoom", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  inviteViaEmail(int seqid, TProtocol iprot, TProtocol oprot) {
    inviteViaEmail_args args = new inviteViaEmail_args();
    args.read(iprot);
    iprot.readMessageEnd();
    inviteViaEmail_result result = new inviteViaEmail_result();
    try {
      iface_.inviteViaEmail(args.reqSeq, args.email, args.name);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing inviteViaEmail");
      oprot.writeMessageBegin(new TMessage("inviteViaEmail", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("inviteViaEmail", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  isIdentityIdentifierAvailable(int seqid, TProtocol iprot, TProtocol oprot) async {
    isIdentityIdentifierAvailable_args args = new isIdentityIdentifierAvailable_args();
    args.read(iprot);
    iprot.readMessageEnd();
    isIdentityIdentifierAvailable_result result = new isIdentityIdentifierAvailable_result();
    try {
      result.success = await iface_.isIdentityIdentifierAvailable(args.provider, args.identifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing isIdentityIdentifierAvailable");
      oprot.writeMessageBegin(new TMessage("isIdentityIdentifierAvailable", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("isIdentityIdentifierAvailable", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  isUseridAvailable(int seqid, TProtocol iprot, TProtocol oprot) async {
    isUseridAvailable_args args = new isUseridAvailable_args();
    args.read(iprot);
    iprot.readMessageEnd();
    isUseridAvailable_result result = new isUseridAvailable_result();
    try {
      result.success = await iface_.isUseridAvailable(args.userid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing isUseridAvailable");
      oprot.writeMessageBegin(new TMessage("isUseridAvailable", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("isUseridAvailable", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  kickoutFromGroup(int seqid, TProtocol iprot, TProtocol oprot) {
    kickoutFromGroup_args args = new kickoutFromGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    kickoutFromGroup_result result = new kickoutFromGroup_result();
    try {
      iface_.kickoutFromGroup(args.reqSeq, args.groupId, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing kickoutFromGroup");
      oprot.writeMessageBegin(new TMessage("kickoutFromGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("kickoutFromGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reissueGroupTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    reissueGroupTicket_args args = new reissueGroupTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reissueGroupTicket_result result = new reissueGroupTicket_result();
    try {
      result.success = await iface_.reissueGroupTicket(args.groupMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reissueGroupTicket");
      oprot.writeMessageBegin(new TMessage("reissueGroupTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reissueGroupTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findGroupByTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    findGroupByTicket_args args = new findGroupByTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findGroupByTicket_result result = new findGroupByTicket_result();
    try {
      result.success = await iface_.findGroupByTicket(args.ticketId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findGroupByTicket");
      oprot.writeMessageBegin(new TMessage("findGroupByTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findGroupByTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  leaveGroup(int seqid, TProtocol iprot, TProtocol oprot) {
    leaveGroup_args args = new leaveGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    leaveGroup_result result = new leaveGroup_result();
    try {
      iface_.leaveGroup(args.reqSeq, args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing leaveGroup");
      oprot.writeMessageBegin(new TMessage("leaveGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("leaveGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  leaveRoom(int seqid, TProtocol iprot, TProtocol oprot) {
    leaveRoom_args args = new leaveRoom_args();
    args.read(iprot);
    iprot.readMessageEnd();
    leaveRoom_result result = new leaveRoom_result();
    try {
      iface_.leaveRoom(args.reqSeq, args.roomId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing leaveRoom");
      oprot.writeMessageBegin(new TMessage("leaveRoom", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("leaveRoom", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  loginWithIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    loginWithIdentityCredential_args args = new loginWithIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    loginWithIdentityCredential_result result = new loginWithIdentityCredential_result();
    try {
      result.success = await iface_.loginWithIdentityCredential(args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing loginWithIdentityCredential");
      oprot.writeMessageBegin(new TMessage("loginWithIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("loginWithIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  loginWithIdentityCredentialForCertificate(int seqid, TProtocol iprot, TProtocol oprot) async {
    loginWithIdentityCredentialForCertificate_args args = new loginWithIdentityCredentialForCertificate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    loginWithIdentityCredentialForCertificate_result result = new loginWithIdentityCredentialForCertificate_result();
    try {
      result.success = await iface_.loginWithIdentityCredentialForCertificate(args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing loginWithIdentityCredentialForCertificate");
      oprot.writeMessageBegin(new TMessage("loginWithIdentityCredentialForCertificate", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("loginWithIdentityCredentialForCertificate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  loginWithVerifier(int seqid, TProtocol iprot, TProtocol oprot) async {
    loginWithVerifier_args args = new loginWithVerifier_args();
    args.read(iprot);
    iprot.readMessageEnd();
    loginWithVerifier_result result = new loginWithVerifier_result();
    try {
      result.success = await iface_.loginWithVerifier(args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing loginWithVerifier");
      oprot.writeMessageBegin(new TMessage("loginWithVerifier", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("loginWithVerifier", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  loginWithVerifierForCerificate(int seqid, TProtocol iprot, TProtocol oprot) async {
    loginWithVerifierForCerificate_args args = new loginWithVerifierForCerificate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    loginWithVerifierForCerificate_result result = new loginWithVerifierForCerificate_result();
    try {
      result.success = await iface_.loginWithVerifierForCerificate(args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing loginWithVerifierForCerificate");
      oprot.writeMessageBegin(new TMessage("loginWithVerifierForCerificate", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("loginWithVerifierForCerificate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  loginWithVerifierForCertificate(int seqid, TProtocol iprot, TProtocol oprot) async {
    loginWithVerifierForCertificate_args args = new loginWithVerifierForCertificate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    loginWithVerifierForCertificate_result result = new loginWithVerifierForCertificate_result();
    try {
      result.success = await iface_.loginWithVerifierForCertificate(args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing loginWithVerifierForCertificate");
      oprot.writeMessageBegin(new TMessage("loginWithVerifierForCertificate", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("loginWithVerifierForCertificate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  logout(int seqid, TProtocol iprot, TProtocol oprot) {
    logout_args args = new logout_args();
    args.read(iprot);
    iprot.readMessageEnd();
    logout_result result = new logout_result();
    try {
      iface_.logout();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing logout");
      oprot.writeMessageBegin(new TMessage("logout", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("logout", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  logoutSession(int seqid, TProtocol iprot, TProtocol oprot) {
    logoutSession_args args = new logoutSession_args();
    args.read(iprot);
    iprot.readMessageEnd();
    logoutSession_result result = new logoutSession_result();
    try {
      iface_.logoutSession(args.tokenKey);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing logoutSession");
      oprot.writeMessageBegin(new TMessage("logoutSession", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("logoutSession", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  noop(int seqid, TProtocol iprot, TProtocol oprot) {
    noop_args args = new noop_args();
    args.read(iprot);
    iprot.readMessageEnd();
    noop_result result = new noop_result();
    try {
      iface_.noop();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing noop");
      oprot.writeMessageBegin(new TMessage("noop", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("noop", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifiedRedirect(int seqid, TProtocol iprot, TProtocol oprot) {
    notifiedRedirect_args args = new notifiedRedirect_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifiedRedirect_result result = new notifiedRedirect_result();
    try {
      iface_.notifiedRedirect(args.paramMap);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifiedRedirect");
      oprot.writeMessageBegin(new TMessage("notifiedRedirect", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifiedRedirect", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyBuddyOnAir(int seqid, TProtocol iprot, TProtocol oprot) async {
    notifyBuddyOnAir_args args = new notifyBuddyOnAir_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyBuddyOnAir_result result = new notifyBuddyOnAir_result();
    try {
      result.success = await iface_.notifyBuddyOnAir(args.seq, args.receiverMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyBuddyOnAir");
      oprot.writeMessageBegin(new TMessage("notifyBuddyOnAir", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyBuddyOnAir", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyIndividualEvent(int seqid, TProtocol iprot, TProtocol oprot) {
    notifyIndividualEvent_args args = new notifyIndividualEvent_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyIndividualEvent_result result = new notifyIndividualEvent_result();
    try {
      iface_.notifyIndividualEvent(args.notificationStatus, args.receiverMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyIndividualEvent");
      oprot.writeMessageBegin(new TMessage("notifyIndividualEvent", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyIndividualEvent", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyInstalled(int seqid, TProtocol iprot, TProtocol oprot) {
    notifyInstalled_args args = new notifyInstalled_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyInstalled_result result = new notifyInstalled_result();
    try {
      iface_.notifyInstalled(args.udidHash, args.applicationTypeWithExtensions);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyInstalled");
      oprot.writeMessageBegin(new TMessage("notifyInstalled", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyInstalled", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyRegistrationComplete(int seqid, TProtocol iprot, TProtocol oprot) {
    notifyRegistrationComplete_args args = new notifyRegistrationComplete_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyRegistrationComplete_result result = new notifyRegistrationComplete_result();
    try {
      iface_.notifyRegistrationComplete(args.udidHash, args.applicationTypeWithExtensions);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyRegistrationComplete");
      oprot.writeMessageBegin(new TMessage("notifyRegistrationComplete", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyRegistrationComplete", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifySleep(int seqid, TProtocol iprot, TProtocol oprot) {
    notifySleep_args args = new notifySleep_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifySleep_result result = new notifySleep_result();
    try {
      iface_.notifySleep(args.lastRev, args.badge);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifySleep");
      oprot.writeMessageBegin(new TMessage("notifySleep", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifySleep", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyUpdated(int seqid, TProtocol iprot, TProtocol oprot) {
    notifyUpdated_args args = new notifyUpdated_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyUpdated_result result = new notifyUpdated_result();
    try {
      iface_.notifyUpdated(args.lastRev, args.deviceInfo);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyUpdated");
      oprot.writeMessageBegin(new TMessage("notifyUpdated", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyUpdated", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  openProximityMatch(int seqid, TProtocol iprot, TProtocol oprot) async {
    openProximityMatch_args args = new openProximityMatch_args();
    args.read(iprot);
    iprot.readMessageEnd();
    openProximityMatch_result result = new openProximityMatch_result();
    try {
      result.success = await iface_.openProximityMatch(args.location);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing openProximityMatch");
      oprot.writeMessageBegin(new TMessage("openProximityMatch", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("openProximityMatch", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerBuddyUser(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerBuddyUser_args args = new registerBuddyUser_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerBuddyUser_result result = new registerBuddyUser_result();
    try {
      result.success = await iface_.registerBuddyUser(args.buddyId, args.registrarPassword);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerBuddyUser");
      oprot.writeMessageBegin(new TMessage("registerBuddyUser", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerBuddyUser", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerBuddyUserid(int seqid, TProtocol iprot, TProtocol oprot) {
    registerBuddyUserid_args args = new registerBuddyUserid_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerBuddyUserid_result result = new registerBuddyUserid_result();
    try {
      iface_.registerBuddyUserid(args.seq, args.userid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerBuddyUserid");
      oprot.writeMessageBegin(new TMessage("registerBuddyUserid", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerBuddyUserid", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerDevice(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerDevice_args args = new registerDevice_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerDevice_result result = new registerDevice_result();
    try {
      result.success = await iface_.registerDevice(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerDevice");
      oprot.writeMessageBegin(new TMessage("registerDevice", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerDevice", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerDeviceWithIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerDeviceWithIdentityCredential_args args = new registerDeviceWithIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerDeviceWithIdentityCredential_result result = new registerDeviceWithIdentityCredential_result();
    try {
      result.success = await iface_.registerDeviceWithIdentityCredential(args.sessionId, args.provider, args.identifier, args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerDeviceWithIdentityCredential");
      oprot.writeMessageBegin(new TMessage("registerDeviceWithIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerDeviceWithIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerDeviceWithoutPhoneNumber(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerDeviceWithoutPhoneNumber_args args = new registerDeviceWithoutPhoneNumber_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerDeviceWithoutPhoneNumber_result result = new registerDeviceWithoutPhoneNumber_result();
    try {
      result.success = await iface_.registerDeviceWithoutPhoneNumber(args.region, args.udidHash, args.deviceInfo);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerDeviceWithoutPhoneNumber");
      oprot.writeMessageBegin(new TMessage("registerDeviceWithoutPhoneNumber", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerDeviceWithoutPhoneNumber", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerDeviceWithoutPhoneNumberWithIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerDeviceWithoutPhoneNumberWithIdentityCredential_args args = new registerDeviceWithoutPhoneNumberWithIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerDeviceWithoutPhoneNumberWithIdentityCredential_result result = new registerDeviceWithoutPhoneNumberWithIdentityCredential_result();
    try {
      result.success = await iface_.registerDeviceWithoutPhoneNumberWithIdentityCredential(args.region, args.udidHash, args.deviceInfo, args.provider, args.identifier, args.verifier, args.mid, args.migrationPincodeSessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerDeviceWithoutPhoneNumberWithIdentityCredential");
      oprot.writeMessageBegin(new TMessage("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerDeviceWithoutPhoneNumberWithIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerUserid(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerUserid_args args = new registerUserid_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerUserid_result result = new registerUserid_result();
    try {
      result.success = await iface_.registerUserid(args.reqSeq, args.userid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerUserid");
      oprot.writeMessageBegin(new TMessage("registerUserid", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerUserid", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerWapDevice(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerWapDevice_args args = new registerWapDevice_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerWapDevice_result result = new registerWapDevice_result();
    try {
      result.success = await iface_.registerWapDevice(args.invitationHash, args.guidHash, args.email, args.deviceInfo);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerWapDevice");
      oprot.writeMessageBegin(new TMessage("registerWapDevice", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerWapDevice", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerWithExistingSnsIdAndIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerWithExistingSnsIdAndIdentityCredential_args args = new registerWithExistingSnsIdAndIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerWithExistingSnsIdAndIdentityCredential_result result = new registerWithExistingSnsIdAndIdentityCredential_result();
    try {
      result.success = await iface_.registerWithExistingSnsIdAndIdentityCredential(args.identityCredential, args.region, args.udidHash, args.deviceInfo);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerWithExistingSnsIdAndIdentityCredential");
      oprot.writeMessageBegin(new TMessage("registerWithExistingSnsIdAndIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerWithExistingSnsIdAndIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerWithSnsId(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerWithSnsId_args args = new registerWithSnsId_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerWithSnsId_result result = new registerWithSnsId_result();
    try {
      result.success = await iface_.registerWithSnsId(args.snsIdType, args.snsAccessToken, args.region, args.udidHash, args.deviceInfo, args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerWithSnsId");
      oprot.writeMessageBegin(new TMessage("registerWithSnsId", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerWithSnsId", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerWithSnsIdAndIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerWithSnsIdAndIdentityCredential_args args = new registerWithSnsIdAndIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerWithSnsIdAndIdentityCredential_result result = new registerWithSnsIdAndIdentityCredential_result();
    try {
      result.success = await iface_.registerWithSnsIdAndIdentityCredential(args.snsIdType, args.snsAccessToken, args.identityCredential, args.region, args.udidHash, args.deviceInfo);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerWithSnsIdAndIdentityCredential");
      oprot.writeMessageBegin(new TMessage("registerWithSnsIdAndIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerWithSnsIdAndIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reissueDeviceCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    reissueDeviceCredential_args args = new reissueDeviceCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reissueDeviceCredential_result result = new reissueDeviceCredential_result();
    try {
      result.success = await iface_.reissueDeviceCredential();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reissueDeviceCredential");
      oprot.writeMessageBegin(new TMessage("reissueDeviceCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reissueDeviceCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reissueUserTicket(int seqid, TProtocol iprot, TProtocol oprot) async {
    reissueUserTicket_args args = new reissueUserTicket_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reissueUserTicket_result result = new reissueUserTicket_result();
    try {
      result.success = await iface_.reissueUserTicket(args.expirationTime, args.maxUseCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reissueUserTicket");
      oprot.writeMessageBegin(new TMessage("reissueUserTicket", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reissueUserTicket", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageReadRange(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageReadRange_args args = new getMessageReadRange_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageReadRange_result result = new getMessageReadRange_result();
    try {
      result.success = await iface_.getMessageReadRange(args.chatIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageReadRange");
      oprot.writeMessageBegin(new TMessage("getMessageReadRange", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageReadRange", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  rejectGroupInvitation(int seqid, TProtocol iprot, TProtocol oprot) {
    rejectGroupInvitation_args args = new rejectGroupInvitation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    rejectGroupInvitation_result result = new rejectGroupInvitation_result();
    try {
      iface_.rejectGroupInvitation(args.reqSeq, args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing rejectGroupInvitation");
      oprot.writeMessageBegin(new TMessage("rejectGroupInvitation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("rejectGroupInvitation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  releaseSession(int seqid, TProtocol iprot, TProtocol oprot) {
    releaseSession_args args = new releaseSession_args();
    args.read(iprot);
    iprot.readMessageEnd();
    releaseSession_result result = new releaseSession_result();
    try {
      iface_.releaseSession();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing releaseSession");
      oprot.writeMessageBegin(new TMessage("releaseSession", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("releaseSession", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeAllMessages(int seqid, TProtocol iprot, TProtocol oprot) {
    removeAllMessages_args args = new removeAllMessages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeAllMessages_result result = new removeAllMessages_result();
    try {
      iface_.removeAllMessages(args.seq, args.lastMessageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeAllMessages");
      oprot.writeMessageBegin(new TMessage("removeAllMessages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeAllMessages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeBuddyLocation(int seqid, TProtocol iprot, TProtocol oprot) {
    removeBuddyLocation_args args = new removeBuddyLocation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeBuddyLocation_result result = new removeBuddyLocation_result();
    try {
      iface_.removeBuddyLocation(args.mid, args.index);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeBuddyLocation");
      oprot.writeMessageBegin(new TMessage("removeBuddyLocation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeBuddyLocation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeMessage(int seqid, TProtocol iprot, TProtocol oprot) async {
    removeMessage_args args = new removeMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeMessage_result result = new removeMessage_result();
    try {
      result.success = await iface_.removeMessage(args.messageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeMessage");
      oprot.writeMessageBegin(new TMessage("removeMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  makeUserAddMyselfAsContact(int seqid, TProtocol iprot, TProtocol oprot) async {
    makeUserAddMyselfAsContact_args args = new makeUserAddMyselfAsContact_args();
    args.read(iprot);
    iprot.readMessageEnd();
    makeUserAddMyselfAsContact_result result = new makeUserAddMyselfAsContact_result();
    try {
      result.success = await iface_.makeUserAddMyselfAsContact(args.contactOwnerMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing makeUserAddMyselfAsContact");
      oprot.writeMessageBegin(new TMessage("makeUserAddMyselfAsContact", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("makeUserAddMyselfAsContact", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeMessageFromMyHome(int seqid, TProtocol iprot, TProtocol oprot) async {
    removeMessageFromMyHome_args args = new removeMessageFromMyHome_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeMessageFromMyHome_result result = new removeMessageFromMyHome_result();
    try {
      result.success = await iface_.removeMessageFromMyHome(args.messageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeMessageFromMyHome");
      oprot.writeMessageBegin(new TMessage("removeMessageFromMyHome", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeMessageFromMyHome", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeSnsId(int seqid, TProtocol iprot, TProtocol oprot) async {
    removeSnsId_args args = new removeSnsId_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeSnsId_result result = new removeSnsId_result();
    try {
      result.success = await iface_.removeSnsId(args.snsIdType);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeSnsId");
      oprot.writeMessageBegin(new TMessage("removeSnsId", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeSnsId", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  report(int seqid, TProtocol iprot, TProtocol oprot) {
    report_args args = new report_args();
    args.read(iprot);
    iprot.readMessageEnd();
    report_result result = new report_result();
    try {
      iface_.report(args.syncOpRevision, args.category, args.report);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing report");
      oprot.writeMessageBegin(new TMessage("report", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("report", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    reportContacts_args args = new reportContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportContacts_result result = new reportContacts_result();
    try {
      result.success = await iface_.reportContacts(args.syncOpRevision, args.category, args.contactReports, args.actionType);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportContacts");
      oprot.writeMessageBegin(new TMessage("reportContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportGroups(int seqid, TProtocol iprot, TProtocol oprot) {
    reportGroups_args args = new reportGroups_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportGroups_result result = new reportGroups_result();
    try {
      iface_.reportGroups(args.syncOpRevision, args.groups);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportGroups");
      oprot.writeMessageBegin(new TMessage("reportGroups", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportGroups", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportProfile(int seqid, TProtocol iprot, TProtocol oprot) {
    reportProfile_args args = new reportProfile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportProfile_result result = new reportProfile_result();
    try {
      iface_.reportProfile(args.syncOpRevision, args.profile);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportProfile");
      oprot.writeMessageBegin(new TMessage("reportProfile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportProfile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportRooms(int seqid, TProtocol iprot, TProtocol oprot) {
    reportRooms_args args = new reportRooms_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportRooms_result result = new reportRooms_result();
    try {
      iface_.reportRooms(args.syncOpRevision, args.rooms);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportRooms");
      oprot.writeMessageBegin(new TMessage("reportRooms", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportRooms", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findAndAddContactByMetaTag(int seqid, TProtocol iprot, TProtocol oprot) async {
    findAndAddContactByMetaTag_args args = new findAndAddContactByMetaTag_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findAndAddContactByMetaTag_result result = new findAndAddContactByMetaTag_result();
    try {
      result.success = await iface_.findAndAddContactByMetaTag(args.reqSeq, args.userid, args.reference);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findAndAddContactByMetaTag");
      oprot.writeMessageBegin(new TMessage("findAndAddContactByMetaTag", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findAndAddContactByMetaTag", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportSettings(int seqid, TProtocol iprot, TProtocol oprot) {
    reportSettings_args args = new reportSettings_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportSettings_result result = new reportSettings_result();
    try {
      iface_.reportSettings(args.syncOpRevision, args.settings);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportSettings");
      oprot.writeMessageBegin(new TMessage("reportSettings", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportSettings", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportSpam(int seqid, TProtocol iprot, TProtocol oprot) {
    reportSpam_args args = new reportSpam_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportSpam_result result = new reportSpam_result();
    try {
      iface_.reportSpam(args.chatMid, args.memberMids, args.spammerReasons, args.senderMids, args.spamMessageIds, args.spamMessages);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportSpam");
      oprot.writeMessageBegin(new TMessage("reportSpam", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportSpam", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reportSpammer(int seqid, TProtocol iprot, TProtocol oprot) {
    reportSpammer_args args = new reportSpammer_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportSpammer_result result = new reportSpammer_result();
    try {
      iface_.reportSpammer(args.spammerMid, args.spammerReasons, args.spamMessageIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reportSpammer");
      oprot.writeMessageBegin(new TMessage("reportSpammer", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reportSpammer", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  requestAccountPasswordReset(int seqid, TProtocol iprot, TProtocol oprot) {
    requestAccountPasswordReset_args args = new requestAccountPasswordReset_args();
    args.read(iprot);
    iprot.readMessageEnd();
    requestAccountPasswordReset_result result = new requestAccountPasswordReset_result();
    try {
      iface_.requestAccountPasswordReset(args.provider, args.identifier, args.locale);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing requestAccountPasswordReset");
      oprot.writeMessageBegin(new TMessage("requestAccountPasswordReset", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("requestAccountPasswordReset", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  requestEmailConfirmation(int seqid, TProtocol iprot, TProtocol oprot) async {
    requestEmailConfirmation_args args = new requestEmailConfirmation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    requestEmailConfirmation_result result = new requestEmailConfirmation_result();
    try {
      result.success = await iface_.requestEmailConfirmation(args.emailConfirmation);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing requestEmailConfirmation");
      oprot.writeMessageBegin(new TMessage("requestEmailConfirmation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("requestEmailConfirmation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  requestIdentityUnbind(int seqid, TProtocol iprot, TProtocol oprot) {
    requestIdentityUnbind_args args = new requestIdentityUnbind_args();
    args.read(iprot);
    iprot.readMessageEnd();
    requestIdentityUnbind_result result = new requestIdentityUnbind_result();
    try {
      iface_.requestIdentityUnbind(args.provider, args.identifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing requestIdentityUnbind");
      oprot.writeMessageBegin(new TMessage("requestIdentityUnbind", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("requestIdentityUnbind", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  resendEmailConfirmation(int seqid, TProtocol iprot, TProtocol oprot) async {
    resendEmailConfirmation_args args = new resendEmailConfirmation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    resendEmailConfirmation_result result = new resendEmailConfirmation_result();
    try {
      result.success = await iface_.resendEmailConfirmation(args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing resendEmailConfirmation");
      oprot.writeMessageBegin(new TMessage("resendEmailConfirmation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("resendEmailConfirmation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  resendPinCode(int seqid, TProtocol iprot, TProtocol oprot) {
    resendPinCode_args args = new resendPinCode_args();
    args.read(iprot);
    iprot.readMessageEnd();
    resendPinCode_result result = new resendPinCode_result();
    try {
      iface_.resendPinCode(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing resendPinCode");
      oprot.writeMessageBegin(new TMessage("resendPinCode", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("resendPinCode", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  resendPinCodeBySMS(int seqid, TProtocol iprot, TProtocol oprot) {
    resendPinCodeBySMS_args args = new resendPinCodeBySMS_args();
    args.read(iprot);
    iprot.readMessageEnd();
    resendPinCodeBySMS_result result = new resendPinCodeBySMS_result();
    try {
      iface_.resendPinCodeBySMS(args.sessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing resendPinCodeBySMS");
      oprot.writeMessageBegin(new TMessage("resendPinCodeBySMS", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("resendPinCodeBySMS", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendChatChecked(int seqid, TProtocol iprot, TProtocol oprot) {
    sendChatChecked_args args = new sendChatChecked_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendChatChecked_result result = new sendChatChecked_result();
    try {
      iface_.sendChatChecked(args.seq, args.consumer, args.lastMessageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendChatChecked");
      oprot.writeMessageBegin(new TMessage("sendChatChecked", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendChatChecked", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessageAwaitCommit(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendMessageAwaitCommit_args args = new sendMessageAwaitCommit_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessageAwaitCommit_result result = new sendMessageAwaitCommit_result();
    try {
      result.success = await iface_.sendMessageAwaitCommit(args.seq, args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessageAwaitCommit");
      oprot.writeMessageBegin(new TMessage("sendMessageAwaitCommit", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessageAwaitCommit", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendChatRemoved(int seqid, TProtocol iprot, TProtocol oprot) {
    sendChatRemoved_args args = new sendChatRemoved_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendChatRemoved_result result = new sendChatRemoved_result();
    try {
      iface_.sendChatRemoved(args.seq, args.consumer, args.lastMessageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendChatRemoved");
      oprot.writeMessageBegin(new TMessage("sendChatRemoved", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendChatRemoved", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendContentPreviewUpdated(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendContentPreviewUpdated_args args = new sendContentPreviewUpdated_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendContentPreviewUpdated_result result = new sendContentPreviewUpdated_result();
    try {
      result.success = await iface_.sendContentPreviewUpdated(args.esq, args.messageId, args.receiverMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendContentPreviewUpdated");
      oprot.writeMessageBegin(new TMessage("sendContentPreviewUpdated", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendContentPreviewUpdated", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendContentReceipt(int seqid, TProtocol iprot, TProtocol oprot) {
    sendContentReceipt_args args = new sendContentReceipt_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendContentReceipt_result result = new sendContentReceipt_result();
    try {
      iface_.sendContentReceipt(args.seq, args.consumer, args.messageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendContentReceipt");
      oprot.writeMessageBegin(new TMessage("sendContentReceipt", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendContentReceipt", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendDummyPush(int seqid, TProtocol iprot, TProtocol oprot) {
    sendDummyPush_args args = new sendDummyPush_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendDummyPush_result result = new sendDummyPush_result();
    try {
      iface_.sendDummyPush();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendDummyPush");
      oprot.writeMessageBegin(new TMessage("sendDummyPush", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendDummyPush", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  removeE2EEPublicKey(int seqid, TProtocol iprot, TProtocol oprot) {
    removeE2EEPublicKey_args args = new removeE2EEPublicKey_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeE2EEPublicKey_result result = new removeE2EEPublicKey_result();
    try {
      iface_.removeE2EEPublicKey(args.publicKey);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing removeE2EEPublicKey");
      oprot.writeMessageBegin(new TMessage("removeE2EEPublicKey", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("removeE2EEPublicKey", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  negotiateE2EEPublicKey(int seqid, TProtocol iprot, TProtocol oprot) async {
    negotiateE2EEPublicKey_args args = new negotiateE2EEPublicKey_args();
    args.read(iprot);
    iprot.readMessageEnd();
    negotiateE2EEPublicKey_result result = new negotiateE2EEPublicKey_result();
    try {
      result.success = await iface_.negotiateE2EEPublicKey(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing negotiateE2EEPublicKey");
      oprot.writeMessageBegin(new TMessage("negotiateE2EEPublicKey", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("negotiateE2EEPublicKey", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getE2EEPublicKey(int seqid, TProtocol iprot, TProtocol oprot) async {
    getE2EEPublicKey_args args = new getE2EEPublicKey_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getE2EEPublicKey_result result = new getE2EEPublicKey_result();
    try {
      result.success = await iface_.getE2EEPublicKey(args.mid, args.version, args.keyId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getE2EEPublicKey");
      oprot.writeMessageBegin(new TMessage("getE2EEPublicKey", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getE2EEPublicKey", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  requestE2EEKeyExchange(int seqid, TProtocol iprot, TProtocol oprot) {
    requestE2EEKeyExchange_args args = new requestE2EEKeyExchange_args();
    args.read(iprot);
    iprot.readMessageEnd();
    requestE2EEKeyExchange_result result = new requestE2EEKeyExchange_result();
    try {
      iface_.requestE2EEKeyExchange(args.reqSeq, args.temporalPublicKey, args.publicKey, args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing requestE2EEKeyExchange");
      oprot.writeMessageBegin(new TMessage("requestE2EEKeyExchange", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("requestE2EEKeyExchange", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getLastE2EEPublicKeys(int seqid, TProtocol iprot, TProtocol oprot) async {
    getLastE2EEPublicKeys_args args = new getLastE2EEPublicKeys_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getLastE2EEPublicKeys_result result = new getLastE2EEPublicKeys_result();
    try {
      result.success = await iface_.getLastE2EEPublicKeys(args.chatMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getLastE2EEPublicKeys");
      oprot.writeMessageBegin(new TMessage("getLastE2EEPublicKeys", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getLastE2EEPublicKeys", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerE2EEPublicKey(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerE2EEPublicKey_args args = new registerE2EEPublicKey_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerE2EEPublicKey_result result = new registerE2EEPublicKey_result();
    try {
      result.success = await iface_.registerE2EEPublicKey(args.reqSeq, args.publicKey);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerE2EEPublicKey");
      oprot.writeMessageBegin(new TMessage("registerE2EEPublicKey", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerE2EEPublicKey", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getE2EEPublicKeys(int seqid, TProtocol iprot, TProtocol oprot) async {
    getE2EEPublicKeys_args args = new getE2EEPublicKeys_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getE2EEPublicKeys_result result = new getE2EEPublicKeys_result();
    try {
      result.success = await iface_.getE2EEPublicKeys();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getE2EEPublicKeys");
      oprot.writeMessageBegin(new TMessage("getE2EEPublicKeys", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getE2EEPublicKeys", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getE2EEPublicKeysEx(int seqid, TProtocol iprot, TProtocol oprot) async {
    getE2EEPublicKeysEx_args args = new getE2EEPublicKeysEx_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getE2EEPublicKeysEx_result result = new getE2EEPublicKeysEx_result();
    try {
      result.success = await iface_.getE2EEPublicKeysEx(args.ignoreE2EEStatus);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getE2EEPublicKeysEx");
      oprot.writeMessageBegin(new TMessage("getE2EEPublicKeysEx", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getE2EEPublicKeysEx", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getReadMessageOpsInBulk(int seqid, TProtocol iprot, TProtocol oprot) async {
    getReadMessageOpsInBulk_args args = new getReadMessageOpsInBulk_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getReadMessageOpsInBulk_result result = new getReadMessageOpsInBulk_result();
    try {
      result.success = await iface_.getReadMessageOpsInBulk(args.chatIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getReadMessageOpsInBulk");
      oprot.writeMessageBegin(new TMessage("getReadMessageOpsInBulk", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getReadMessageOpsInBulk", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendEvent(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendEvent_args args = new sendEvent_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendEvent_result result = new sendEvent_result();
    try {
      result.success = await iface_.sendEvent(args.seq, args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendEvent");
      oprot.writeMessageBegin(new TMessage("sendEvent", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendEvent", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessage(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendMessage_args args = new sendMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessage_result result = new sendMessage_result();
    try {
      result.success = await iface_.sendMessage(args.seq, args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessage");
      oprot.writeMessageBegin(new TMessage("sendMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessageIgnored(int seqid, TProtocol iprot, TProtocol oprot) {
    sendMessageIgnored_args args = new sendMessageIgnored_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessageIgnored_result result = new sendMessageIgnored_result();
    try {
      iface_.sendMessageIgnored(args.seq, args.consumer, args.messageIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessageIgnored");
      oprot.writeMessageBegin(new TMessage("sendMessageIgnored", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessageIgnored", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessageReceipt(int seqid, TProtocol iprot, TProtocol oprot) {
    sendMessageReceipt_args args = new sendMessageReceipt_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessageReceipt_result result = new sendMessageReceipt_result();
    try {
      iface_.sendMessageReceipt(args.seq, args.consumer, args.messageIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessageReceipt");
      oprot.writeMessageBegin(new TMessage("sendMessageReceipt", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessageReceipt", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findContactByMetaTag(int seqid, TProtocol iprot, TProtocol oprot) async {
    findContactByMetaTag_args args = new findContactByMetaTag_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findContactByMetaTag_result result = new findContactByMetaTag_result();
    try {
      result.success = await iface_.findContactByMetaTag(args.userid, args.reference);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findContactByMetaTag");
      oprot.writeMessageBegin(new TMessage("findContactByMetaTag", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findContactByMetaTag", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessageToMyHome(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendMessageToMyHome_args args = new sendMessageToMyHome_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessageToMyHome_result result = new sendMessageToMyHome_result();
    try {
      result.success = await iface_.sendMessageToMyHome(args.seq, args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessageToMyHome");
      oprot.writeMessageBegin(new TMessage("sendMessageToMyHome", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessageToMyHome", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  setBuddyLocation(int seqid, TProtocol iprot, TProtocol oprot) {
    setBuddyLocation_args args = new setBuddyLocation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    setBuddyLocation_result result = new setBuddyLocation_result();
    try {
      iface_.setBuddyLocation(args.mid, args.index, args.location);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing setBuddyLocation");
      oprot.writeMessageBegin(new TMessage("setBuddyLocation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("setBuddyLocation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  setIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) {
    setIdentityCredential_args args = new setIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    setIdentityCredential_result result = new setIdentityCredential_result();
    try {
      iface_.setIdentityCredential(args.identifier, args.verifier, args.provider);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing setIdentityCredential");
      oprot.writeMessageBegin(new TMessage("setIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("setIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  setNotificationsEnabled(int seqid, TProtocol iprot, TProtocol oprot) {
    setNotificationsEnabled_args args = new setNotificationsEnabled_args();
    args.read(iprot);
    iprot.readMessageEnd();
    setNotificationsEnabled_result result = new setNotificationsEnabled_result();
    try {
      iface_.setNotificationsEnabled(args.reqSeq, args.type, args.target, args.enablement);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing setNotificationsEnabled");
      oprot.writeMessageBegin(new TMessage("setNotificationsEnabled", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("setNotificationsEnabled", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  startUpdateVerification(int seqid, TProtocol iprot, TProtocol oprot) async {
    startUpdateVerification_args args = new startUpdateVerification_args();
    args.read(iprot);
    iprot.readMessageEnd();
    startUpdateVerification_result result = new startUpdateVerification_result();
    try {
      result.success = await iface_.startUpdateVerification(args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.locale);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing startUpdateVerification");
      oprot.writeMessageBegin(new TMessage("startUpdateVerification", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("startUpdateVerification", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  startVerification(int seqid, TProtocol iprot, TProtocol oprot) async {
    startVerification_args args = new startVerification_args();
    args.read(iprot);
    iprot.readMessageEnd();
    startVerification_result result = new startVerification_result();
    try {
      result.success = await iface_.startVerification(args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.mid, args.locale, args.simInfo, args.oldUdidHash);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing startVerification");
      oprot.writeMessageBegin(new TMessage("startVerification", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("startVerification", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateGroupPreferenceAttribute(int seqid, TProtocol iprot, TProtocol oprot) {
    updateGroupPreferenceAttribute_args args = new updateGroupPreferenceAttribute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateGroupPreferenceAttribute_result result = new updateGroupPreferenceAttribute_result();
    try {
      iface_.updateGroupPreferenceAttribute(args.reqSeq, args.groupMid, args.updatedAttrs);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateGroupPreferenceAttribute");
      oprot.writeMessageBegin(new TMessage("updateGroupPreferenceAttribute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateGroupPreferenceAttribute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createRoomV2(int seqid, TProtocol iprot, TProtocol oprot) async {
    createRoomV2_args args = new createRoomV2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createRoomV2_result result = new createRoomV2_result();
    try {
      result.success = await iface_.createRoomV2(args.reqSeq, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createRoomV2");
      oprot.writeMessageBegin(new TMessage("createRoomV2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createRoomV2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  storeUpdateProfileAttribute(int seqid, TProtocol iprot, TProtocol oprot) {
    storeUpdateProfileAttribute_args args = new storeUpdateProfileAttribute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    storeUpdateProfileAttribute_result result = new storeUpdateProfileAttribute_result();
    try {
      iface_.storeUpdateProfileAttribute(args.seq, args.profileAttribute, args.value);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing storeUpdateProfileAttribute");
      oprot.writeMessageBegin(new TMessage("storeUpdateProfileAttribute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("storeUpdateProfileAttribute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  syncContactBySnsIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    syncContactBySnsIds_args args = new syncContactBySnsIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    syncContactBySnsIds_result result = new syncContactBySnsIds_result();
    try {
      result.success = await iface_.syncContactBySnsIds(args.reqSeq, args.modifications);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing syncContactBySnsIds");
      oprot.writeMessageBegin(new TMessage("syncContactBySnsIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("syncContactBySnsIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  syncContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    syncContacts_args args = new syncContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    syncContacts_result result = new syncContacts_result();
    try {
      result.success = await iface_.syncContacts(args.reqSeq, args.localContacts);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing syncContacts");
      oprot.writeMessageBegin(new TMessage("syncContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("syncContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  trySendMessage(int seqid, TProtocol iprot, TProtocol oprot) async {
    trySendMessage_args args = new trySendMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    trySendMessage_result result = new trySendMessage_result();
    try {
      result.success = await iface_.trySendMessage(args.seq, args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing trySendMessage");
      oprot.writeMessageBegin(new TMessage("trySendMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("trySendMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getNextMessagesV2(int seqid, TProtocol iprot, TProtocol oprot) async {
    getNextMessagesV2_args args = new getNextMessagesV2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getNextMessagesV2_result result = new getNextMessagesV2_result();
    try {
      result.success = await iface_.getNextMessagesV2(args.messageBoxId, args.startMessageId, args.messagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getNextMessagesV2");
      oprot.writeMessageBegin(new TMessage("getNextMessagesV2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getNextMessagesV2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMessageBoxCompactWrapUpV2(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMessageBoxCompactWrapUpV2_args args = new getMessageBoxCompactWrapUpV2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMessageBoxCompactWrapUpV2_result result = new getMessageBoxCompactWrapUpV2_result();
    try {
      result.success = await iface_.getMessageBoxCompactWrapUpV2(args.messageBoxId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMessageBoxCompactWrapUpV2");
      oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUpV2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMessageBoxCompactWrapUpV2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRecentMessagesV2(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRecentMessagesV2_args args = new getRecentMessagesV2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRecentMessagesV2_result result = new getRecentMessagesV2_result();
    try {
      result.success = await iface_.getRecentMessagesV2(args.messageBoxId, args.messagesCount);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRecentMessagesV2");
      oprot.writeMessageBegin(new TMessage("getRecentMessagesV2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRecentMessagesV2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  validateContactsOnBot(int seqid, TProtocol iprot, TProtocol oprot) async {
    validateContactsOnBot_args args = new validateContactsOnBot_args();
    args.read(iprot);
    iprot.readMessageEnd();
    validateContactsOnBot_result result = new validateContactsOnBot_result();
    try {
      result.success = await iface_.validateContactsOnBot(args.contacts);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing validateContactsOnBot");
      oprot.writeMessageBegin(new TMessage("validateContactsOnBot", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("validateContactsOnBot", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tryFriendRequest(int seqid, TProtocol iprot, TProtocol oprot) {
    tryFriendRequest_args args = new tryFriendRequest_args();
    args.read(iprot);
    iprot.readMessageEnd();
    tryFriendRequest_result result = new tryFriendRequest_result();
    try {
      iface_.tryFriendRequest(args.midOrEMid, args.method, args.friendRequestParams);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing tryFriendRequest");
      oprot.writeMessageBegin(new TMessage("tryFriendRequest", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("tryFriendRequest", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  unblockContact(int seqid, TProtocol iprot, TProtocol oprot) {
    unblockContact_args args = new unblockContact_args();
    args.read(iprot);
    iprot.readMessageEnd();
    unblockContact_result result = new unblockContact_result();
    try {
      iface_.unblockContact(args.reqSeq, args.id);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing unblockContact");
      oprot.writeMessageBegin(new TMessage("unblockContact", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("unblockContact", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  unblockRecommendation(int seqid, TProtocol iprot, TProtocol oprot) {
    unblockRecommendation_args args = new unblockRecommendation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    unblockRecommendation_result result = new unblockRecommendation_result();
    try {
      iface_.unblockRecommendation(args.reqSeq, args.id);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing unblockRecommendation");
      oprot.writeMessageBegin(new TMessage("unblockRecommendation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("unblockRecommendation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  unregisterUserAndDevice(int seqid, TProtocol iprot, TProtocol oprot) async {
    unregisterUserAndDevice_args args = new unregisterUserAndDevice_args();
    args.read(iprot);
    iprot.readMessageEnd();
    unregisterUserAndDevice_result result = new unregisterUserAndDevice_result();
    try {
      result.success = await iface_.unregisterUserAndDevice();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing unregisterUserAndDevice");
      oprot.writeMessageBegin(new TMessage("unregisterUserAndDevice", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("unregisterUserAndDevice", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateApnsDeviceToken(int seqid, TProtocol iprot, TProtocol oprot) {
    updateApnsDeviceToken_args args = new updateApnsDeviceToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateApnsDeviceToken_result result = new updateApnsDeviceToken_result();
    try {
      iface_.updateApnsDeviceToken(args.apnsDeviceToken);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateApnsDeviceToken");
      oprot.writeMessageBegin(new TMessage("updateApnsDeviceToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateApnsDeviceToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateBuddySetting(int seqid, TProtocol iprot, TProtocol oprot) {
    updateBuddySetting_args args = new updateBuddySetting_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateBuddySetting_result result = new updateBuddySetting_result();
    try {
      iface_.updateBuddySetting(args.key, args.value);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateBuddySetting");
      oprot.writeMessageBegin(new TMessage("updateBuddySetting", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateBuddySetting", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateC2DMRegistrationId(int seqid, TProtocol iprot, TProtocol oprot) {
    updateC2DMRegistrationId_args args = new updateC2DMRegistrationId_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateC2DMRegistrationId_result result = new updateC2DMRegistrationId_result();
    try {
      iface_.updateC2DMRegistrationId(args.registrationId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateC2DMRegistrationId");
      oprot.writeMessageBegin(new TMessage("updateC2DMRegistrationId", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateC2DMRegistrationId", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateContactSetting(int seqid, TProtocol iprot, TProtocol oprot) {
    updateContactSetting_args args = new updateContactSetting_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateContactSetting_result result = new updateContactSetting_result();
    try {
      iface_.updateContactSetting(args.reqSeq, args.mid, args.flag, args.value);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateContactSetting");
      oprot.writeMessageBegin(new TMessage("updateContactSetting", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateContactSetting", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateCustomModeSettings(int seqid, TProtocol iprot, TProtocol oprot) {
    updateCustomModeSettings_args args = new updateCustomModeSettings_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateCustomModeSettings_result result = new updateCustomModeSettings_result();
    try {
      iface_.updateCustomModeSettings(args.customMode, args.paramMap);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateCustomModeSettings");
      oprot.writeMessageBegin(new TMessage("updateCustomModeSettings", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateCustomModeSettings", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateDeviceInfo(int seqid, TProtocol iprot, TProtocol oprot) {
    updateDeviceInfo_args args = new updateDeviceInfo_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateDeviceInfo_result result = new updateDeviceInfo_result();
    try {
      iface_.updateDeviceInfo(args.deviceUid, args.deviceInfo);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateDeviceInfo");
      oprot.writeMessageBegin(new TMessage("updateDeviceInfo", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateDeviceInfo", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateGroup(int seqid, TProtocol iprot, TProtocol oprot) {
    updateGroup_args args = new updateGroup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateGroup_result result = new updateGroup_result();
    try {
      iface_.updateGroup(args.reqSeq, args.group);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateGroup");
      oprot.writeMessageBegin(new TMessage("updateGroup", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateGroup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateNotificationToken(int seqid, TProtocol iprot, TProtocol oprot) {
    updateNotificationToken_args args = new updateNotificationToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateNotificationToken_result result = new updateNotificationToken_result();
    try {
      iface_.updateNotificationToken(args.type, args.token);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateNotificationToken");
      oprot.writeMessageBegin(new TMessage("updateNotificationToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateNotificationToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateNotificationTokenWithBytes(int seqid, TProtocol iprot, TProtocol oprot) {
    updateNotificationTokenWithBytes_args args = new updateNotificationTokenWithBytes_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateNotificationTokenWithBytes_result result = new updateNotificationTokenWithBytes_result();
    try {
      iface_.updateNotificationTokenWithBytes(args.type, args.token);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateNotificationTokenWithBytes");
      oprot.writeMessageBegin(new TMessage("updateNotificationTokenWithBytes", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateNotificationTokenWithBytes", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateProfile(int seqid, TProtocol iprot, TProtocol oprot) {
    updateProfile_args args = new updateProfile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateProfile_result result = new updateProfile_result();
    try {
      iface_.updateProfile(args.reqSeq, args.profile);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateProfile");
      oprot.writeMessageBegin(new TMessage("updateProfile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateProfile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateProfileAttribute(int seqid, TProtocol iprot, TProtocol oprot) {
    updateProfileAttribute_args args = new updateProfileAttribute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateProfileAttribute_result result = new updateProfileAttribute_result();
    try {
      iface_.updateProfileAttribute(args.reqSeq, args.attr, args.value);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateProfileAttribute");
      oprot.writeMessageBegin(new TMessage("updateProfileAttribute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateProfileAttribute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateRegion(int seqid, TProtocol iprot, TProtocol oprot) {
    updateRegion_args args = new updateRegion_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateRegion_result result = new updateRegion_result();
    try {
      iface_.updateRegion(args.region);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateRegion");
      oprot.writeMessageBegin(new TMessage("updateRegion", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateRegion", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateSettings(int seqid, TProtocol iprot, TProtocol oprot) {
    updateSettings_args args = new updateSettings_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateSettings_result result = new updateSettings_result();
    try {
      iface_.updateSettings(args.reqSeq, args.settings);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateSettings");
      oprot.writeMessageBegin(new TMessage("updateSettings", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateSettings", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateSettings2(int seqid, TProtocol iprot, TProtocol oprot) async {
    updateSettings2_args args = new updateSettings2_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateSettings2_result result = new updateSettings2_result();
    try {
      result.success = await iface_.updateSettings2(args.reqSeq, args.settings);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateSettings2");
      oprot.writeMessageBegin(new TMessage("updateSettings2", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateSettings2", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateSettingsAttribute(int seqid, TProtocol iprot, TProtocol oprot) {
    updateSettingsAttribute_args args = new updateSettingsAttribute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateSettingsAttribute_result result = new updateSettingsAttribute_result();
    try {
      iface_.updateSettingsAttribute(args.reqSeq, args.attr, args.value);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateSettingsAttribute");
      oprot.writeMessageBegin(new TMessage("updateSettingsAttribute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateSettingsAttribute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateSettingsAttributes(int seqid, TProtocol iprot, TProtocol oprot) async {
    updateSettingsAttributes_args args = new updateSettingsAttributes_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateSettingsAttributes_result result = new updateSettingsAttributes_result();
    try {
      result.success = await iface_.updateSettingsAttributes(args.reqSeq, args.attrBitset, args.settings);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateSettingsAttributes");
      oprot.writeMessageBegin(new TMessage("updateSettingsAttributes", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateSettingsAttributes", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  verifyIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) {
    verifyIdentityCredential_args args = new verifyIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyIdentityCredential_result result = new verifyIdentityCredential_result();
    try {
      iface_.verifyIdentityCredential(args.identityProvider, args.identifier, args.password);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing verifyIdentityCredential");
      oprot.writeMessageBegin(new TMessage("verifyIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("verifyIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  verifyIdentityCredentialWithResult(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyIdentityCredentialWithResult_args args = new verifyIdentityCredentialWithResult_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyIdentityCredentialWithResult_result result = new verifyIdentityCredentialWithResult_result();
    try {
      result.success = await iface_.verifyIdentityCredentialWithResult(args.identityCredential);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing verifyIdentityCredentialWithResult");
      oprot.writeMessageBegin(new TMessage("verifyIdentityCredentialWithResult", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("verifyIdentityCredentialWithResult", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  verifyPhone(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyPhone_args args = new verifyPhone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyPhone_result result = new verifyPhone_result();
    try {
      result.success = await iface_.verifyPhone(args.sessionId, args.pinCode, args.udidHash);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing verifyPhone");
      oprot.writeMessageBegin(new TMessage("verifyPhone", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("verifyPhone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  verifyQrcode(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyQrcode_args args = new verifyQrcode_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyQrcode_result result = new verifyQrcode_result();
    try {
      result.success = await iface_.verifyQrcode(args.verifier, args.pinCode);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing verifyQrcode");
      oprot.writeMessageBegin(new TMessage("verifyQrcode", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("verifyQrcode", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

}

class getChatRoomAnnouncementsBulk_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChatRoomAnnouncementsBulk_args");
  static final TField _CHAT_ROOM_MIDS_FIELD_DESC = new TField("chatRoomMids", TType.LIST, 2);

  List<String> _chatRoomMids;
  static const int CHATROOMMIDS = 2;


  getChatRoomAnnouncementsBulk_args() {
  }

  // chatRoomMids
  List<String> get chatRoomMids => this._chatRoomMids;

  set chatRoomMids(List<String> chatRoomMids) {
    this._chatRoomMids = chatRoomMids;
  }

  bool isSetChatRoomMids() => this.chatRoomMids != null;

  unsetChatRoomMids() {
    this.chatRoomMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATROOMMIDS:
        return this.chatRoomMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATROOMMIDS:
        if (value == null) {
          unsetChatRoomMids();
        } else {
          this.chatRoomMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATROOMMIDS:
        return isSetChatRoomMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATROOMMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list802 = iprot.readListBegin();
              this.chatRoomMids = new List<String>();
              for (int _i803 = 0; _i803 < _list802.length; ++_i803) {
                String _elem804;
                _elem804 = iprot.readString();
                this.chatRoomMids.add(_elem804);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatRoomMids != null) {
      oprot.writeFieldBegin(_CHAT_ROOM_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.chatRoomMids.length));
        for (var elem805 in this.chatRoomMids) {
          oprot.writeString(elem805);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChatRoomAnnouncementsBulk_args(");

    ret.write("chatRoomMids:");
    if (this.chatRoomMids == null) {
      ret.write("null");
    } else {
      ret.write(this.chatRoomMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChatRoomAnnouncementsBulk_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChatRoomAnnouncementsBulk_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, List<ChatRoomAnnouncement>> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getChatRoomAnnouncementsBulk_result() {
  }

  // success
  Map<String, List<ChatRoomAnnouncement>> get success => this._success;

  set success(Map<String, List<ChatRoomAnnouncement>> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map806 = iprot.readMapBegin();
              this.success = new Map<String, List<ChatRoomAnnouncement>>();
              for (int _i807 = 0; _i807 < _map806.length; ++_i807) {
                String _key808;
                List<ChatRoomAnnouncement> _val809;
                _key808 = iprot.readString();
                {
                  TList _list810 = iprot.readListBegin();
                  _val809 = new List<ChatRoomAnnouncement>();
                  for (int _i811 = 0; _i811 < _list810.length; ++_i811) {
                    ChatRoomAnnouncement _elem812;
                    _elem812 = new ChatRoomAnnouncement();
                    _elem812.read(iprot);
                    _val809.add(_elem812);
                  }
                  iprot.readListEnd();
                }
                this.success[_key808] = _val809;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.length));
        for (var elem814 in this.success.keys) {
          oprot.writeString(elem814);
          {
            oprot.writeListBegin(new TList(TType.STRUCT, this.success[elem814].length));
            for (var elem815 in this.success[elem814]) {
              elem815.write(oprot);
            }
            oprot.writeListEnd();
          }
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChatRoomAnnouncementsBulk_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChatRoomAnnouncements_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChatRoomAnnouncements_args");
  static final TField _CHAT_ROOM_MID_FIELD_DESC = new TField("chatRoomMid", TType.STRING, 2);

  String _chatRoomMid;
  static const int CHATROOMMID = 2;


  getChatRoomAnnouncements_args() {
  }

  // chatRoomMid
  String get chatRoomMid => this._chatRoomMid;

  set chatRoomMid(String chatRoomMid) {
    this._chatRoomMid = chatRoomMid;
  }

  bool isSetChatRoomMid() => this.chatRoomMid != null;

  unsetChatRoomMid() {
    this.chatRoomMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATROOMMID:
        return this.chatRoomMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATROOMMID:
        if (value == null) {
          unsetChatRoomMid();
        } else {
          this.chatRoomMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATROOMMID:
        return isSetChatRoomMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATROOMMID:
          if (field.type == TType.STRING) {
            this.chatRoomMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatRoomMid != null) {
      oprot.writeFieldBegin(_CHAT_ROOM_MID_FIELD_DESC);
      oprot.writeString(this.chatRoomMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChatRoomAnnouncements_args(");

    ret.write("chatRoomMid:");
    if (this.chatRoomMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatRoomMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChatRoomAnnouncements_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChatRoomAnnouncements_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<ChatRoomAnnouncement> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getChatRoomAnnouncements_result() {
  }

  // success
  List<ChatRoomAnnouncement> get success => this._success;

  set success(List<ChatRoomAnnouncement> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list816 = iprot.readListBegin();
              this.success = new List<ChatRoomAnnouncement>();
              for (int _i817 = 0; _i817 < _list816.length; ++_i817) {
                ChatRoomAnnouncement _elem818;
                _elem818 = new ChatRoomAnnouncement();
                _elem818.read(iprot);
                this.success.add(_elem818);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem819 in this.success) {
          elem819.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChatRoomAnnouncements_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createChatRoomAnnouncement_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createChatRoomAnnouncement_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _CHAT_ROOM_MID_FIELD_DESC = new TField("chatRoomMid", TType.STRING, 2);
  static final TField _TYPE_FIELD_DESC = new TField("type", TType.I32, 3);
  static final TField _CONTENTS_FIELD_DESC = new TField("contents", TType.STRUCT, 4);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _chatRoomMid;
  static const int CHATROOMMID = 2;
  int _type;
  static const int TYPE = 3;
  ChatRoomAnnouncementContents _contents;
  static const int CONTENTS = 4;

  bool __isset_reqSeq = false;
  bool __isset_type = false;

  createChatRoomAnnouncement_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // chatRoomMid
  String get chatRoomMid => this._chatRoomMid;

  set chatRoomMid(String chatRoomMid) {
    this._chatRoomMid = chatRoomMid;
  }

  bool isSetChatRoomMid() => this.chatRoomMid != null;

  unsetChatRoomMid() {
    this.chatRoomMid = null;
  }

  // type
  int get type => this._type;

  set type(int type) {
    this._type = type;
    this.__isset_type = true;
  }

  bool isSetType() => this.__isset_type;

  unsetType() {
    this.__isset_type = false;
  }

  // contents
  ChatRoomAnnouncementContents get contents => this._contents;

  set contents(ChatRoomAnnouncementContents contents) {
    this._contents = contents;
  }

  bool isSetContents() => this.contents != null;

  unsetContents() {
    this.contents = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case CHATROOMMID:
        return this.chatRoomMid;
      case TYPE:
        return this.type;
      case CONTENTS:
        return this.contents;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case CHATROOMMID:
        if (value == null) {
          unsetChatRoomMid();
        } else {
          this.chatRoomMid = value;
        }
        break;

      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          this.type = value;
        }
        break;

      case CONTENTS:
        if (value == null) {
          unsetContents();
        } else {
          this.contents = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case CHATROOMMID:
        return isSetChatRoomMid();
      case TYPE:
        return isSetType();
      case CONTENTS:
        return isSetContents();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CHATROOMMID:
          if (field.type == TType.STRING) {
            this.chatRoomMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TYPE:
          if (field.type == TType.I32) {
            this.type = iprot.readI32();
            this.__isset_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTENTS:
          if (field.type == TType.STRUCT) {
            this.contents = new ChatRoomAnnouncementContents();
            this.contents.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.chatRoomMid != null) {
      oprot.writeFieldBegin(_CHAT_ROOM_MID_FIELD_DESC);
      oprot.writeString(this.chatRoomMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_TYPE_FIELD_DESC);
    oprot.writeI32(this.type);
    oprot.writeFieldEnd();
    if (this.contents != null) {
      oprot.writeFieldBegin(_CONTENTS_FIELD_DESC);
      this.contents.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createChatRoomAnnouncement_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("chatRoomMid:");
    if (this.chatRoomMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatRoomMid);
    }

    ret.write(", ");
    ret.write("type:");
    String type_name = ChatRoomAnnouncementType.VALUES_TO_NAMES[this.type];
    if (type_name != null) {
      ret.write(type_name);
      ret.write(" (");
    }
    ret.write(this.type);
    if (type_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("contents:");
    if (this.contents == null) {
      ret.write("null");
    } else {
      ret.write(this.contents);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetType() && !ChatRoomAnnouncementType.VALID_VALUES.contains(type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'type' has been assigned the invalid value $type");
    }
  }

}

class createChatRoomAnnouncement_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createChatRoomAnnouncement_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChatRoomAnnouncement _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createChatRoomAnnouncement_result() {
  }

  // success
  ChatRoomAnnouncement get success => this._success;

  set success(ChatRoomAnnouncement success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChatRoomAnnouncement();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createChatRoomAnnouncement_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeChatRoomAnnouncement_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeChatRoomAnnouncement_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _CHAT_ROOM_MID_FIELD_DESC = new TField("chatRoomMid", TType.STRING, 2);
  static final TField _ANNOUNCEMENT_SEQ_FIELD_DESC = new TField("announcementSeq", TType.I64, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _chatRoomMid;
  static const int CHATROOMMID = 2;
  int _announcementSeq = 0;
  static const int ANNOUNCEMENTSEQ = 3;

  bool __isset_reqSeq = false;
  bool __isset_announcementSeq = false;

  removeChatRoomAnnouncement_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // chatRoomMid
  String get chatRoomMid => this._chatRoomMid;

  set chatRoomMid(String chatRoomMid) {
    this._chatRoomMid = chatRoomMid;
  }

  bool isSetChatRoomMid() => this.chatRoomMid != null;

  unsetChatRoomMid() {
    this.chatRoomMid = null;
  }

  // announcementSeq
  int get announcementSeq => this._announcementSeq;

  set announcementSeq(int announcementSeq) {
    this._announcementSeq = announcementSeq;
    this.__isset_announcementSeq = true;
  }

  bool isSetAnnouncementSeq() => this.__isset_announcementSeq;

  unsetAnnouncementSeq() {
    this.__isset_announcementSeq = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case CHATROOMMID:
        return this.chatRoomMid;
      case ANNOUNCEMENTSEQ:
        return this.announcementSeq;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case CHATROOMMID:
        if (value == null) {
          unsetChatRoomMid();
        } else {
          this.chatRoomMid = value;
        }
        break;

      case ANNOUNCEMENTSEQ:
        if (value == null) {
          unsetAnnouncementSeq();
        } else {
          this.announcementSeq = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case CHATROOMMID:
        return isSetChatRoomMid();
      case ANNOUNCEMENTSEQ:
        return isSetAnnouncementSeq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CHATROOMMID:
          if (field.type == TType.STRING) {
            this.chatRoomMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ANNOUNCEMENTSEQ:
          if (field.type == TType.I64) {
            this.announcementSeq = iprot.readI64();
            this.__isset_announcementSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.chatRoomMid != null) {
      oprot.writeFieldBegin(_CHAT_ROOM_MID_FIELD_DESC);
      oprot.writeString(this.chatRoomMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_ANNOUNCEMENT_SEQ_FIELD_DESC);
    oprot.writeI64(this.announcementSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeChatRoomAnnouncement_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("chatRoomMid:");
    if (this.chatRoomMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatRoomMid);
    }

    ret.write(", ");
    ret.write("announcementSeq:");
    ret.write(this.announcementSeq);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeChatRoomAnnouncement_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeChatRoomAnnouncement_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  removeChatRoomAnnouncement_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeChatRoomAnnouncement_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unsendMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unsendMessage_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 2);

  int _seq = 0;
  static const int SEQ = 1;
  String _messageId;
  static const int MESSAGEID = 2;

  bool __isset_seq = false;

  unsendMessage_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGEID:
        return this.messageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGEID:
        return isSetMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unsendMessage_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unsendMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unsendMessage_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  unsendMessage_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unsendMessage_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupWithoutMembers_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupWithoutMembers_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);

  String _groupId;
  static const int GROUPID = 2;


  getGroupWithoutMembers_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupWithoutMembers_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupWithoutMembers_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupWithoutMembers_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Group _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupWithoutMembers_result() {
  }

  // success
  Group get success => this._success;

  set success(Group success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Group();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupWithoutMembers_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestResendMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestResendMessage_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _SENDER_MID_FIELD_DESC = new TField("senderMid", TType.STRING, 2);
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _senderMid;
  static const int SENDERMID = 2;
  String _messageId;
  static const int MESSAGEID = 3;

  bool __isset_reqSeq = false;

  requestResendMessage_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // senderMid
  String get senderMid => this._senderMid;

  set senderMid(String senderMid) {
    this._senderMid = senderMid;
  }

  bool isSetSenderMid() => this.senderMid != null;

  unsetSenderMid() {
    this.senderMid = null;
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case SENDERMID:
        return this.senderMid;
      case MESSAGEID:
        return this.messageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case SENDERMID:
        if (value == null) {
          unsetSenderMid();
        } else {
          this.senderMid = value;
        }
        break;

      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case SENDERMID:
        return isSetSenderMid();
      case MESSAGEID:
        return isSetMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SENDERMID:
          if (field.type == TType.STRING) {
            this.senderMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.senderMid != null) {
      oprot.writeFieldBegin(_SENDER_MID_FIELD_DESC);
      oprot.writeString(this.senderMid);
      oprot.writeFieldEnd();
    }
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestResendMessage_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("senderMid:");
    if (this.senderMid == null) {
      ret.write("null");
    } else {
      ret.write(this.senderMid);
    }

    ret.write(", ");
    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestResendMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestResendMessage_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  requestResendMessage_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestResendMessage_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class respondResendMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("respondResendMessage_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _RECEIVER_MID_FIELD_DESC = new TField("receiverMid", TType.STRING, 2);
  static final TField _ORIGINAL_MESSAGE_ID_FIELD_DESC = new TField("originalMessageId", TType.STRING, 3);
  static final TField _RESEND_MESSAGE_FIELD_DESC = new TField("resendMessage", TType.STRUCT, 4);
  static final TField _ERROR_CODE_FIELD_DESC = new TField("errorCode", TType.I32, 5);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _receiverMid;
  static const int RECEIVERMID = 2;
  String _originalMessageId;
  static const int ORIGINALMESSAGEID = 3;
  Message _resendMessage;
  static const int RESENDMESSAGE = 4;
  int _errorCode;
  static const int ERRORCODE = 5;

  bool __isset_reqSeq = false;
  bool __isset_errorCode = false;

  respondResendMessage_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // receiverMid
  String get receiverMid => this._receiverMid;

  set receiverMid(String receiverMid) {
    this._receiverMid = receiverMid;
  }

  bool isSetReceiverMid() => this.receiverMid != null;

  unsetReceiverMid() {
    this.receiverMid = null;
  }

  // originalMessageId
  String get originalMessageId => this._originalMessageId;

  set originalMessageId(String originalMessageId) {
    this._originalMessageId = originalMessageId;
  }

  bool isSetOriginalMessageId() => this.originalMessageId != null;

  unsetOriginalMessageId() {
    this.originalMessageId = null;
  }

  // resendMessage
  Message get resendMessage => this._resendMessage;

  set resendMessage(Message resendMessage) {
    this._resendMessage = resendMessage;
  }

  bool isSetResendMessage() => this.resendMessage != null;

  unsetResendMessage() {
    this.resendMessage = null;
  }

  // errorCode
  int get errorCode => this._errorCode;

  set errorCode(int errorCode) {
    this._errorCode = errorCode;
    this.__isset_errorCode = true;
  }

  bool isSetErrorCode() => this.__isset_errorCode;

  unsetErrorCode() {
    this.__isset_errorCode = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case RECEIVERMID:
        return this.receiverMid;
      case ORIGINALMESSAGEID:
        return this.originalMessageId;
      case RESENDMESSAGE:
        return this.resendMessage;
      case ERRORCODE:
        return this.errorCode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case RECEIVERMID:
        if (value == null) {
          unsetReceiverMid();
        } else {
          this.receiverMid = value;
        }
        break;

      case ORIGINALMESSAGEID:
        if (value == null) {
          unsetOriginalMessageId();
        } else {
          this.originalMessageId = value;
        }
        break;

      case RESENDMESSAGE:
        if (value == null) {
          unsetResendMessage();
        } else {
          this.resendMessage = value;
        }
        break;

      case ERRORCODE:
        if (value == null) {
          unsetErrorCode();
        } else {
          this.errorCode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case RECEIVERMID:
        return isSetReceiverMid();
      case ORIGINALMESSAGEID:
        return isSetOriginalMessageId();
      case RESENDMESSAGE:
        return isSetResendMessage();
      case ERRORCODE:
        return isSetErrorCode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMID:
          if (field.type == TType.STRING) {
            this.receiverMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ORIGINALMESSAGEID:
          if (field.type == TType.STRING) {
            this.originalMessageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RESENDMESSAGE:
          if (field.type == TType.STRUCT) {
            this.resendMessage = new Message();
            this.resendMessage.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ERRORCODE:
          if (field.type == TType.I32) {
            this.errorCode = iprot.readI32();
            this.__isset_errorCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.receiverMid != null) {
      oprot.writeFieldBegin(_RECEIVER_MID_FIELD_DESC);
      oprot.writeString(this.receiverMid);
      oprot.writeFieldEnd();
    }
    if (this.originalMessageId != null) {
      oprot.writeFieldBegin(_ORIGINAL_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.originalMessageId);
      oprot.writeFieldEnd();
    }
    if (this.resendMessage != null) {
      oprot.writeFieldBegin(_RESEND_MESSAGE_FIELD_DESC);
      this.resendMessage.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_ERROR_CODE_FIELD_DESC);
    oprot.writeI32(this.errorCode);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("respondResendMessage_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("receiverMid:");
    if (this.receiverMid == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMid);
    }

    ret.write(", ");
    ret.write("originalMessageId:");
    if (this.originalMessageId == null) {
      ret.write("null");
    } else {
      ret.write(this.originalMessageId);
    }

    ret.write(", ");
    ret.write("resendMessage:");
    if (this.resendMessage == null) {
      ret.write("null");
    } else {
      ret.write(this.resendMessage);
    }

    ret.write(", ");
    ret.write("errorCode:");
    String errorCode_name = ErrorCode.VALUES_TO_NAMES[this.errorCode];
    if (errorCode_name != null) {
      ret.write(errorCode_name);
      ret.write(" (");
    }
    ret.write(this.errorCode);
    if (errorCode_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetErrorCode() && !ErrorCode.VALID_VALUES.contains(errorCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'errorCode' has been assigned the invalid value $errorCode");
    }
  }

}

class respondResendMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("respondResendMessage_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  respondResendMessage_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("respondResendMessage_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acceptGroupInvitation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acceptGroupInvitation_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupId;
  static const int GROUPID = 2;

  bool __isset_reqSeq = false;

  acceptGroupInvitation_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acceptGroupInvitation_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acceptGroupInvitation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acceptGroupInvitation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  acceptGroupInvitation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acceptGroupInvitation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acceptGroupInvitationByTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acceptGroupInvitationByTicket_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_MID_FIELD_DESC = new TField("GroupMid", TType.STRING, 2);
  static final TField _TICKET_ID_FIELD_DESC = new TField("ticketId", TType.STRING, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupMid;
  static const int GROUPMID = 2;
  String _ticketId;
  static const int TICKETID = 3;

  bool __isset_reqSeq = false;

  acceptGroupInvitationByTicket_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupMid
  String get groupMid => this._groupMid;

  set groupMid(String groupMid) {
    this._groupMid = groupMid;
  }

  bool isSetGroupMid() => this.groupMid != null;

  unsetGroupMid() {
    this.groupMid = null;
  }

  // ticketId
  String get ticketId => this._ticketId;

  set ticketId(String ticketId) {
    this._ticketId = ticketId;
  }

  bool isSetTicketId() => this.ticketId != null;

  unsetTicketId() {
    this.ticketId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPMID:
        return this.groupMid;
      case TICKETID:
        return this.ticketId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPMID:
        if (value == null) {
          unsetGroupMid();
        } else {
          this.groupMid = value;
        }
        break;

      case TICKETID:
        if (value == null) {
          unsetTicketId();
        } else {
          this.ticketId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPMID:
        return isSetGroupMid();
      case TICKETID:
        return isSetTicketId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPMID:
          if (field.type == TType.STRING) {
            this.groupMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TICKETID:
          if (field.type == TType.STRING) {
            this.ticketId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupMid != null) {
      oprot.writeFieldBegin(_GROUP_MID_FIELD_DESC);
      oprot.writeString(this.groupMid);
      oprot.writeFieldEnd();
    }
    if (this.ticketId != null) {
      oprot.writeFieldBegin(_TICKET_ID_FIELD_DESC);
      oprot.writeString(this.ticketId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acceptGroupInvitationByTicket_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupMid:");
    if (this.groupMid == null) {
      ret.write("null");
    } else {
      ret.write(this.groupMid);
    }

    ret.write(", ");
    ret.write("ticketId:");
    if (this.ticketId == null) {
      ret.write("null");
    } else {
      ret.write(this.ticketId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acceptGroupInvitationByTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acceptGroupInvitationByTicket_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  acceptGroupInvitationByTicket_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acceptGroupInvitationByTicket_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acceptProximityMatches_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acceptProximityMatches_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _IDS_FIELD_DESC = new TField("ids", TType.SET, 3);

  String _sessionId;
  static const int SESSIONID = 2;
  Set<String> _ids;
  static const int IDS = 3;


  acceptProximityMatches_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // ids
  Set<String> get ids => this._ids;

  set ids(Set<String> ids) {
    this._ids = ids;
  }

  bool isSetIds() => this.ids != null;

  unsetIds() {
    this.ids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case IDS:
        return this.ids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case IDS:
        if (value == null) {
          unsetIds();
        } else {
          this.ids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case IDS:
        return isSetIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDS:
          if (field.type == TType.SET) {
            {
              TSet _set820 = iprot.readSetBegin();
              this.ids = new Set<String>();
              for (int _i821 = 0; _i821 < _set820.length; ++_i821) {
                String _elem822;
                _elem822 = iprot.readString();
                this.ids.add(_elem822);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    if (this.ids != null) {
      oprot.writeFieldBegin(_IDS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRING, this.ids.length));
        for (var elem823 in this.ids) {
          oprot.writeString(elem823);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acceptProximityMatches_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("ids:");
    if (this.ids == null) {
      ret.write("null");
    } else {
      ret.write(this.ids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acceptProximityMatches_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acceptProximityMatches_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  acceptProximityMatches_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acceptProximityMatches_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquireCallRoute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireCallRoute_args");
  static final TField _TO_FIELD_DESC = new TField("to", TType.STRING, 2);

  String _to;
  static const int TO = 2;


  acquireCallRoute_args() {
  }

  // to
  String get to => this._to;

  set to(String to) {
    this._to = to;
  }

  bool isSetTo() => this.to != null;

  unsetTo() {
    this.to = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TO:
        return this.to;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TO:
        if (value == null) {
          unsetTo();
        } else {
          this.to = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TO:
        return isSetTo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TO:
          if (field.type == TType.STRING) {
            this.to = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.to != null) {
      oprot.writeFieldBegin(_TO_FIELD_DESC);
      oprot.writeString(this.to);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireCallRoute_args(");

    ret.write("to:");
    if (this.to == null) {
      ret.write("null");
    } else {
      ret.write(this.to);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquireCallRoute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireCallRoute_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  acquireCallRoute_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list824 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i825 = 0; _i825 < _list824.length; ++_i825) {
                String _elem826;
                _elem826 = iprot.readString();
                this.success.add(_elem826);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem827 in this.success) {
          oprot.writeString(elem827);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireCallRoute_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquireCallTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireCallTicket_args");
  static final TField _TO_FIELD_DESC = new TField("to", TType.STRING, 2);

  String _to;
  static const int TO = 2;


  acquireCallTicket_args() {
  }

  // to
  String get to => this._to;

  set to(String to) {
    this._to = to;
  }

  bool isSetTo() => this.to != null;

  unsetTo() {
    this.to = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TO:
        return this.to;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TO:
        if (value == null) {
          unsetTo();
        } else {
          this.to = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TO:
        return isSetTo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TO:
          if (field.type == TType.STRING) {
            this.to = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.to != null) {
      oprot.writeFieldBegin(_TO_FIELD_DESC);
      oprot.writeString(this.to);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireCallTicket_args(");

    ret.write("to:");
    if (this.to == null) {
      ret.write("null");
    } else {
      ret.write(this.to);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquireCallTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireCallTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  acquireCallTicket_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireCallTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquireEncryptedAccessToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireEncryptedAccessToken_args");
  static final TField _FEATURE_TYPE_FIELD_DESC = new TField("featureType", TType.I32, 2);

  int _featureType;
  static const int FEATURETYPE = 2;

  bool __isset_featureType = false;

  acquireEncryptedAccessToken_args() {
  }

  // featureType
  int get featureType => this._featureType;

  set featureType(int featureType) {
    this._featureType = featureType;
    this.__isset_featureType = true;
  }

  bool isSetFeatureType() => this.__isset_featureType;

  unsetFeatureType() {
    this.__isset_featureType = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case FEATURETYPE:
        return this.featureType;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case FEATURETYPE:
        if (value == null) {
          unsetFeatureType();
        } else {
          this.featureType = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case FEATURETYPE:
        return isSetFeatureType();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case FEATURETYPE:
          if (field.type == TType.I32) {
            this.featureType = iprot.readI32();
            this.__isset_featureType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_FEATURE_TYPE_FIELD_DESC);
    oprot.writeI32(this.featureType);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireEncryptedAccessToken_args(");

    ret.write("featureType:");
    String featureType_name = FeatureType.VALUES_TO_NAMES[this.featureType];
    if (featureType_name != null) {
      ret.write(featureType_name);
      ret.write(" (");
    }
    ret.write(this.featureType);
    if (featureType_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetFeatureType() && !FeatureType.VALID_VALUES.contains(featureType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'featureType' has been assigned the invalid value $featureType");
    }
  }

}

class acquireEncryptedAccessToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireEncryptedAccessToken_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  acquireEncryptedAccessToken_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireEncryptedAccessToken_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class addSnsId_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addSnsId_args");
  static final TField _SNS_ID_TYPE_FIELD_DESC = new TField("snsIdType", TType.I32, 2);
  static final TField _SNS_ACCESS_TOKEN_FIELD_DESC = new TField("snsAccessToken", TType.STRING, 3);

  int _snsIdType;
  static const int SNSIDTYPE = 2;
  String _snsAccessToken;
  static const int SNSACCESSTOKEN = 3;

  bool __isset_snsIdType = false;

  addSnsId_args() {
  }

  // snsIdType
  int get snsIdType => this._snsIdType;

  set snsIdType(int snsIdType) {
    this._snsIdType = snsIdType;
    this.__isset_snsIdType = true;
  }

  bool isSetSnsIdType() => this.__isset_snsIdType;

  unsetSnsIdType() {
    this.__isset_snsIdType = false;
  }

  // snsAccessToken
  String get snsAccessToken => this._snsAccessToken;

  set snsAccessToken(String snsAccessToken) {
    this._snsAccessToken = snsAccessToken;
  }

  bool isSetSnsAccessToken() => this.snsAccessToken != null;

  unsetSnsAccessToken() {
    this.snsAccessToken = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return this.snsIdType;
      case SNSACCESSTOKEN:
        return this.snsAccessToken;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SNSIDTYPE:
        if (value == null) {
          unsetSnsIdType();
        } else {
          this.snsIdType = value;
        }
        break;

      case SNSACCESSTOKEN:
        if (value == null) {
          unsetSnsAccessToken();
        } else {
          this.snsAccessToken = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return isSetSnsIdType();
      case SNSACCESSTOKEN:
        return isSetSnsAccessToken();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SNSIDTYPE:
          if (field.type == TType.I32) {
            this.snsIdType = iprot.readI32();
            this.__isset_snsIdType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SNSACCESSTOKEN:
          if (field.type == TType.STRING) {
            this.snsAccessToken = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SNS_ID_TYPE_FIELD_DESC);
    oprot.writeI32(this.snsIdType);
    oprot.writeFieldEnd();
    if (this.snsAccessToken != null) {
      oprot.writeFieldBegin(_SNS_ACCESS_TOKEN_FIELD_DESC);
      oprot.writeString(this.snsAccessToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addSnsId_args(");

    ret.write("snsIdType:");
    String snsIdType_name = SnsIdType.VALUES_TO_NAMES[this.snsIdType];
    if (snsIdType_name != null) {
      ret.write(snsIdType_name);
      ret.write(" (");
    }
    ret.write(this.snsIdType);
    if (snsIdType_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("snsAccessToken:");
    if (this.snsAccessToken == null) {
      ret.write("null");
    } else {
      ret.write(this.snsAccessToken);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSnsIdType() && !SnsIdType.VALID_VALUES.contains(snsIdType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'snsIdType' has been assigned the invalid value $snsIdType");
    }
  }

}

class addSnsId_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addSnsId_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  addSnsId_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addSnsId_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class blockContact_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("blockContact_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ID_FIELD_DESC = new TField("id", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _id;
  static const int ID = 2;

  bool __isset_reqSeq = false;

  blockContact_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // id
  String get id => this._id;

  set id(String id) {
    this._id = id;
  }

  bool isSetId() => this.id != null;

  unsetId() {
    this.id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ID:
        return this.id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ID:
        return isSetId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.STRING) {
            this.id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.id != null) {
      oprot.writeFieldBegin(_ID_FIELD_DESC);
      oprot.writeString(this.id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blockContact_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("id:");
    if (this.id == null) {
      ret.write("null");
    } else {
      ret.write(this.id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class blockContact_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("blockContact_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  blockContact_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blockContact_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class blockRecommendation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("blockRecommendation_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ID_FIELD_DESC = new TField("id", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _id;
  static const int ID = 2;

  bool __isset_reqSeq = false;

  blockRecommendation_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // id
  String get id => this._id;

  set id(String id) {
    this._id = id;
  }

  bool isSetId() => this.id != null;

  unsetId() {
    this.id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ID:
        return this.id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ID:
        return isSetId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.STRING) {
            this.id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.id != null) {
      oprot.writeFieldBegin(_ID_FIELD_DESC);
      oprot.writeString(this.id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blockRecommendation_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("id:");
    if (this.id == null) {
      ret.write("null");
    } else {
      ret.write(this.id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class blockRecommendation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("blockRecommendation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  blockRecommendation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blockRecommendation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class cancelGroupInvitation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("cancelGroupInvitation_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupId;
  static const int GROUPID = 2;
  List<String> _contactIds;
  static const int CONTACTIDS = 3;

  bool __isset_reqSeq = false;

  cancelGroupInvitation_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPID:
        return this.groupId;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPID:
        return isSetGroupId();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list828 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i829 = 0; _i829 < _list828.length; ++_i829) {
                String _elem830;
                _elem830 = iprot.readString();
                this.contactIds.add(_elem830);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem831 in this.contactIds) {
          oprot.writeString(elem831);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("cancelGroupInvitation_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class cancelGroupInvitation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("cancelGroupInvitation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  cancelGroupInvitation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("cancelGroupInvitation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class changeVerificationMethod_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("changeVerificationMethod_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _METHOD_FIELD_DESC = new TField("method", TType.I32, 3);

  String _sessionId;
  static const int SESSIONID = 2;
  int _method;
  static const int METHOD = 3;

  bool __isset_method = false;

  changeVerificationMethod_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // method
  int get method => this._method;

  set method(int method) {
    this._method = method;
    this.__isset_method = true;
  }

  bool isSetMethod() => this.__isset_method;

  unsetMethod() {
    this.__isset_method = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case METHOD:
        return this.method;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case METHOD:
        if (value == null) {
          unsetMethod();
        } else {
          this.method = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case METHOD:
        return isSetMethod();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case METHOD:
          if (field.type == TType.I32) {
            this.method = iprot.readI32();
            this.__isset_method = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_METHOD_FIELD_DESC);
    oprot.writeI32(this.method);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("changeVerificationMethod_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("method:");
    String method_name = VerificationMethod.VALUES_TO_NAMES[this.method];
    if (method_name != null) {
      ret.write(method_name);
      ret.write(" (");
    }
    ret.write(this.method);
    if (method_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetMethod() && !VerificationMethod.VALID_VALUES.contains(method)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'method' has been assigned the invalid value $method");
    }
  }

}

class changeVerificationMethod_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("changeVerificationMethod_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  VerificationSessionData _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  changeVerificationMethod_result() {
  }

  // success
  VerificationSessionData get success => this._success;

  set success(VerificationSessionData success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new VerificationSessionData();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("changeVerificationMethod_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clearIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clearIdentityCredential_args");



  clearIdentityCredential_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clearIdentityCredential_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clearIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clearIdentityCredential_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  clearIdentityCredential_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clearIdentityCredential_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clearMessageBox_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clearMessageBox_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 3);

  String _channelId;
  static const int CHANNELID = 2;
  String _messageBoxId;
  static const int MESSAGEBOXID = 3;


  clearMessageBox_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case MESSAGEBOXID:
        return this.messageBoxId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clearMessageBox_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clearMessageBox_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clearMessageBox_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  clearMessageBox_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clearMessageBox_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class closeProximityMatch_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("closeProximityMatch_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  closeProximityMatch_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("closeProximityMatch_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class closeProximityMatch_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("closeProximityMatch_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  closeProximityMatch_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("closeProximityMatch_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class commitSendMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("commitSendMessage_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 2);
  static final TField _RECEIVER_MIDS_FIELD_DESC = new TField("receiverMids", TType.LIST, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _messageId;
  static const int MESSAGEID = 2;
  List<String> _receiverMids;
  static const int RECEIVERMIDS = 3;

  bool __isset_seq = false;

  commitSendMessage_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  // receiverMids
  List<String> get receiverMids => this._receiverMids;

  set receiverMids(List<String> receiverMids) {
    this._receiverMids = receiverMids;
  }

  bool isSetReceiverMids() => this.receiverMids != null;

  unsetReceiverMids() {
    this.receiverMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGEID:
        return this.messageId;
      case RECEIVERMIDS:
        return this.receiverMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      case RECEIVERMIDS:
        if (value == null) {
          unsetReceiverMids();
        } else {
          this.receiverMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGEID:
        return isSetMessageId();
      case RECEIVERMIDS:
        return isSetReceiverMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list832 = iprot.readListBegin();
              this.receiverMids = new List<String>();
              for (int _i833 = 0; _i833 < _list832.length; ++_i833) {
                String _elem834;
                _elem834 = iprot.readString();
                this.receiverMids.add(_elem834);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    if (this.receiverMids != null) {
      oprot.writeFieldBegin(_RECEIVER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.receiverMids.length));
        for (var elem835 in this.receiverMids) {
          oprot.writeString(elem835);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("commitSendMessage_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(", ");
    ret.write("receiverMids:");
    if (this.receiverMids == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class commitSendMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("commitSendMessage_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  commitSendMessage_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map836 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i837 = 0; _i837 < _map836.length; ++_i837) {
                String _key838;
                String _val839;
                _key838 = iprot.readString();
                _val839 = iprot.readString();
                this.success[_key838] = _val839;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem841 in this.success.keys) {
          oprot.writeString(elem841);
          oprot.writeString(this.success[elem841]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("commitSendMessage_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class commitSendMessages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("commitSendMessages_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_IDS_FIELD_DESC = new TField("messageIds", TType.LIST, 2);
  static final TField _RECEIVER_MIDS_FIELD_DESC = new TField("receiverMids", TType.LIST, 3);

  int _seq = 0;
  static const int SEQ = 1;
  List<String> _messageIds;
  static const int MESSAGEIDS = 2;
  List<String> _receiverMids;
  static const int RECEIVERMIDS = 3;

  bool __isset_seq = false;

  commitSendMessages_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // messageIds
  List<String> get messageIds => this._messageIds;

  set messageIds(List<String> messageIds) {
    this._messageIds = messageIds;
  }

  bool isSetMessageIds() => this.messageIds != null;

  unsetMessageIds() {
    this.messageIds = null;
  }

  // receiverMids
  List<String> get receiverMids => this._receiverMids;

  set receiverMids(List<String> receiverMids) {
    this._receiverMids = receiverMids;
  }

  bool isSetReceiverMids() => this.receiverMids != null;

  unsetReceiverMids() {
    this.receiverMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGEIDS:
        return this.messageIds;
      case RECEIVERMIDS:
        return this.receiverMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGEIDS:
        if (value == null) {
          unsetMessageIds();
        } else {
          this.messageIds = value;
        }
        break;

      case RECEIVERMIDS:
        if (value == null) {
          unsetReceiverMids();
        } else {
          this.receiverMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGEIDS:
        return isSetMessageIds();
      case RECEIVERMIDS:
        return isSetReceiverMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEIDS:
          if (field.type == TType.LIST) {
            {
              TList _list842 = iprot.readListBegin();
              this.messageIds = new List<String>();
              for (int _i843 = 0; _i843 < _list842.length; ++_i843) {
                String _elem844;
                _elem844 = iprot.readString();
                this.messageIds.add(_elem844);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list845 = iprot.readListBegin();
              this.receiverMids = new List<String>();
              for (int _i846 = 0; _i846 < _list845.length; ++_i846) {
                String _elem847;
                _elem847 = iprot.readString();
                this.receiverMids.add(_elem847);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.messageIds != null) {
      oprot.writeFieldBegin(_MESSAGE_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.messageIds.length));
        for (var elem848 in this.messageIds) {
          oprot.writeString(elem848);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.receiverMids != null) {
      oprot.writeFieldBegin(_RECEIVER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.receiverMids.length));
        for (var elem849 in this.receiverMids) {
          oprot.writeString(elem849);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("commitSendMessages_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("messageIds:");
    if (this.messageIds == null) {
      ret.write("null");
    } else {
      ret.write(this.messageIds);
    }

    ret.write(", ");
    ret.write("receiverMids:");
    if (this.receiverMids == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class commitSendMessages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("commitSendMessages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  commitSendMessages_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map850 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i851 = 0; _i851 < _map850.length; ++_i851) {
                String _key852;
                String _val853;
                _key852 = iprot.readString();
                _val853 = iprot.readString();
                this.success[_key852] = _val853;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem855 in this.success.keys) {
          oprot.writeString(elem855);
          oprot.writeString(this.success[elem855]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("commitSendMessages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class commitUpdateProfile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("commitUpdateProfile_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _ATTRS_FIELD_DESC = new TField("attrs", TType.LIST, 2);
  static final TField _RECEIVER_MIDS_FIELD_DESC = new TField("receiverMids", TType.LIST, 3);

  int _seq = 0;
  static const int SEQ = 1;
  List<int> _attrs;
  static const int ATTRS = 2;
  List<String> _receiverMids;
  static const int RECEIVERMIDS = 3;

  bool __isset_seq = false;

  commitUpdateProfile_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // attrs
  List<int> get attrs => this._attrs;

  set attrs(List<int> attrs) {
    this._attrs = attrs;
  }

  bool isSetAttrs() => this.attrs != null;

  unsetAttrs() {
    this.attrs = null;
  }

  // receiverMids
  List<String> get receiverMids => this._receiverMids;

  set receiverMids(List<String> receiverMids) {
    this._receiverMids = receiverMids;
  }

  bool isSetReceiverMids() => this.receiverMids != null;

  unsetReceiverMids() {
    this.receiverMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case ATTRS:
        return this.attrs;
      case RECEIVERMIDS:
        return this.receiverMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case ATTRS:
        if (value == null) {
          unsetAttrs();
        } else {
          this.attrs = value;
        }
        break;

      case RECEIVERMIDS:
        if (value == null) {
          unsetReceiverMids();
        } else {
          this.receiverMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case ATTRS:
        return isSetAttrs();
      case RECEIVERMIDS:
        return isSetReceiverMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ATTRS:
          if (field.type == TType.LIST) {
            {
              TList _list856 = iprot.readListBegin();
              this.attrs = new List<int>();
              for (int _i857 = 0; _i857 < _list856.length; ++_i857) {
                int _elem858;
                _elem858 = iprot.readI32();
                this.attrs.add(_elem858);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list859 = iprot.readListBegin();
              this.receiverMids = new List<String>();
              for (int _i860 = 0; _i860 < _list859.length; ++_i860) {
                String _elem861;
                _elem861 = iprot.readString();
                this.receiverMids.add(_elem861);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.attrs != null) {
      oprot.writeFieldBegin(_ATTRS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.I32, this.attrs.length));
        for (var elem862 in this.attrs) {
          oprot.writeI32(elem862);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.receiverMids != null) {
      oprot.writeFieldBegin(_RECEIVER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.receiverMids.length));
        for (var elem863 in this.receiverMids) {
          oprot.writeString(elem863);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("commitUpdateProfile_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("attrs:");
    if (this.attrs == null) {
      ret.write("null");
    } else {
      ret.write(this.attrs);
    }

    ret.write(", ");
    ret.write("receiverMids:");
    if (this.receiverMids == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class commitUpdateProfile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("commitUpdateProfile_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  commitUpdateProfile_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map864 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i865 = 0; _i865 < _map864.length; ++_i865) {
                String _key866;
                String _val867;
                _key866 = iprot.readString();
                _val867 = iprot.readString();
                this.success[_key866] = _val867;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem869 in this.success.keys) {
          oprot.writeString(elem869);
          oprot.writeString(this.success[elem869]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("commitUpdateProfile_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class confirmEmail_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("confirmEmail_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 2);
  static final TField _PIN_CODE_FIELD_DESC = new TField("pinCode", TType.STRING, 3);

  String _verifier;
  static const int VERIFIER = 2;
  String _pinCode;
  static const int PINCODE = 3;


  confirmEmail_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  // pinCode
  String get pinCode => this._pinCode;

  set pinCode(String pinCode) {
    this._pinCode = pinCode;
  }

  bool isSetPinCode() => this.pinCode != null;

  unsetPinCode() {
    this.pinCode = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      case PINCODE:
        return this.pinCode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      case PINCODE:
        if (value == null) {
          unsetPinCode();
        } else {
          this.pinCode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      case PINCODE:
        return isSetPinCode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PINCODE:
          if (field.type == TType.STRING) {
            this.pinCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    if (this.pinCode != null) {
      oprot.writeFieldBegin(_PIN_CODE_FIELD_DESC);
      oprot.writeString(this.pinCode);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("confirmEmail_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(", ");
    ret.write("pinCode:");
    if (this.pinCode == null) {
      ret.write("null");
    } else {
      ret.write(this.pinCode);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class confirmEmail_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("confirmEmail_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  confirmEmail_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("confirmEmail_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createGroup_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _NAME_FIELD_DESC = new TField("name", TType.STRING, 2);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _name;
  static const int NAME = 2;
  List<String> _contactIds;
  static const int CONTACTIDS = 3;

  bool __isset_seq = false;

  createGroup_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // name
  String get name => this._name;

  set name(String name) {
    this._name = name;
  }

  bool isSetName() => this.name != null;

  unsetName() {
    this.name = null;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case NAME:
        return this.name;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          this.name = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case NAME:
        return isSetName();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NAME:
          if (field.type == TType.STRING) {
            this.name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list870 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i871 = 0; _i871 < _list870.length; ++_i871) {
                String _elem872;
                _elem872 = iprot.readString();
                this.contactIds.add(_elem872);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.name != null) {
      oprot.writeFieldBegin(_NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem873 in this.contactIds) {
          oprot.writeString(elem873);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createGroup_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("name:");
    if (this.name == null) {
      ret.write("null");
    } else {
      ret.write(this.name);
    }

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createGroup_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Group _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createGroup_result() {
  }

  // success
  Group get success => this._success;

  set success(Group success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Group();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createGroup_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createQrcodeBase64Image_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createQrcodeBase64Image_args");
  static final TField _URL_FIELD_DESC = new TField("url", TType.STRING, 2);
  static final TField _CHARACTER_SET_FIELD_DESC = new TField("characterSet", TType.STRING, 3);
  static final TField _IMAGE_SIZE_FIELD_DESC = new TField("imageSize", TType.I32, 4);
  static final TField _X_FIELD_DESC = new TField("x", TType.I32, 5);
  static final TField _Y_FIELD_DESC = new TField("y", TType.I32, 6);
  static final TField _WIDTH_FIELD_DESC = new TField("width", TType.I32, 7);
  static final TField _HEIGHT_FIELD_DESC = new TField("height", TType.I32, 8);

  String _url;
  static const int URL = 2;
  String _characterSet;
  static const int CHARACTERSET = 3;
  int _imageSize = 0;
  static const int IMAGESIZE = 4;
  int _x = 0;
  static const int X = 5;
  int _y = 0;
  static const int Y = 6;
  int _width = 0;
  static const int WIDTH = 7;
  int _height = 0;
  static const int HEIGHT = 8;

  bool __isset_imageSize = false;
  bool __isset_x = false;
  bool __isset_y = false;
  bool __isset_width = false;
  bool __isset_height = false;

  createQrcodeBase64Image_args() {
  }

  // url
  String get url => this._url;

  set url(String url) {
    this._url = url;
  }

  bool isSetUrl() => this.url != null;

  unsetUrl() {
    this.url = null;
  }

  // characterSet
  String get characterSet => this._characterSet;

  set characterSet(String characterSet) {
    this._characterSet = characterSet;
  }

  bool isSetCharacterSet() => this.characterSet != null;

  unsetCharacterSet() {
    this.characterSet = null;
  }

  // imageSize
  int get imageSize => this._imageSize;

  set imageSize(int imageSize) {
    this._imageSize = imageSize;
    this.__isset_imageSize = true;
  }

  bool isSetImageSize() => this.__isset_imageSize;

  unsetImageSize() {
    this.__isset_imageSize = false;
  }

  // x
  int get x => this._x;

  set x(int x) {
    this._x = x;
    this.__isset_x = true;
  }

  bool isSetX() => this.__isset_x;

  unsetX() {
    this.__isset_x = false;
  }

  // y
  int get y => this._y;

  set y(int y) {
    this._y = y;
    this.__isset_y = true;
  }

  bool isSetY() => this.__isset_y;

  unsetY() {
    this.__isset_y = false;
  }

  // width
  int get width => this._width;

  set width(int width) {
    this._width = width;
    this.__isset_width = true;
  }

  bool isSetWidth() => this.__isset_width;

  unsetWidth() {
    this.__isset_width = false;
  }

  // height
  int get height => this._height;

  set height(int height) {
    this._height = height;
    this.__isset_height = true;
  }

  bool isSetHeight() => this.__isset_height;

  unsetHeight() {
    this.__isset_height = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case URL:
        return this.url;
      case CHARACTERSET:
        return this.characterSet;
      case IMAGESIZE:
        return this.imageSize;
      case X:
        return this.x;
      case Y:
        return this.y;
      case WIDTH:
        return this.width;
      case HEIGHT:
        return this.height;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case URL:
        if (value == null) {
          unsetUrl();
        } else {
          this.url = value;
        }
        break;

      case CHARACTERSET:
        if (value == null) {
          unsetCharacterSet();
        } else {
          this.characterSet = value;
        }
        break;

      case IMAGESIZE:
        if (value == null) {
          unsetImageSize();
        } else {
          this.imageSize = value;
        }
        break;

      case X:
        if (value == null) {
          unsetX();
        } else {
          this.x = value;
        }
        break;

      case Y:
        if (value == null) {
          unsetY();
        } else {
          this.y = value;
        }
        break;

      case WIDTH:
        if (value == null) {
          unsetWidth();
        } else {
          this.width = value;
        }
        break;

      case HEIGHT:
        if (value == null) {
          unsetHeight();
        } else {
          this.height = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case URL:
        return isSetUrl();
      case CHARACTERSET:
        return isSetCharacterSet();
      case IMAGESIZE:
        return isSetImageSize();
      case X:
        return isSetX();
      case Y:
        return isSetY();
      case WIDTH:
        return isSetWidth();
      case HEIGHT:
        return isSetHeight();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case URL:
          if (field.type == TType.STRING) {
            this.url = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CHARACTERSET:
          if (field.type == TType.STRING) {
            this.characterSet = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IMAGESIZE:
          if (field.type == TType.I32) {
            this.imageSize = iprot.readI32();
            this.__isset_imageSize = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case X:
          if (field.type == TType.I32) {
            this.x = iprot.readI32();
            this.__isset_x = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case Y:
          if (field.type == TType.I32) {
            this.y = iprot.readI32();
            this.__isset_y = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WIDTH:
          if (field.type == TType.I32) {
            this.width = iprot.readI32();
            this.__isset_width = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case HEIGHT:
          if (field.type == TType.I32) {
            this.height = iprot.readI32();
            this.__isset_height = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.url != null) {
      oprot.writeFieldBegin(_URL_FIELD_DESC);
      oprot.writeString(this.url);
      oprot.writeFieldEnd();
    }
    if (this.characterSet != null) {
      oprot.writeFieldBegin(_CHARACTER_SET_FIELD_DESC);
      oprot.writeString(this.characterSet);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_IMAGE_SIZE_FIELD_DESC);
    oprot.writeI32(this.imageSize);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_X_FIELD_DESC);
    oprot.writeI32(this.x);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_Y_FIELD_DESC);
    oprot.writeI32(this.y);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_WIDTH_FIELD_DESC);
    oprot.writeI32(this.width);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_HEIGHT_FIELD_DESC);
    oprot.writeI32(this.height);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createQrcodeBase64Image_args(");

    ret.write("url:");
    if (this.url == null) {
      ret.write("null");
    } else {
      ret.write(this.url);
    }

    ret.write(", ");
    ret.write("characterSet:");
    if (this.characterSet == null) {
      ret.write("null");
    } else {
      ret.write(this.characterSet);
    }

    ret.write(", ");
    ret.write("imageSize:");
    ret.write(this.imageSize);

    ret.write(", ");
    ret.write("x:");
    ret.write(this.x);

    ret.write(", ");
    ret.write("y:");
    ret.write(this.y);

    ret.write(", ");
    ret.write("width:");
    ret.write(this.width);

    ret.write(", ");
    ret.write("height:");
    ret.write(this.height);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createQrcodeBase64Image_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createQrcodeBase64Image_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createQrcodeBase64Image_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createQrcodeBase64Image_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createRoom_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createRoom_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  List<String> _contactIds;
  static const int CONTACTIDS = 2;

  bool __isset_reqSeq = false;

  createRoom_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list874 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i875 = 0; _i875 < _list874.length; ++_i875) {
                String _elem876;
                _elem876 = iprot.readString();
                this.contactIds.add(_elem876);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem877 in this.contactIds) {
          oprot.writeString(elem877);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createRoom_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createRoom_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createRoom_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Room _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createRoom_result() {
  }

  // success
  Room get success => this._success;

  set success(Room success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Room();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createRoom_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createSession_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSession_args");



  createSession_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSession_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createSession_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSession_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createSession_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSession_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchAnnouncements_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchAnnouncements_args");
  static final TField _LAST_FETCHED_INDEX_FIELD_DESC = new TField("lastFetchedIndex", TType.I32, 2);

  int _lastFetchedIndex = 0;
  static const int LASTFETCHEDINDEX = 2;

  bool __isset_lastFetchedIndex = false;

  fetchAnnouncements_args() {
  }

  // lastFetchedIndex
  int get lastFetchedIndex => this._lastFetchedIndex;

  set lastFetchedIndex(int lastFetchedIndex) {
    this._lastFetchedIndex = lastFetchedIndex;
    this.__isset_lastFetchedIndex = true;
  }

  bool isSetLastFetchedIndex() => this.__isset_lastFetchedIndex;

  unsetLastFetchedIndex() {
    this.__isset_lastFetchedIndex = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTFETCHEDINDEX:
        return this.lastFetchedIndex;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTFETCHEDINDEX:
        if (value == null) {
          unsetLastFetchedIndex();
        } else {
          this.lastFetchedIndex = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTFETCHEDINDEX:
        return isSetLastFetchedIndex();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTFETCHEDINDEX:
          if (field.type == TType.I32) {
            this.lastFetchedIndex = iprot.readI32();
            this.__isset_lastFetchedIndex = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_FETCHED_INDEX_FIELD_DESC);
    oprot.writeI32(this.lastFetchedIndex);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchAnnouncements_args(");

    ret.write("lastFetchedIndex:");
    ret.write(this.lastFetchedIndex);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchAnnouncements_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchAnnouncements_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Announcement> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  fetchAnnouncements_result() {
  }

  // success
  List<Announcement> get success => this._success;

  set success(List<Announcement> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list878 = iprot.readListBegin();
              this.success = new List<Announcement>();
              for (int _i879 = 0; _i879 < _list878.length; ++_i879) {
                Announcement _elem880;
                _elem880 = new Announcement();
                _elem880.read(iprot);
                this.success.add(_elem880);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem881 in this.success) {
          elem881.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchAnnouncements_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchMessages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchMessages_args");
  static final TField _LOCAL_TS_FIELD_DESC = new TField("localTs", TType.I64, 2);
  static final TField _COUNT_FIELD_DESC = new TField("count", TType.I32, 3);

  int _localTs = 0;
  static const int LOCALTS = 2;
  int _count = 0;
  static const int COUNT = 3;

  bool __isset_localTs = false;
  bool __isset_count = false;

  fetchMessages_args() {
  }

  // localTs
  int get localTs => this._localTs;

  set localTs(int localTs) {
    this._localTs = localTs;
    this.__isset_localTs = true;
  }

  bool isSetLocalTs() => this.__isset_localTs;

  unsetLocalTs() {
    this.__isset_localTs = false;
  }

  // count
  int get count => this._count;

  set count(int count) {
    this._count = count;
    this.__isset_count = true;
  }

  bool isSetCount() => this.__isset_count;

  unsetCount() {
    this.__isset_count = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCALTS:
        return this.localTs;
      case COUNT:
        return this.count;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCALTS:
        if (value == null) {
          unsetLocalTs();
        } else {
          this.localTs = value;
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          this.count = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCALTS:
        return isSetLocalTs();
      case COUNT:
        return isSetCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCALTS:
          if (field.type == TType.I64) {
            this.localTs = iprot.readI64();
            this.__isset_localTs = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LOCAL_TS_FIELD_DESC);
    oprot.writeI64(this.localTs);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchMessages_args(");

    ret.write("localTs:");
    ret.write(this.localTs);

    ret.write(", ");
    ret.write("count:");
    ret.write(this.count);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchMessages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchMessages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  fetchMessages_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list882 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i883 = 0; _i883 < _list882.length; ++_i883) {
                Message _elem884;
                _elem884 = new Message();
                _elem884.read(iprot);
                this.success.add(_elem884);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem885 in this.success) {
          elem885.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchMessages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchOperations_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchOperations_args");
  static final TField _LOCAL_REV_FIELD_DESC = new TField("localRev", TType.I64, 2);
  static final TField _COUNT_FIELD_DESC = new TField("count", TType.I32, 3);

  int _localRev = 0;
  static const int LOCALREV = 2;
  int _count = 0;
  static const int COUNT = 3;

  bool __isset_localRev = false;
  bool __isset_count = false;

  fetchOperations_args() {
  }

  // localRev
  int get localRev => this._localRev;

  set localRev(int localRev) {
    this._localRev = localRev;
    this.__isset_localRev = true;
  }

  bool isSetLocalRev() => this.__isset_localRev;

  unsetLocalRev() {
    this.__isset_localRev = false;
  }

  // count
  int get count => this._count;

  set count(int count) {
    this._count = count;
    this.__isset_count = true;
  }

  bool isSetCount() => this.__isset_count;

  unsetCount() {
    this.__isset_count = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return this.localRev;
      case COUNT:
        return this.count;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCALREV:
        if (value == null) {
          unsetLocalRev();
        } else {
          this.localRev = value;
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          this.count = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return isSetLocalRev();
      case COUNT:
        return isSetCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCALREV:
          if (field.type == TType.I64) {
            this.localRev = iprot.readI64();
            this.__isset_localRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LOCAL_REV_FIELD_DESC);
    oprot.writeI64(this.localRev);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchOperations_args(");

    ret.write("localRev:");
    ret.write(this.localRev);

    ret.write(", ");
    ret.write("count:");
    ret.write(this.count);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchOperations_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchOperations_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Operation> _success;
  static const int SUCCESS = 0;
  ShouldSyncException _e;
  static const int E = 1;


  fetchOperations_result() {
  }

  // success
  List<Operation> get success => this._success;

  set success(List<Operation> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ShouldSyncException get e => this._e;

  set e(ShouldSyncException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list886 = iprot.readListBegin();
              this.success = new List<Operation>();
              for (int _i887 = 0; _i887 < _list886.length; ++_i887) {
                Operation _elem888;
                _elem888 = new Operation();
                _elem888.read(iprot);
                this.success.add(_elem888);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ShouldSyncException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem889 in this.success) {
          elem889.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchOperations_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchOps_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchOps_args");
  static final TField _LOCAL_REV_FIELD_DESC = new TField("localRev", TType.I64, 2);
  static final TField _COUNT_FIELD_DESC = new TField("count", TType.I32, 3);
  static final TField _GLOBAL_REV_FIELD_DESC = new TField("globalRev", TType.I64, 4);
  static final TField _INDIVIDUAL_REV_FIELD_DESC = new TField("individualRev", TType.I64, 5);

  int _localRev = 0;
  static const int LOCALREV = 2;
  int _count = 0;
  static const int COUNT = 3;
  int _globalRev = 0;
  static const int GLOBALREV = 4;
  int _individualRev = 0;
  static const int INDIVIDUALREV = 5;

  bool __isset_localRev = false;
  bool __isset_count = false;
  bool __isset_globalRev = false;
  bool __isset_individualRev = false;

  fetchOps_args() {
  }

  // localRev
  int get localRev => this._localRev;

  set localRev(int localRev) {
    this._localRev = localRev;
    this.__isset_localRev = true;
  }

  bool isSetLocalRev() => this.__isset_localRev;

  unsetLocalRev() {
    this.__isset_localRev = false;
  }

  // count
  int get count => this._count;

  set count(int count) {
    this._count = count;
    this.__isset_count = true;
  }

  bool isSetCount() => this.__isset_count;

  unsetCount() {
    this.__isset_count = false;
  }

  // globalRev
  int get globalRev => this._globalRev;

  set globalRev(int globalRev) {
    this._globalRev = globalRev;
    this.__isset_globalRev = true;
  }

  bool isSetGlobalRev() => this.__isset_globalRev;

  unsetGlobalRev() {
    this.__isset_globalRev = false;
  }

  // individualRev
  int get individualRev => this._individualRev;

  set individualRev(int individualRev) {
    this._individualRev = individualRev;
    this.__isset_individualRev = true;
  }

  bool isSetIndividualRev() => this.__isset_individualRev;

  unsetIndividualRev() {
    this.__isset_individualRev = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return this.localRev;
      case COUNT:
        return this.count;
      case GLOBALREV:
        return this.globalRev;
      case INDIVIDUALREV:
        return this.individualRev;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCALREV:
        if (value == null) {
          unsetLocalRev();
        } else {
          this.localRev = value;
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          this.count = value;
        }
        break;

      case GLOBALREV:
        if (value == null) {
          unsetGlobalRev();
        } else {
          this.globalRev = value;
        }
        break;

      case INDIVIDUALREV:
        if (value == null) {
          unsetIndividualRev();
        } else {
          this.individualRev = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return isSetLocalRev();
      case COUNT:
        return isSetCount();
      case GLOBALREV:
        return isSetGlobalRev();
      case INDIVIDUALREV:
        return isSetIndividualRev();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCALREV:
          if (field.type == TType.I64) {
            this.localRev = iprot.readI64();
            this.__isset_localRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GLOBALREV:
          if (field.type == TType.I64) {
            this.globalRev = iprot.readI64();
            this.__isset_globalRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INDIVIDUALREV:
          if (field.type == TType.I64) {
            this.individualRev = iprot.readI64();
            this.__isset_individualRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LOCAL_REV_FIELD_DESC);
    oprot.writeI64(this.localRev);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_GLOBAL_REV_FIELD_DESC);
    oprot.writeI64(this.globalRev);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_INDIVIDUAL_REV_FIELD_DESC);
    oprot.writeI64(this.individualRev);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchOps_args(");

    ret.write("localRev:");
    ret.write(this.localRev);

    ret.write(", ");
    ret.write("count:");
    ret.write(this.count);

    ret.write(", ");
    ret.write("globalRev:");
    ret.write(this.globalRev);

    ret.write(", ");
    ret.write("individualRev:");
    ret.write(this.individualRev);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchOps_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchOps_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Operation> _success;
  static const int SUCCESS = 0;
  ShouldSyncException _e;
  static const int E = 1;


  fetchOps_result() {
  }

  // success
  List<Operation> get success => this._success;

  set success(List<Operation> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ShouldSyncException get e => this._e;

  set e(ShouldSyncException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list890 = iprot.readListBegin();
              this.success = new List<Operation>();
              for (int _i891 = 0; _i891 < _list890.length; ++_i891) {
                Operation _elem892;
                _elem892 = new Operation();
                _elem892.read(iprot);
                this.success.add(_elem892);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ShouldSyncException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem893 in this.success) {
          elem893.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchOps_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByEmail_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByEmail_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _EMAILS_FIELD_DESC = new TField("emails", TType.SET, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Set<String> _emails;
  static const int EMAILS = 2;

  bool __isset_reqSeq = false;

  findAndAddContactsByEmail_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // emails
  Set<String> get emails => this._emails;

  set emails(Set<String> emails) {
    this._emails = emails;
  }

  bool isSetEmails() => this.emails != null;

  unsetEmails() {
    this.emails = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case EMAILS:
        return this.emails;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case EMAILS:
        if (value == null) {
          unsetEmails();
        } else {
          this.emails = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case EMAILS:
        return isSetEmails();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EMAILS:
          if (field.type == TType.SET) {
            {
              TSet _set894 = iprot.readSetBegin();
              this.emails = new Set<String>();
              for (int _i895 = 0; _i895 < _set894.length; ++_i895) {
                String _elem896;
                _elem896 = iprot.readString();
                this.emails.add(_elem896);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.emails != null) {
      oprot.writeFieldBegin(_EMAILS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRING, this.emails.length));
        for (var elem897 in this.emails) {
          oprot.writeString(elem897);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByEmail_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("emails:");
    if (this.emails == null) {
      ret.write("null");
    } else {
      ret.write(this.emails);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByEmail_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByEmail_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findAndAddContactsByEmail_result() {
  }

  // success
  Map<String, Contact> get success => this._success;

  set success(Map<String, Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map898 = iprot.readMapBegin();
              this.success = new Map<String, Contact>();
              for (int _i899 = 0; _i899 < _map898.length; ++_i899) {
                String _key900;
                Contact _val901;
                _key900 = iprot.readString();
                _val901 = new Contact();
                _val901.read(iprot);
                this.success[_key900] = _val901;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem903 in this.success.keys) {
          oprot.writeString(elem903);
          this.success[elem903].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByEmail_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByMid_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByMid_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);
  static final TField _TYPE_FIELD_DESC = new TField("type", TType.I32, 3);
  static final TField _REFERENCE_FIELD_DESC = new TField("reference", TType.STRING, 4);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _mid;
  static const int MID = 2;
  int _type;
  static const int TYPE = 3;
  String _reference;
  static const int REFERENCE = 4;

  bool __isset_reqSeq = false;
  bool __isset_type = false;

  findAndAddContactsByMid_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // type
  int get type => this._type;

  set type(int type) {
    this._type = type;
    this.__isset_type = true;
  }

  bool isSetType() => this.__isset_type;

  unsetType() {
    this.__isset_type = false;
  }

  // reference
  String get reference => this._reference;

  set reference(String reference) {
    this._reference = reference;
  }

  bool isSetReference() => this.reference != null;

  unsetReference() {
    this.reference = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case MID:
        return this.mid;
      case TYPE:
        return this.type;
      case REFERENCE:
        return this.reference;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          this.type = value;
        }
        break;

      case REFERENCE:
        if (value == null) {
          unsetReference();
        } else {
          this.reference = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case MID:
        return isSetMid();
      case TYPE:
        return isSetType();
      case REFERENCE:
        return isSetReference();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TYPE:
          if (field.type == TType.I32) {
            this.type = iprot.readI32();
            this.__isset_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REFERENCE:
          if (field.type == TType.STRING) {
            this.reference = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_TYPE_FIELD_DESC);
    oprot.writeI32(this.type);
    oprot.writeFieldEnd();
    if (this.reference != null) {
      oprot.writeFieldBegin(_REFERENCE_FIELD_DESC);
      oprot.writeString(this.reference);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByMid_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("type:");
    String type_name = ContactType.VALUES_TO_NAMES[this.type];
    if (type_name != null) {
      ret.write(type_name);
      ret.write(" (");
    }
    ret.write(this.type);
    if (type_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("reference:");
    if (this.reference == null) {
      ret.write("null");
    } else {
      ret.write(this.reference);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetType() && !ContactType.VALID_VALUES.contains(type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'type' has been assigned the invalid value $type");
    }
  }

}

class findAndAddContactsByMid_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByMid_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findAndAddContactsByMid_result() {
  }

  // success
  Map<String, Contact> get success => this._success;

  set success(Map<String, Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map904 = iprot.readMapBegin();
              this.success = new Map<String, Contact>();
              for (int _i905 = 0; _i905 < _map904.length; ++_i905) {
                String _key906;
                Contact _val907;
                _key906 = iprot.readString();
                _val907 = new Contact();
                _val907.read(iprot);
                this.success[_key906] = _val907;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem909 in this.success.keys) {
          oprot.writeString(elem909);
          this.success[elem909].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByMid_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findGroupByTicketV2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findGroupByTicketV2_args");
  static final TField _TICKET_ID_FIELD_DESC = new TField("ticketId", TType.STRING, 1);

  String _ticketId;
  static const int TICKETID = 1;


  findGroupByTicketV2_args() {
  }

  // ticketId
  String get ticketId => this._ticketId;

  set ticketId(String ticketId) {
    this._ticketId = ticketId;
  }

  bool isSetTicketId() => this.ticketId != null;

  unsetTicketId() {
    this.ticketId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TICKETID:
        return this.ticketId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TICKETID:
        if (value == null) {
          unsetTicketId();
        } else {
          this.ticketId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TICKETID:
        return isSetTicketId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TICKETID:
          if (field.type == TType.STRING) {
            this.ticketId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ticketId != null) {
      oprot.writeFieldBegin(_TICKET_ID_FIELD_DESC);
      oprot.writeString(this.ticketId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findGroupByTicketV2_args(");

    ret.write("ticketId:");
    if (this.ticketId == null) {
      ret.write("null");
    } else {
      ret.write(this.ticketId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findGroupByTicketV2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findGroupByTicketV2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Group _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findGroupByTicketV2_result() {
  }

  // success
  Group get success => this._success;

  set success(Group success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Group();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findGroupByTicketV2_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByPhone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByPhone_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _PHONES_FIELD_DESC = new TField("phones", TType.SET, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Set<String> _phones;
  static const int PHONES = 2;

  bool __isset_reqSeq = false;

  findAndAddContactsByPhone_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // phones
  Set<String> get phones => this._phones;

  set phones(Set<String> phones) {
    this._phones = phones;
  }

  bool isSetPhones() => this.phones != null;

  unsetPhones() {
    this.phones = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case PHONES:
        return this.phones;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case PHONES:
        if (value == null) {
          unsetPhones();
        } else {
          this.phones = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case PHONES:
        return isSetPhones();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PHONES:
          if (field.type == TType.SET) {
            {
              TSet _set910 = iprot.readSetBegin();
              this.phones = new Set<String>();
              for (int _i911 = 0; _i911 < _set910.length; ++_i911) {
                String _elem912;
                _elem912 = iprot.readString();
                this.phones.add(_elem912);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.phones != null) {
      oprot.writeFieldBegin(_PHONES_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRING, this.phones.length));
        for (var elem913 in this.phones) {
          oprot.writeString(elem913);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByPhone_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("phones:");
    if (this.phones == null) {
      ret.write("null");
    } else {
      ret.write(this.phones);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByPhone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByPhone_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findAndAddContactsByPhone_result() {
  }

  // success
  Map<String, Contact> get success => this._success;

  set success(Map<String, Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map914 = iprot.readMapBegin();
              this.success = new Map<String, Contact>();
              for (int _i915 = 0; _i915 < _map914.length; ++_i915) {
                String _key916;
                Contact _val917;
                _key916 = iprot.readString();
                _val917 = new Contact();
                _val917.read(iprot);
                this.success[_key916] = _val917;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem919 in this.success.keys) {
          oprot.writeString(elem919);
          this.success[elem919].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByPhone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFriendRequests_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFriendRequests_args");
  static final TField _DIRECTION_FIELD_DESC = new TField("direction", TType.I32, 1);
  static final TField _LAST_SEEN_SEQ_ID_FIELD_DESC = new TField("lastSeenSeqId", TType.I64, 2);

  int _direction;
  static const int DIRECTION = 1;
  int _lastSeenSeqId = 0;
  static const int LASTSEENSEQID = 2;

  bool __isset_direction = false;
  bool __isset_lastSeenSeqId = false;

  getFriendRequests_args() {
  }

  // direction
  int get direction => this._direction;

  set direction(int direction) {
    this._direction = direction;
    this.__isset_direction = true;
  }

  bool isSetDirection() => this.__isset_direction;

  unsetDirection() {
    this.__isset_direction = false;
  }

  // lastSeenSeqId
  int get lastSeenSeqId => this._lastSeenSeqId;

  set lastSeenSeqId(int lastSeenSeqId) {
    this._lastSeenSeqId = lastSeenSeqId;
    this.__isset_lastSeenSeqId = true;
  }

  bool isSetLastSeenSeqId() => this.__isset_lastSeenSeqId;

  unsetLastSeenSeqId() {
    this.__isset_lastSeenSeqId = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case DIRECTION:
        return this.direction;
      case LASTSEENSEQID:
        return this.lastSeenSeqId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case DIRECTION:
        if (value == null) {
          unsetDirection();
        } else {
          this.direction = value;
        }
        break;

      case LASTSEENSEQID:
        if (value == null) {
          unsetLastSeenSeqId();
        } else {
          this.lastSeenSeqId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case DIRECTION:
        return isSetDirection();
      case LASTSEENSEQID:
        return isSetLastSeenSeqId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DIRECTION:
          if (field.type == TType.I32) {
            this.direction = iprot.readI32();
            this.__isset_direction = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTSEENSEQID:
          if (field.type == TType.I64) {
            this.lastSeenSeqId = iprot.readI64();
            this.__isset_lastSeenSeqId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_DIRECTION_FIELD_DESC);
    oprot.writeI32(this.direction);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LAST_SEEN_SEQ_ID_FIELD_DESC);
    oprot.writeI64(this.lastSeenSeqId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFriendRequests_args(");

    ret.write("direction:");
    String direction_name = FriendRequestDirection.VALUES_TO_NAMES[this.direction];
    if (direction_name != null) {
      ret.write(direction_name);
      ret.write(" (");
    }
    ret.write(this.direction);
    if (direction_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("lastSeenSeqId:");
    ret.write(this.lastSeenSeqId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetDirection() && !FriendRequestDirection.VALID_VALUES.contains(direction)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'direction' has been assigned the invalid value $direction");
    }
  }

}

class getFriendRequests_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFriendRequests_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<FriendRequest> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getFriendRequests_result() {
  }

  // success
  List<FriendRequest> get success => this._success;

  set success(List<FriendRequest> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list920 = iprot.readListBegin();
              this.success = new List<FriendRequest>();
              for (int _i921 = 0; _i921 < _list920.length; ++_i921) {
                FriendRequest _elem922;
                _elem922 = new FriendRequest();
                _elem922.read(iprot);
                this.success.add(_elem922);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem923 in this.success) {
          elem923.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFriendRequests_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeFriendRequest_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeFriendRequest_args");
  static final TField _DIRECTION_FIELD_DESC = new TField("direction", TType.I32, 1);
  static final TField _MID_OR_EMID_FIELD_DESC = new TField("midOrEMid", TType.STRING, 2);

  int _direction;
  static const int DIRECTION = 1;
  String _midOrEMid;
  static const int MIDOREMID = 2;

  bool __isset_direction = false;

  removeFriendRequest_args() {
  }

  // direction
  int get direction => this._direction;

  set direction(int direction) {
    this._direction = direction;
    this.__isset_direction = true;
  }

  bool isSetDirection() => this.__isset_direction;

  unsetDirection() {
    this.__isset_direction = false;
  }

  // midOrEMid
  String get midOrEMid => this._midOrEMid;

  set midOrEMid(String midOrEMid) {
    this._midOrEMid = midOrEMid;
  }

  bool isSetMidOrEMid() => this.midOrEMid != null;

  unsetMidOrEMid() {
    this.midOrEMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case DIRECTION:
        return this.direction;
      case MIDOREMID:
        return this.midOrEMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case DIRECTION:
        if (value == null) {
          unsetDirection();
        } else {
          this.direction = value;
        }
        break;

      case MIDOREMID:
        if (value == null) {
          unsetMidOrEMid();
        } else {
          this.midOrEMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case DIRECTION:
        return isSetDirection();
      case MIDOREMID:
        return isSetMidOrEMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DIRECTION:
          if (field.type == TType.I32) {
            this.direction = iprot.readI32();
            this.__isset_direction = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MIDOREMID:
          if (field.type == TType.STRING) {
            this.midOrEMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_DIRECTION_FIELD_DESC);
    oprot.writeI32(this.direction);
    oprot.writeFieldEnd();
    if (this.midOrEMid != null) {
      oprot.writeFieldBegin(_MID_OR_EMID_FIELD_DESC);
      oprot.writeString(this.midOrEMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeFriendRequest_args(");

    ret.write("direction:");
    String direction_name = FriendRequestDirection.VALUES_TO_NAMES[this.direction];
    if (direction_name != null) {
      ret.write(direction_name);
      ret.write(" (");
    }
    ret.write(this.direction);
    if (direction_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("midOrEMid:");
    if (this.midOrEMid == null) {
      ret.write("null");
    } else {
      ret.write(this.midOrEMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetDirection() && !FriendRequestDirection.VALID_VALUES.contains(direction)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'direction' has been assigned the invalid value $direction");
    }
  }

}

class removeFriendRequest_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeFriendRequest_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  removeFriendRequest_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeFriendRequest_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByUserid_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByUserid_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _userid;
  static const int USERID = 2;

  bool __isset_reqSeq = false;

  findAndAddContactsByUserid_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case USERID:
        return this.userid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case USERID:
        return isSetUserid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByUserid_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactsByUserid_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactsByUserid_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findAndAddContactsByUserid_result() {
  }

  // success
  Map<String, Contact> get success => this._success;

  set success(Map<String, Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map924 = iprot.readMapBegin();
              this.success = new Map<String, Contact>();
              for (int _i925 = 0; _i925 < _map924.length; ++_i925) {
                String _key926;
                Contact _val927;
                _key926 = iprot.readString();
                _val927 = new Contact();
                _val927.read(iprot);
                this.success[_key926] = _val927;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem929 in this.success.keys) {
          oprot.writeString(elem929);
          this.success[elem929].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactsByUserid_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByUserid_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByUserid_args");
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);

  String _userid;
  static const int USERID = 2;


  findContactByUserid_args() {
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERID:
        return this.userid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERID:
        return isSetUserid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByUserid_args(");

    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByUserid_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByUserid_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findContactByUserid_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByUserid_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByUserTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByUserTicket_args");
  static final TField _TICKET_ID_WITH_TAG_FIELD_DESC = new TField("ticketIdWithTag", TType.STRING, 2);

  String _ticketIdWithTag;
  static const int TICKETIDWITHTAG = 2;


  findContactByUserTicket_args() {
  }

  // ticketIdWithTag
  String get ticketIdWithTag => this._ticketIdWithTag;

  set ticketIdWithTag(String ticketIdWithTag) {
    this._ticketIdWithTag = ticketIdWithTag;
  }

  bool isSetTicketIdWithTag() => this.ticketIdWithTag != null;

  unsetTicketIdWithTag() {
    this.ticketIdWithTag = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TICKETIDWITHTAG:
        return this.ticketIdWithTag;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TICKETIDWITHTAG:
        if (value == null) {
          unsetTicketIdWithTag();
        } else {
          this.ticketIdWithTag = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TICKETIDWITHTAG:
        return isSetTicketIdWithTag();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TICKETIDWITHTAG:
          if (field.type == TType.STRING) {
            this.ticketIdWithTag = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ticketIdWithTag != null) {
      oprot.writeFieldBegin(_TICKET_ID_WITH_TAG_FIELD_DESC);
      oprot.writeString(this.ticketIdWithTag);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByUserTicket_args(");

    ret.write("ticketIdWithTag:");
    if (this.ticketIdWithTag == null) {
      ret.write("null");
    } else {
      ret.write(this.ticketIdWithTag);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByUserTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByUserTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findContactByUserTicket_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByUserTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactsByEmail_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactsByEmail_args");
  static final TField _EMAILS_FIELD_DESC = new TField("emails", TType.SET, 2);

  Set<String> _emails;
  static const int EMAILS = 2;


  findContactsByEmail_args() {
  }

  // emails
  Set<String> get emails => this._emails;

  set emails(Set<String> emails) {
    this._emails = emails;
  }

  bool isSetEmails() => this.emails != null;

  unsetEmails() {
    this.emails = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case EMAILS:
        return this.emails;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case EMAILS:
        if (value == null) {
          unsetEmails();
        } else {
          this.emails = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case EMAILS:
        return isSetEmails();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case EMAILS:
          if (field.type == TType.SET) {
            {
              TSet _set930 = iprot.readSetBegin();
              this.emails = new Set<String>();
              for (int _i931 = 0; _i931 < _set930.length; ++_i931) {
                String _elem932;
                _elem932 = iprot.readString();
                this.emails.add(_elem932);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.emails != null) {
      oprot.writeFieldBegin(_EMAILS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRING, this.emails.length));
        for (var elem933 in this.emails) {
          oprot.writeString(elem933);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactsByEmail_args(");

    ret.write("emails:");
    if (this.emails == null) {
      ret.write("null");
    } else {
      ret.write(this.emails);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactsByEmail_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactsByEmail_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findContactsByEmail_result() {
  }

  // success
  Map<String, Contact> get success => this._success;

  set success(Map<String, Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map934 = iprot.readMapBegin();
              this.success = new Map<String, Contact>();
              for (int _i935 = 0; _i935 < _map934.length; ++_i935) {
                String _key936;
                Contact _val937;
                _key936 = iprot.readString();
                _val937 = new Contact();
                _val937.read(iprot);
                this.success[_key936] = _val937;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem939 in this.success.keys) {
          oprot.writeString(elem939);
          this.success[elem939].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactsByEmail_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactsByPhone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactsByPhone_args");
  static final TField _PHONES_FIELD_DESC = new TField("phones", TType.SET, 2);

  Set<String> _phones;
  static const int PHONES = 2;


  findContactsByPhone_args() {
  }

  // phones
  Set<String> get phones => this._phones;

  set phones(Set<String> phones) {
    this._phones = phones;
  }

  bool isSetPhones() => this.phones != null;

  unsetPhones() {
    this.phones = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PHONES:
        return this.phones;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PHONES:
        if (value == null) {
          unsetPhones();
        } else {
          this.phones = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PHONES:
        return isSetPhones();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PHONES:
          if (field.type == TType.SET) {
            {
              TSet _set940 = iprot.readSetBegin();
              this.phones = new Set<String>();
              for (int _i941 = 0; _i941 < _set940.length; ++_i941) {
                String _elem942;
                _elem942 = iprot.readString();
                this.phones.add(_elem942);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.phones != null) {
      oprot.writeFieldBegin(_PHONES_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRING, this.phones.length));
        for (var elem943 in this.phones) {
          oprot.writeString(elem943);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactsByPhone_args(");

    ret.write("phones:");
    if (this.phones == null) {
      ret.write("null");
    } else {
      ret.write(this.phones);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactsByPhone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactsByPhone_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findContactsByPhone_result() {
  }

  // success
  Map<String, Contact> get success => this._success;

  set success(Map<String, Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map944 = iprot.readMapBegin();
              this.success = new Map<String, Contact>();
              for (int _i945 = 0; _i945 < _map944.length; ++_i945) {
                String _key946;
                Contact _val947;
                _key946 = iprot.readString();
                _val947 = new Contact();
                _val947.read(iprot);
                this.success[_key946] = _val947;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem949 in this.success.keys) {
          oprot.writeString(elem949);
          this.success[elem949].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactsByPhone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findSnsIdUserStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findSnsIdUserStatus_args");
  static final TField _SNS_ID_TYPE_FIELD_DESC = new TField("snsIdType", TType.I32, 2);
  static final TField _SNS_ACCESS_TOKEN_FIELD_DESC = new TField("snsAccessToken", TType.STRING, 3);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 4);

  int _snsIdType;
  static const int SNSIDTYPE = 2;
  String _snsAccessToken;
  static const int SNSACCESSTOKEN = 3;
  String _udidHash;
  static const int UDIDHASH = 4;

  bool __isset_snsIdType = false;

  findSnsIdUserStatus_args() {
  }

  // snsIdType
  int get snsIdType => this._snsIdType;

  set snsIdType(int snsIdType) {
    this._snsIdType = snsIdType;
    this.__isset_snsIdType = true;
  }

  bool isSetSnsIdType() => this.__isset_snsIdType;

  unsetSnsIdType() {
    this.__isset_snsIdType = false;
  }

  // snsAccessToken
  String get snsAccessToken => this._snsAccessToken;

  set snsAccessToken(String snsAccessToken) {
    this._snsAccessToken = snsAccessToken;
  }

  bool isSetSnsAccessToken() => this.snsAccessToken != null;

  unsetSnsAccessToken() {
    this.snsAccessToken = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return this.snsIdType;
      case SNSACCESSTOKEN:
        return this.snsAccessToken;
      case UDIDHASH:
        return this.udidHash;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SNSIDTYPE:
        if (value == null) {
          unsetSnsIdType();
        } else {
          this.snsIdType = value;
        }
        break;

      case SNSACCESSTOKEN:
        if (value == null) {
          unsetSnsAccessToken();
        } else {
          this.snsAccessToken = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return isSetSnsIdType();
      case SNSACCESSTOKEN:
        return isSetSnsAccessToken();
      case UDIDHASH:
        return isSetUdidHash();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SNSIDTYPE:
          if (field.type == TType.I32) {
            this.snsIdType = iprot.readI32();
            this.__isset_snsIdType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SNSACCESSTOKEN:
          if (field.type == TType.STRING) {
            this.snsAccessToken = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SNS_ID_TYPE_FIELD_DESC);
    oprot.writeI32(this.snsIdType);
    oprot.writeFieldEnd();
    if (this.snsAccessToken != null) {
      oprot.writeFieldBegin(_SNS_ACCESS_TOKEN_FIELD_DESC);
      oprot.writeString(this.snsAccessToken);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findSnsIdUserStatus_args(");

    ret.write("snsIdType:");
    String snsIdType_name = SnsIdType.VALUES_TO_NAMES[this.snsIdType];
    if (snsIdType_name != null) {
      ret.write(snsIdType_name);
      ret.write(" (");
    }
    ret.write(this.snsIdType);
    if (snsIdType_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("snsAccessToken:");
    if (this.snsAccessToken == null) {
      ret.write("null");
    } else {
      ret.write(this.snsAccessToken);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSnsIdType() && !SnsIdType.VALID_VALUES.contains(snsIdType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'snsIdType' has been assigned the invalid value $snsIdType");
    }
  }

}

class findSnsIdUserStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findSnsIdUserStatus_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  SnsIdUserStatus _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findSnsIdUserStatus_result() {
  }

  // success
  SnsIdUserStatus get success => this._success;

  set success(SnsIdUserStatus success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SnsIdUserStatus();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findSnsIdUserStatus_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class finishUpdateVerification_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("finishUpdateVerification_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  finishUpdateVerification_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("finishUpdateVerification_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class finishUpdateVerification_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("finishUpdateVerification_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  finishUpdateVerification_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("finishUpdateVerification_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class generateUserTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("generateUserTicket_args");
  static final TField _EXPIRATION_TIME_FIELD_DESC = new TField("expirationTime", TType.I64, 3);
  static final TField _MAX_USE_COUNT_FIELD_DESC = new TField("maxUseCount", TType.I32, 4);

  int _expirationTime = 0;
  static const int EXPIRATIONTIME = 3;
  int _maxUseCount = 0;
  static const int MAXUSECOUNT = 4;

  bool __isset_expirationTime = false;
  bool __isset_maxUseCount = false;

  generateUserTicket_args() {
  }

  // expirationTime
  int get expirationTime => this._expirationTime;

  set expirationTime(int expirationTime) {
    this._expirationTime = expirationTime;
    this.__isset_expirationTime = true;
  }

  bool isSetExpirationTime() => this.__isset_expirationTime;

  unsetExpirationTime() {
    this.__isset_expirationTime = false;
  }

  // maxUseCount
  int get maxUseCount => this._maxUseCount;

  set maxUseCount(int maxUseCount) {
    this._maxUseCount = maxUseCount;
    this.__isset_maxUseCount = true;
  }

  bool isSetMaxUseCount() => this.__isset_maxUseCount;

  unsetMaxUseCount() {
    this.__isset_maxUseCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case EXPIRATIONTIME:
        return this.expirationTime;
      case MAXUSECOUNT:
        return this.maxUseCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case EXPIRATIONTIME:
        if (value == null) {
          unsetExpirationTime();
        } else {
          this.expirationTime = value;
        }
        break;

      case MAXUSECOUNT:
        if (value == null) {
          unsetMaxUseCount();
        } else {
          this.maxUseCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case EXPIRATIONTIME:
        return isSetExpirationTime();
      case MAXUSECOUNT:
        return isSetMaxUseCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case EXPIRATIONTIME:
          if (field.type == TType.I64) {
            this.expirationTime = iprot.readI64();
            this.__isset_expirationTime = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXUSECOUNT:
          if (field.type == TType.I32) {
            this.maxUseCount = iprot.readI32();
            this.__isset_maxUseCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_EXPIRATION_TIME_FIELD_DESC);
    oprot.writeI64(this.expirationTime);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_MAX_USE_COUNT_FIELD_DESC);
    oprot.writeI32(this.maxUseCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("generateUserTicket_args(");

    ret.write("expirationTime:");
    ret.write(this.expirationTime);

    ret.write(", ");
    ret.write("maxUseCount:");
    ret.write(this.maxUseCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class generateUserTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("generateUserTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Ticket _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  generateUserTicket_result() {
  }

  // success
  Ticket get success => this._success;

  set success(Ticket success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Ticket();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("generateUserTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class destroyMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("destroyMessage_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _CHAT_ID_FIELD_DESC = new TField("chatId", TType.STRING, 2);
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 3);
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.BYTE, 4);

  int _seq = 0;
  static const int SEQ = 1;
  String _chatId;
  static const int CHATID = 2;
  String _messageId;
  static const int MESSAGEID = 3;
  int _sessionId = 0;
  static const int SESSIONID = 4;

  bool __isset_seq = false;
  bool __isset_sessionId = false;

  destroyMessage_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // chatId
  String get chatId => this._chatId;

  set chatId(String chatId) {
    this._chatId = chatId;
  }

  bool isSetChatId() => this.chatId != null;

  unsetChatId() {
    this.chatId = null;
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  // sessionId
  int get sessionId => this._sessionId;

  set sessionId(int sessionId) {
    this._sessionId = sessionId;
    this.__isset_sessionId = true;
  }

  bool isSetSessionId() => this.__isset_sessionId;

  unsetSessionId() {
    this.__isset_sessionId = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case CHATID:
        return this.chatId;
      case MESSAGEID:
        return this.messageId;
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case CHATID:
        if (value == null) {
          unsetChatId();
        } else {
          this.chatId = value;
        }
        break;

      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case CHATID:
        return isSetChatId();
      case MESSAGEID:
        return isSetMessageId();
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CHATID:
          if (field.type == TType.STRING) {
            this.chatId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SESSIONID:
          if (field.type == TType.BYTE) {
            this.sessionId = iprot.readByte();
            this.__isset_sessionId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.chatId != null) {
      oprot.writeFieldBegin(_CHAT_ID_FIELD_DESC);
      oprot.writeString(this.chatId);
      oprot.writeFieldEnd();
    }
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
    oprot.writeByte(this.sessionId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("destroyMessage_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("chatId:");
    if (this.chatId == null) {
      ret.write("null");
    } else {
      ret.write(this.chatId);
    }

    ret.write(", ");
    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(", ");
    ret.write("sessionId:");
    ret.write(this.sessionId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class destroyMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("destroyMessage_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  destroyMessage_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("destroyMessage_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAcceptedProximityMatches_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAcceptedProximityMatches_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  getAcceptedProximityMatches_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAcceptedProximityMatches_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAcceptedProximityMatches_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAcceptedProximityMatches_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.SET, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Set<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getAcceptedProximityMatches_result() {
  }

  // success
  Set<String> get success => this._success;

  set success(Set<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.SET) {
            {
              TSet _set950 = iprot.readSetBegin();
              this.success = new Set<String>();
              for (int _i951 = 0; _i951 < _set950.length; ++_i951) {
                String _elem952;
                _elem952 = iprot.readString();
                this.success.add(_elem952);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRING, this.success.length));
        for (var elem953 in this.success) {
          oprot.writeString(elem953);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAcceptedProximityMatches_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getActiveBuddySubscriberIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getActiveBuddySubscriberIds_args");



  getActiveBuddySubscriberIds_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getActiveBuddySubscriberIds_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getActiveBuddySubscriberIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getActiveBuddySubscriberIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getActiveBuddySubscriberIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list954 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i955 = 0; _i955 < _list954.length; ++_i955) {
                String _elem956;
                _elem956 = iprot.readString();
                this.success.add(_elem956);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem957 in this.success) {
          oprot.writeString(elem957);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getActiveBuddySubscriberIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAllContactIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAllContactIds_args");



  getAllContactIds_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAllContactIds_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAllContactIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAllContactIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getAllContactIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list958 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i959 = 0; _i959 < _list958.length; ++_i959) {
                String _elem960;
                _elem960 = iprot.readString();
                this.success.add(_elem960);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem961 in this.success) {
          oprot.writeString(elem961);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAllContactIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAuthQrcode_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAuthQrcode_args");
  static final TField _KEEP_LOGGED_IN_FIELD_DESC = new TField("keepLoggedIn", TType.BOOL, 2);
  static final TField _SYSTEM_NAME_FIELD_DESC = new TField("systemName", TType.STRING, 3);

  bool _keepLoggedIn = false;
  static const int KEEPLOGGEDIN = 2;
  String _systemName;
  static const int SYSTEMNAME = 3;

  bool __isset_keepLoggedIn = false;

  getAuthQrcode_args() {
  }

  // keepLoggedIn
  bool get keepLoggedIn => this._keepLoggedIn;

  set keepLoggedIn(bool keepLoggedIn) {
    this._keepLoggedIn = keepLoggedIn;
    this.__isset_keepLoggedIn = true;
  }

  bool isSetKeepLoggedIn() => this.__isset_keepLoggedIn;

  unsetKeepLoggedIn() {
    this.__isset_keepLoggedIn = false;
  }

  // systemName
  String get systemName => this._systemName;

  set systemName(String systemName) {
    this._systemName = systemName;
  }

  bool isSetSystemName() => this.systemName != null;

  unsetSystemName() {
    this.systemName = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case KEEPLOGGEDIN:
        return this.keepLoggedIn;
      case SYSTEMNAME:
        return this.systemName;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case KEEPLOGGEDIN:
        if (value == null) {
          unsetKeepLoggedIn();
        } else {
          this.keepLoggedIn = value;
        }
        break;

      case SYSTEMNAME:
        if (value == null) {
          unsetSystemName();
        } else {
          this.systemName = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case KEEPLOGGEDIN:
        return isSetKeepLoggedIn();
      case SYSTEMNAME:
        return isSetSystemName();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case KEEPLOGGEDIN:
          if (field.type == TType.BOOL) {
            this.keepLoggedIn = iprot.readBool();
            this.__isset_keepLoggedIn = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMNAME:
          if (field.type == TType.STRING) {
            this.systemName = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_KEEP_LOGGED_IN_FIELD_DESC);
    oprot.writeBool(this.keepLoggedIn);
    oprot.writeFieldEnd();
    if (this.systemName != null) {
      oprot.writeFieldBegin(_SYSTEM_NAME_FIELD_DESC);
      oprot.writeString(this.systemName);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAuthQrcode_args(");

    ret.write("keepLoggedIn:");
    ret.write(this.keepLoggedIn);

    ret.write(", ");
    ret.write("systemName:");
    if (this.systemName == null) {
      ret.write("null");
    } else {
      ret.write(this.systemName);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAuthQrcode_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAuthQrcode_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  AuthQrcode _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getAuthQrcode_result() {
  }

  // success
  AuthQrcode get success => this._success;

  set success(AuthQrcode success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AuthQrcode();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAuthQrcode_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBlockedContactIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBlockedContactIds_args");



  getBlockedContactIds_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBlockedContactIds_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBlockedContactIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBlockedContactIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getBlockedContactIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list962 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i963 = 0; _i963 < _list962.length; ++_i963) {
                String _elem964;
                _elem964 = iprot.readString();
                this.success.add(_elem964);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem965 in this.success) {
          oprot.writeString(elem965);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBlockedContactIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithPhoneNumber_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithPhoneNumber_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _MIGRATION_PINCODE_SESSION_ID_FIELD_DESC = new TField("migrationPincodeSessionId", TType.STRING, 3);

  String _sessionId;
  static const int SESSIONID = 2;
  String _migrationPincodeSessionId;
  static const int MIGRATIONPINCODESESSIONID = 3;


  registerWithPhoneNumber_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // migrationPincodeSessionId
  String get migrationPincodeSessionId => this._migrationPincodeSessionId;

  set migrationPincodeSessionId(String migrationPincodeSessionId) {
    this._migrationPincodeSessionId = migrationPincodeSessionId;
  }

  bool isSetMigrationPincodeSessionId() => this.migrationPincodeSessionId != null;

  unsetMigrationPincodeSessionId() {
    this.migrationPincodeSessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case MIGRATIONPINCODESESSIONID:
        return this.migrationPincodeSessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case MIGRATIONPINCODESESSIONID:
        if (value == null) {
          unsetMigrationPincodeSessionId();
        } else {
          this.migrationPincodeSessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case MIGRATIONPINCODESESSIONID:
        return isSetMigrationPincodeSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MIGRATIONPINCODESESSIONID:
          if (field.type == TType.STRING) {
            this.migrationPincodeSessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId != null) {
      oprot.writeFieldBegin(_MIGRATION_PINCODE_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.migrationPincodeSessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithPhoneNumber_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("migrationPincodeSessionId:");
    if (this.migrationPincodeSessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.migrationPincodeSessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithPhoneNumber_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithPhoneNumber_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  RegisterWithPhoneNumberResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerWithPhoneNumber_result() {
  }

  // success
  RegisterWithPhoneNumberResult get success => this._success;

  set success(RegisterWithPhoneNumberResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RegisterWithPhoneNumberResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithPhoneNumber_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithPhoneNumberAndPassword_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithPhoneNumberAndPassword_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _KEYNM_FIELD_DESC = new TField("keynm", TType.STRING, 3);
  static final TField _ENCRYPTED_FIELD_DESC = new TField("encrypted", TType.STRING, 4);

  String _sessionId;
  static const int SESSIONID = 2;
  String _keynm;
  static const int KEYNM = 3;
  String _encrypted;
  static const int ENCRYPTED = 4;


  registerWithPhoneNumberAndPassword_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // keynm
  String get keynm => this._keynm;

  set keynm(String keynm) {
    this._keynm = keynm;
  }

  bool isSetKeynm() => this.keynm != null;

  unsetKeynm() {
    this.keynm = null;
  }

  // encrypted
  String get encrypted => this._encrypted;

  set encrypted(String encrypted) {
    this._encrypted = encrypted;
  }

  bool isSetEncrypted() => this.encrypted != null;

  unsetEncrypted() {
    this.encrypted = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case KEYNM:
        return this.keynm;
      case ENCRYPTED:
        return this.encrypted;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case KEYNM:
        if (value == null) {
          unsetKeynm();
        } else {
          this.keynm = value;
        }
        break;

      case ENCRYPTED:
        if (value == null) {
          unsetEncrypted();
        } else {
          this.encrypted = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case KEYNM:
        return isSetKeynm();
      case ENCRYPTED:
        return isSetEncrypted();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEYNM:
          if (field.type == TType.STRING) {
            this.keynm = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ENCRYPTED:
          if (field.type == TType.STRING) {
            this.encrypted = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    if (this.keynm != null) {
      oprot.writeFieldBegin(_KEYNM_FIELD_DESC);
      oprot.writeString(this.keynm);
      oprot.writeFieldEnd();
    }
    if (this.encrypted != null) {
      oprot.writeFieldBegin(_ENCRYPTED_FIELD_DESC);
      oprot.writeString(this.encrypted);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithPhoneNumberAndPassword_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("keynm:");
    if (this.keynm == null) {
      ret.write("null");
    } else {
      ret.write(this.keynm);
    }

    ret.write(", ");
    ret.write("encrypted:");
    if (this.encrypted == null) {
      ret.write("null");
    } else {
      ret.write(this.encrypted);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithPhoneNumberAndPassword_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithPhoneNumberAndPassword_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  RegisterWithPhoneNumberResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerWithPhoneNumberAndPassword_result() {
  }

  // success
  RegisterWithPhoneNumberResult get success => this._success;

  set success(RegisterWithPhoneNumberResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RegisterWithPhoneNumberResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithPhoneNumberAndPassword_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAnalyticsInfo_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAnalyticsInfo_args");



  getAnalyticsInfo_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAnalyticsInfo_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAnalyticsInfo_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAnalyticsInfo_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  AnalyticsInfo _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getAnalyticsInfo_result() {
  }

  // success
  AnalyticsInfo get success => this._success;

  set success(AnalyticsInfo success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AnalyticsInfo();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAnalyticsInfo_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportClientStatistics_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportClientStatistics_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _CATEGORY_FIELD_DESC = new TField("category", TType.I32, 2);
  static final TField _COUNT_FIELD_DESC = new TField("count", TType.I32, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  int _category;
  static const int CATEGORY = 2;
  int _count = 0;
  static const int COUNT = 3;

  bool __isset_reqSeq = false;
  bool __isset_category = false;
  bool __isset_count = false;

  reportClientStatistics_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // category
  int get category => this._category;

  set category(int category) {
    this._category = category;
    this.__isset_category = true;
  }

  bool isSetCategory() => this.__isset_category;

  unsetCategory() {
    this.__isset_category = false;
  }

  // count
  int get count => this._count;

  set count(int count) {
    this._count = count;
    this.__isset_count = true;
  }

  bool isSetCount() => this.__isset_count;

  unsetCount() {
    this.__isset_count = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case CATEGORY:
        return this.category;
      case COUNT:
        return this.count;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case CATEGORY:
        if (value == null) {
          unsetCategory();
        } else {
          this.category = value;
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          this.count = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case CATEGORY:
        return isSetCategory();
      case COUNT:
        return isSetCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CATEGORY:
          if (field.type == TType.I32) {
            this.category = iprot.readI32();
            this.__isset_category = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_CATEGORY_FIELD_DESC);
    oprot.writeI32(this.category);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportClientStatistics_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("category:");
    String category_name = ReportCategory.VALUES_TO_NAMES[this.category];
    if (category_name != null) {
      ret.write(category_name);
      ret.write(" (");
    }
    ret.write(this.category);
    if (category_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("count:");
    ret.write(this.count);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCategory() && !ReportCategory.VALID_VALUES.contains(category)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'category' has been assigned the invalid value $category");
    }
  }

}

class reportClientStatistics_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportClientStatistics_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportClientStatistics_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportClientStatistics_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyPhoneNumberForLogin_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyPhoneNumberForLogin_args");
  static final TField _VERIFIER_FROM_PHONE_FIELD_DESC = new TField("verifierFromPhone", TType.STRING, 2);
  static final TField _PIN_CODE_FOR_PHONE_FIELD_DESC = new TField("pinCodeForPhone", TType.STRING, 3);
  static final TField _VERIFIER_FROM_LOGIN_FIELD_DESC = new TField("verifierFromLogin", TType.STRING, 4);

  String _verifierFromPhone;
  static const int VERIFIERFROMPHONE = 2;
  String _pinCodeForPhone;
  static const int PINCODEFORPHONE = 3;
  String _verifierFromLogin;
  static const int VERIFIERFROMLOGIN = 4;


  verifyPhoneNumberForLogin_args() {
  }

  // verifierFromPhone
  String get verifierFromPhone => this._verifierFromPhone;

  set verifierFromPhone(String verifierFromPhone) {
    this._verifierFromPhone = verifierFromPhone;
  }

  bool isSetVerifierFromPhone() => this.verifierFromPhone != null;

  unsetVerifierFromPhone() {
    this.verifierFromPhone = null;
  }

  // pinCodeForPhone
  String get pinCodeForPhone => this._pinCodeForPhone;

  set pinCodeForPhone(String pinCodeForPhone) {
    this._pinCodeForPhone = pinCodeForPhone;
  }

  bool isSetPinCodeForPhone() => this.pinCodeForPhone != null;

  unsetPinCodeForPhone() {
    this.pinCodeForPhone = null;
  }

  // verifierFromLogin
  String get verifierFromLogin => this._verifierFromLogin;

  set verifierFromLogin(String verifierFromLogin) {
    this._verifierFromLogin = verifierFromLogin;
  }

  bool isSetVerifierFromLogin() => this.verifierFromLogin != null;

  unsetVerifierFromLogin() {
    this.verifierFromLogin = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIERFROMPHONE:
        return this.verifierFromPhone;
      case PINCODEFORPHONE:
        return this.pinCodeForPhone;
      case VERIFIERFROMLOGIN:
        return this.verifierFromLogin;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIERFROMPHONE:
        if (value == null) {
          unsetVerifierFromPhone();
        } else {
          this.verifierFromPhone = value;
        }
        break;

      case PINCODEFORPHONE:
        if (value == null) {
          unsetPinCodeForPhone();
        } else {
          this.pinCodeForPhone = value;
        }
        break;

      case VERIFIERFROMLOGIN:
        if (value == null) {
          unsetVerifierFromLogin();
        } else {
          this.verifierFromLogin = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIERFROMPHONE:
        return isSetVerifierFromPhone();
      case PINCODEFORPHONE:
        return isSetPinCodeForPhone();
      case VERIFIERFROMLOGIN:
        return isSetVerifierFromLogin();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIERFROMPHONE:
          if (field.type == TType.STRING) {
            this.verifierFromPhone = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PINCODEFORPHONE:
          if (field.type == TType.STRING) {
            this.pinCodeForPhone = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VERIFIERFROMLOGIN:
          if (field.type == TType.STRING) {
            this.verifierFromLogin = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifierFromPhone != null) {
      oprot.writeFieldBegin(_VERIFIER_FROM_PHONE_FIELD_DESC);
      oprot.writeString(this.verifierFromPhone);
      oprot.writeFieldEnd();
    }
    if (this.pinCodeForPhone != null) {
      oprot.writeFieldBegin(_PIN_CODE_FOR_PHONE_FIELD_DESC);
      oprot.writeString(this.pinCodeForPhone);
      oprot.writeFieldEnd();
    }
    if (this.verifierFromLogin != null) {
      oprot.writeFieldBegin(_VERIFIER_FROM_LOGIN_FIELD_DESC);
      oprot.writeString(this.verifierFromLogin);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyPhoneNumberForLogin_args(");

    ret.write("verifierFromPhone:");
    if (this.verifierFromPhone == null) {
      ret.write("null");
    } else {
      ret.write(this.verifierFromPhone);
    }

    ret.write(", ");
    ret.write("pinCodeForPhone:");
    if (this.pinCodeForPhone == null) {
      ret.write("null");
    } else {
      ret.write(this.pinCodeForPhone);
    }

    ret.write(", ");
    ret.write("verifierFromLogin:");
    if (this.verifierFromLogin == null) {
      ret.write("null");
    } else {
      ret.write(this.verifierFromLogin);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyPhoneNumberForLogin_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyPhoneNumberForLogin_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  verifyPhoneNumberForLogin_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyPhoneNumberForLogin_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyPhoneNumber_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyPhoneNumber_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _PIN_CODE_FIELD_DESC = new TField("pinCode", TType.STRING, 3);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 4);
  static final TField _MIGRATION_PINCODE_SESSION_ID_FIELD_DESC = new TField("migrationPincodeSessionId", TType.STRING, 5);
  static final TField _OLD_UDID_HASH_FIELD_DESC = new TField("oldUdidHash", TType.STRING, 6);

  String _sessionId;
  static const int SESSIONID = 2;
  String _pinCode;
  static const int PINCODE = 3;
  String _udidHash;
  static const int UDIDHASH = 4;
  String _migrationPincodeSessionId;
  static const int MIGRATIONPINCODESESSIONID = 5;
  String _oldUdidHash;
  static const int OLDUDIDHASH = 6;


  verifyPhoneNumber_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // pinCode
  String get pinCode => this._pinCode;

  set pinCode(String pinCode) {
    this._pinCode = pinCode;
  }

  bool isSetPinCode() => this.pinCode != null;

  unsetPinCode() {
    this.pinCode = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // migrationPincodeSessionId
  String get migrationPincodeSessionId => this._migrationPincodeSessionId;

  set migrationPincodeSessionId(String migrationPincodeSessionId) {
    this._migrationPincodeSessionId = migrationPincodeSessionId;
  }

  bool isSetMigrationPincodeSessionId() => this.migrationPincodeSessionId != null;

  unsetMigrationPincodeSessionId() {
    this.migrationPincodeSessionId = null;
  }

  // oldUdidHash
  String get oldUdidHash => this._oldUdidHash;

  set oldUdidHash(String oldUdidHash) {
    this._oldUdidHash = oldUdidHash;
  }

  bool isSetOldUdidHash() => this.oldUdidHash != null;

  unsetOldUdidHash() {
    this.oldUdidHash = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case PINCODE:
        return this.pinCode;
      case UDIDHASH:
        return this.udidHash;
      case MIGRATIONPINCODESESSIONID:
        return this.migrationPincodeSessionId;
      case OLDUDIDHASH:
        return this.oldUdidHash;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case PINCODE:
        if (value == null) {
          unsetPinCode();
        } else {
          this.pinCode = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case MIGRATIONPINCODESESSIONID:
        if (value == null) {
          unsetMigrationPincodeSessionId();
        } else {
          this.migrationPincodeSessionId = value;
        }
        break;

      case OLDUDIDHASH:
        if (value == null) {
          unsetOldUdidHash();
        } else {
          this.oldUdidHash = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case PINCODE:
        return isSetPinCode();
      case UDIDHASH:
        return isSetUdidHash();
      case MIGRATIONPINCODESESSIONID:
        return isSetMigrationPincodeSessionId();
      case OLDUDIDHASH:
        return isSetOldUdidHash();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PINCODE:
          if (field.type == TType.STRING) {
            this.pinCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MIGRATIONPINCODESESSIONID:
          if (field.type == TType.STRING) {
            this.migrationPincodeSessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OLDUDIDHASH:
          if (field.type == TType.STRING) {
            this.oldUdidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    if (this.pinCode != null) {
      oprot.writeFieldBegin(_PIN_CODE_FIELD_DESC);
      oprot.writeString(this.pinCode);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId != null) {
      oprot.writeFieldBegin(_MIGRATION_PINCODE_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.migrationPincodeSessionId);
      oprot.writeFieldEnd();
    }
    if (this.oldUdidHash != null) {
      oprot.writeFieldBegin(_OLD_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.oldUdidHash);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyPhoneNumber_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("pinCode:");
    if (this.pinCode == null) {
      ret.write("null");
    } else {
      ret.write(this.pinCode);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("migrationPincodeSessionId:");
    if (this.migrationPincodeSessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.migrationPincodeSessionId);
    }

    ret.write(", ");
    ret.write("oldUdidHash:");
    if (this.oldUdidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.oldUdidHash);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyPhoneNumber_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyPhoneNumber_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PhoneVerificationResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  verifyPhoneNumber_result() {
  }

  // success
  PhoneVerificationResult get success => this._success;

  set success(PhoneVerificationResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PhoneVerificationResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyPhoneNumber_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBlockedContactIdsByRange_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBlockedContactIdsByRange_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I32, 2);
  static final TField _COUNT_FIELD_DESC = new TField("count", TType.I32, 3);

  int _start = 0;
  static const int START = 2;
  int _count = 0;
  static const int COUNT = 3;

  bool __isset_start = false;
  bool __isset_count = false;

  getBlockedContactIdsByRange_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // count
  int get count => this._count;

  set count(int count) {
    this._count = count;
    this.__isset_count = true;
  }

  bool isSetCount() => this.__isset_count;

  unsetCount() {
    this.__isset_count = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case COUNT:
        return this.count;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          this.count = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case COUNT:
        return isSetCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I32) {
            this.start = iprot.readI32();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI32(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBlockedContactIdsByRange_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("count:");
    ret.write(this.count);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBlockedContactIdsByRange_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBlockedContactIdsByRange_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getBlockedContactIdsByRange_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list966 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i967 = 0; _i967 < _list966.length; ++_i967) {
                String _elem968;
                _elem968 = iprot.readString();
                this.success.add(_elem968);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem969 in this.success) {
          oprot.writeString(elem969);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBlockedContactIdsByRange_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBlockedRecommendationIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBlockedRecommendationIds_args");



  getBlockedRecommendationIds_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBlockedRecommendationIds_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBlockedRecommendationIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBlockedRecommendationIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getBlockedRecommendationIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list970 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i971 = 0; _i971 < _list970.length; ++_i971) {
                String _elem972;
                _elem972 = iprot.readString();
                this.success.add(_elem972);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem973 in this.success) {
          oprot.writeString(elem973);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBlockedRecommendationIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBuddyBlockerIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBuddyBlockerIds_args");



  getBuddyBlockerIds_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBuddyBlockerIds_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBuddyBlockerIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBuddyBlockerIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getBuddyBlockerIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list974 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i975 = 0; _i975 < _list974.length; ++_i975) {
                String _elem976;
                _elem976 = iprot.readString();
                this.success.add(_elem976);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem977 in this.success) {
          oprot.writeString(elem977);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBuddyBlockerIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBuddyLocation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBuddyLocation_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);
  static final TField _INDEX_FIELD_DESC = new TField("index", TType.I32, 3);

  String _mid;
  static const int MID = 2;
  int _index = 0;
  static const int INDEX = 3;

  bool __isset_index = false;

  getBuddyLocation_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // index
  int get index => this._index;

  set index(int index) {
    this._index = index;
    this.__isset_index = true;
  }

  bool isSetIndex() => this.__isset_index;

  unsetIndex() {
    this.__isset_index = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      case INDEX:
        return this.index;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case INDEX:
        if (value == null) {
          unsetIndex();
        } else {
          this.index = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      case INDEX:
        return isSetIndex();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INDEX:
          if (field.type == TType.I32) {
            this.index = iprot.readI32();
            this.__isset_index = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_INDEX_FIELD_DESC);
    oprot.writeI32(this.index);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBuddyLocation_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("index:");
    ret.write(this.index);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBuddyLocation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getBuddyLocation_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Geolocation _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getBuddyLocation_result() {
  }

  // success
  Geolocation get success => this._success;

  set success(Geolocation success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Geolocation();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getBuddyLocation_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactContactsModifiedSince_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactContactsModifiedSince_args");
  static final TField _TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, 2);

  int _timestamp = 0;
  static const int TIMESTAMP = 2;

  bool __isset_timestamp = false;

  getCompactContactsModifiedSince_args() {
  }

  // timestamp
  int get timestamp => this._timestamp;

  set timestamp(int timestamp) {
    this._timestamp = timestamp;
    this.__isset_timestamp = true;
  }

  bool isSetTimestamp() => this.__isset_timestamp;

  unsetTimestamp() {
    this.__isset_timestamp = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TIMESTAMP:
        return this.timestamp;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          this.timestamp = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TIMESTAMP:
        return isSetTimestamp();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TIMESTAMP:
          if (field.type == TType.I64) {
            this.timestamp = iprot.readI64();
            this.__isset_timestamp = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TIMESTAMP_FIELD_DESC);
    oprot.writeI64(this.timestamp);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactContactsModifiedSince_args(");

    ret.write("timestamp:");
    ret.write(this.timestamp);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactContactsModifiedSince_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactContactsModifiedSince_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<CompactContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCompactContactsModifiedSince_result() {
  }

  // success
  List<CompactContact> get success => this._success;

  set success(List<CompactContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list978 = iprot.readListBegin();
              this.success = new List<CompactContact>();
              for (int _i979 = 0; _i979 < _list978.length; ++_i979) {
                CompactContact _elem980;
                _elem980 = new CompactContact();
                _elem980.read(iprot);
                this.success.add(_elem980);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem981 in this.success) {
          elem981.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactContactsModifiedSince_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactGroup_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);

  String _groupId;
  static const int GROUPID = 2;


  getCompactGroup_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactGroup_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactGroup_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Group _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCompactGroup_result() {
  }

  // success
  Group get success => this._success;

  set success(Group success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Group();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactGroup_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactRoom_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactRoom_args");
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 2);

  String _roomId;
  static const int ROOMID = 2;


  getCompactRoom_args() {
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return this.roomId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return isSetRoomId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactRoom_args(");

    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactRoom_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactRoom_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Room _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCompactRoom_result() {
  }

  // success
  Room get success => this._success;

  set success(Room success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Room();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactRoom_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContact_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContact_args");
  static final TField _ID_FIELD_DESC = new TField("id", TType.STRING, 2);

  String _id;
  static const int ID = 2;


  getContact_args() {
  }

  // id
  String get id => this._id;

  set id(String id) {
    this._id = id;
  }

  bool isSetId() => this.id != null;

  unsetId() {
    this.id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ID:
        return this.id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ID:
        return isSetId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ID:
          if (field.type == TType.STRING) {
            this.id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(_ID_FIELD_DESC);
      oprot.writeString(this.id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContact_args(");

    ret.write("id:");
    if (this.id == null) {
      ret.write("null");
    } else {
      ret.write(this.id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContact_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContact_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getContact_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContact_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContacts_args");
  static final TField _IDS_FIELD_DESC = new TField("ids", TType.LIST, 2);

  List<String> _ids;
  static const int IDS = 2;


  getContacts_args() {
  }

  // ids
  List<String> get ids => this._ids;

  set ids(List<String> ids) {
    this._ids = ids;
  }

  bool isSetIds() => this.ids != null;

  unsetIds() {
    this.ids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDS:
        return this.ids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDS:
        if (value == null) {
          unsetIds();
        } else {
          this.ids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDS:
        return isSetIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDS:
          if (field.type == TType.LIST) {
            {
              TList _list982 = iprot.readListBegin();
              this.ids = new List<String>();
              for (int _i983 = 0; _i983 < _list982.length; ++_i983) {
                String _elem984;
                _elem984 = iprot.readString();
                this.ids.add(_elem984);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ids != null) {
      oprot.writeFieldBegin(_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.ids.length));
        for (var elem985 in this.ids) {
          oprot.writeString(elem985);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContacts_args(");

    ret.write("ids:");
    if (this.ids == null) {
      ret.write("null");
    } else {
      ret.write(this.ids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getContacts_result() {
  }

  // success
  List<Contact> get success => this._success;

  set success(List<Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list986 = iprot.readListBegin();
              this.success = new List<Contact>();
              for (int _i987 = 0; _i987 < _list986.length; ++_i987) {
                Contact _elem988;
                _elem988 = new Contact();
                _elem988.read(iprot);
                this.success.add(_elem988);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem989 in this.success) {
          elem989.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContactWithFriendRequestStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContactWithFriendRequestStatus_args");
  static final TField _ID_FIELD_DESC = new TField("id", TType.STRING, 2);

  String _id;
  static const int ID = 2;


  getContactWithFriendRequestStatus_args() {
  }

  // id
  String get id => this._id;

  set id(String id) {
    this._id = id;
  }

  bool isSetId() => this.id != null;

  unsetId() {
    this.id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ID:
        return this.id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ID:
        return isSetId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ID:
          if (field.type == TType.STRING) {
            this.id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(_ID_FIELD_DESC);
      oprot.writeString(this.id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContactWithFriendRequestStatus_args(");

    ret.write("id:");
    if (this.id == null) {
      ret.write("null");
    } else {
      ret.write(this.id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContactWithFriendRequestStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContactWithFriendRequestStatus_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getContactWithFriendRequestStatus_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContactWithFriendRequestStatus_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCountryWithRequestIp_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCountryWithRequestIp_args");



  getCountryWithRequestIp_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCountryWithRequestIp_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCountryWithRequestIp_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCountryWithRequestIp_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCountryWithRequestIp_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCountryWithRequestIp_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFavoriteMids_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFavoriteMids_args");



  getFavoriteMids_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFavoriteMids_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFavoriteMids_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFavoriteMids_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getFavoriteMids_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list990 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i991 = 0; _i991 < _list990.length; ++_i991) {
                String _elem992;
                _elem992 = iprot.readString();
                this.success.add(_elem992);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem993 in this.success) {
          oprot.writeString(elem993);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFavoriteMids_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroup_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);

  String _groupId;
  static const int GROUPID = 2;


  getGroup_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroup_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroup_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Group _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroup_result() {
  }

  // success
  Group get success => this._success;

  set success(Group success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Group();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroup_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupIdsInvited_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupIdsInvited_args");



  getGroupIdsInvited_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupIdsInvited_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupIdsInvited_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupIdsInvited_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupIdsInvited_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list994 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i995 = 0; _i995 < _list994.length; ++_i995) {
                String _elem996;
                _elem996 = iprot.readString();
                this.success.add(_elem996);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem997 in this.success) {
          oprot.writeString(elem997);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupIdsInvited_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupIdsJoined_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupIdsJoined_args");



  getGroupIdsJoined_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupIdsJoined_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupIdsJoined_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupIdsJoined_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupIdsJoined_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list998 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i999 = 0; _i999 < _list998.length; ++_i999) {
                String _elem1000;
                _elem1000 = iprot.readString();
                this.success.add(_elem1000);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1001 in this.success) {
          oprot.writeString(elem1001);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupIdsJoined_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroups_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroups_args");
  static final TField _GROUP_IDS_FIELD_DESC = new TField("groupIds", TType.LIST, 2);

  List<String> _groupIds;
  static const int GROUPIDS = 2;


  getGroups_args() {
  }

  // groupIds
  List<String> get groupIds => this._groupIds;

  set groupIds(List<String> groupIds) {
    this._groupIds = groupIds;
  }

  bool isSetGroupIds() => this.groupIds != null;

  unsetGroupIds() {
    this.groupIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPIDS:
        return this.groupIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPIDS:
        if (value == null) {
          unsetGroupIds();
        } else {
          this.groupIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPIDS:
        return isSetGroupIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1002 = iprot.readListBegin();
              this.groupIds = new List<String>();
              for (int _i1003 = 0; _i1003 < _list1002.length; ++_i1003) {
                String _elem1004;
                _elem1004 = iprot.readString();
                this.groupIds.add(_elem1004);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupIds != null) {
      oprot.writeFieldBegin(_GROUP_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.groupIds.length));
        for (var elem1005 in this.groupIds) {
          oprot.writeString(elem1005);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroups_args(");

    ret.write("groupIds:");
    if (this.groupIds == null) {
      ret.write("null");
    } else {
      ret.write(this.groupIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroups_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroups_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Group> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroups_result() {
  }

  // success
  List<Group> get success => this._success;

  set success(List<Group> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1006 = iprot.readListBegin();
              this.success = new List<Group>();
              for (int _i1007 = 0; _i1007 < _list1006.length; ++_i1007) {
                Group _elem1008;
                _elem1008 = new Group();
                _elem1008.read(iprot);
                this.success.add(_elem1008);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1009 in this.success) {
          elem1009.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroups_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getHiddenContactMids_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getHiddenContactMids_args");



  getHiddenContactMids_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getHiddenContactMids_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getHiddenContactMids_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getHiddenContactMids_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getHiddenContactMids_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1010 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1011 = 0; _i1011 < _list1010.length; ++_i1011) {
                String _elem1012;
                _elem1012 = iprot.readString();
                this.success.add(_elem1012);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1013 in this.success) {
          oprot.writeString(elem1013);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getHiddenContactMids_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getIdentityIdentifier_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getIdentityIdentifier_args");



  getIdentityIdentifier_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getIdentityIdentifier_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getIdentityIdentifier_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getIdentityIdentifier_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getIdentityIdentifier_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getIdentityIdentifier_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLastAnnouncementIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getLastAnnouncementIndex_args");



  getLastAnnouncementIndex_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getLastAnnouncementIndex_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLastAnnouncementIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getLastAnnouncementIndex_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I32, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  getLastAnnouncementIndex_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getLastAnnouncementIndex_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLastOpRevision_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getLastOpRevision_args");



  getLastOpRevision_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getLastOpRevision_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLastOpRevision_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getLastOpRevision_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  getLastOpRevision_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getLastOpRevision_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSuggestRevisions_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSuggestRevisions_args");



  getSuggestRevisions_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSuggestRevisions_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSuggestRevisions_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSuggestRevisions_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  SuggestDictionaryRevisions _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getSuggestRevisions_result() {
  }

  // success
  SuggestDictionaryRevisions get success => this._success;

  set success(SuggestDictionaryRevisions success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SuggestDictionaryRevisions();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSuggestRevisions_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPreviousMessagesV2WithReadCount_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPreviousMessagesV2WithReadCount_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);
  static final TField _END_MESSAGE_ID_FIELD_DESC = new TField("endMessageId", TType.STRUCT, 3);
  static final TField _MESSAGES_COUNT_FIELD_DESC = new TField("messagesCount", TType.I32, 4);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;
  MessageBoxV2MessageId _endMessageId;
  static const int ENDMESSAGEID = 3;
  int _messagesCount = 0;
  static const int MESSAGESCOUNT = 4;

  bool __isset_messagesCount = false;

  getPreviousMessagesV2WithReadCount_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // endMessageId
  MessageBoxV2MessageId get endMessageId => this._endMessageId;

  set endMessageId(MessageBoxV2MessageId endMessageId) {
    this._endMessageId = endMessageId;
  }

  bool isSetEndMessageId() => this.endMessageId != null;

  unsetEndMessageId() {
    this.endMessageId = null;
  }

  // messagesCount
  int get messagesCount => this._messagesCount;

  set messagesCount(int messagesCount) {
    this._messagesCount = messagesCount;
    this.__isset_messagesCount = true;
  }

  bool isSetMessagesCount() => this.__isset_messagesCount;

  unsetMessagesCount() {
    this.__isset_messagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      case ENDMESSAGEID:
        return this.endMessageId;
      case MESSAGESCOUNT:
        return this.messagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case ENDMESSAGEID:
        if (value == null) {
          unsetEndMessageId();
        } else {
          this.endMessageId = value;
        }
        break;

      case MESSAGESCOUNT:
        if (value == null) {
          unsetMessagesCount();
        } else {
          this.messagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case ENDMESSAGEID:
        return isSetEndMessageId();
      case MESSAGESCOUNT:
        return isSetMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ENDMESSAGEID:
          if (field.type == TType.STRUCT) {
            this.endMessageId = new MessageBoxV2MessageId();
            this.endMessageId.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.messagesCount = iprot.readI32();
            this.__isset_messagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    if (this.endMessageId != null) {
      oprot.writeFieldBegin(_END_MESSAGE_ID_FIELD_DESC);
      this.endMessageId.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.messagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPreviousMessagesV2WithReadCount_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("endMessageId:");
    if (this.endMessageId == null) {
      ret.write("null");
    } else {
      ret.write(this.endMessageId);
    }

    ret.write(", ");
    ret.write("messagesCount:");
    ret.write(this.messagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPreviousMessagesV2WithReadCount_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPreviousMessagesV2WithReadCount_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPreviousMessagesV2WithReadCount_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1014 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1015 = 0; _i1015 < _list1014.length; ++_i1015) {
                Message _elem1016;
                _elem1016 = new Message();
                _elem1016.read(iprot);
                this.success.add(_elem1016);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1017 in this.success) {
          elem1017.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPreviousMessagesV2WithReadCount_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBox_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBox_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 3);
  static final TField _LAST_MESSAGES_COUNT_FIELD_DESC = new TField("lastMessagesCount", TType.I32, 4);

  String _channelId;
  static const int CHANNELID = 2;
  String _messageBoxId;
  static const int MESSAGEBOXID = 3;
  int _lastMessagesCount = 0;
  static const int LASTMESSAGESCOUNT = 4;

  bool __isset_lastMessagesCount = false;

  getMessageBox_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // lastMessagesCount
  int get lastMessagesCount => this._lastMessagesCount;

  set lastMessagesCount(int lastMessagesCount) {
    this._lastMessagesCount = lastMessagesCount;
    this.__isset_lastMessagesCount = true;
  }

  bool isSetLastMessagesCount() => this.__isset_lastMessagesCount;

  unsetLastMessagesCount() {
    this.__isset_lastMessagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case MESSAGEBOXID:
        return this.messageBoxId;
      case LASTMESSAGESCOUNT:
        return this.lastMessagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case LASTMESSAGESCOUNT:
        if (value == null) {
          unsetLastMessagesCount();
        } else {
          this.lastMessagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case LASTMESSAGESCOUNT:
        return isSetLastMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTMESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.lastMessagesCount = iprot.readI32();
            this.__isset_lastMessagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_LAST_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.lastMessagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBox_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("lastMessagesCount:");
    ret.write(this.lastMessagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBox_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBox_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMessageBox _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBox_result() {
  }

  // success
  TMessageBox get success => this._success;

  set success(TMessageBox success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMessageBox();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBox_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxCompactWrapUp_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxCompactWrapUp_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);

  String _mid;
  static const int MID = 2;


  getMessageBoxCompactWrapUp_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxCompactWrapUp_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxCompactWrapUp_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxCompactWrapUp_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMessageBoxWrapUp _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxCompactWrapUp_result() {
  }

  // success
  TMessageBoxWrapUp get success => this._success;

  set success(TMessageBoxWrapUp success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMessageBoxWrapUp();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxCompactWrapUp_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxCompactWrapUpList_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxCompactWrapUpList_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I32, 2);
  static final TField _MESSAGE_BOX_COUNT_FIELD_DESC = new TField("messageBoxCount", TType.I32, 3);

  int _start = 0;
  static const int START = 2;
  int _messageBoxCount = 0;
  static const int MESSAGEBOXCOUNT = 3;

  bool __isset_start = false;
  bool __isset_messageBoxCount = false;

  getMessageBoxCompactWrapUpList_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // messageBoxCount
  int get messageBoxCount => this._messageBoxCount;

  set messageBoxCount(int messageBoxCount) {
    this._messageBoxCount = messageBoxCount;
    this.__isset_messageBoxCount = true;
  }

  bool isSetMessageBoxCount() => this.__isset_messageBoxCount;

  unsetMessageBoxCount() {
    this.__isset_messageBoxCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case MESSAGEBOXCOUNT:
        return this.messageBoxCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case MESSAGEBOXCOUNT:
        if (value == null) {
          unsetMessageBoxCount();
        } else {
          this.messageBoxCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case MESSAGEBOXCOUNT:
        return isSetMessageBoxCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I32) {
            this.start = iprot.readI32();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEBOXCOUNT:
          if (field.type == TType.I32) {
            this.messageBoxCount = iprot.readI32();
            this.__isset_messageBoxCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI32(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_MESSAGE_BOX_COUNT_FIELD_DESC);
    oprot.writeI32(this.messageBoxCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxCompactWrapUpList_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("messageBoxCount:");
    ret.write(this.messageBoxCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxCompactWrapUpList_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxCompactWrapUpList_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMessageBoxWrapUpResponse _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxCompactWrapUpList_result() {
  }

  // success
  TMessageBoxWrapUpResponse get success => this._success;

  set success(TMessageBoxWrapUpResponse success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMessageBoxWrapUpResponse();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxCompactWrapUpList_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxList_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxList_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _LAST_MESSAGES_COUNT_FIELD_DESC = new TField("lastMessagesCount", TType.I32, 3);

  String _channelId;
  static const int CHANNELID = 2;
  int _lastMessagesCount = 0;
  static const int LASTMESSAGESCOUNT = 3;

  bool __isset_lastMessagesCount = false;

  getMessageBoxList_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // lastMessagesCount
  int get lastMessagesCount => this._lastMessagesCount;

  set lastMessagesCount(int lastMessagesCount) {
    this._lastMessagesCount = lastMessagesCount;
    this.__isset_lastMessagesCount = true;
  }

  bool isSetLastMessagesCount() => this.__isset_lastMessagesCount;

  unsetLastMessagesCount() {
    this.__isset_lastMessagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case LASTMESSAGESCOUNT:
        return this.lastMessagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case LASTMESSAGESCOUNT:
        if (value == null) {
          unsetLastMessagesCount();
        } else {
          this.lastMessagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case LASTMESSAGESCOUNT:
        return isSetLastMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTMESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.lastMessagesCount = iprot.readI32();
            this.__isset_lastMessagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_LAST_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.lastMessagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxList_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("lastMessagesCount:");
    ret.write(this.lastMessagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxList_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxList_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<TMessageBox> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxList_result() {
  }

  // success
  List<TMessageBox> get success => this._success;

  set success(List<TMessageBox> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1018 = iprot.readListBegin();
              this.success = new List<TMessageBox>();
              for (int _i1019 = 0; _i1019 < _list1018.length; ++_i1019) {
                TMessageBox _elem1020;
                _elem1020 = new TMessageBox();
                _elem1020.read(iprot);
                this.success.add(_elem1020);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1021 in this.success) {
          elem1021.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxList_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxListByStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxListByStatus_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _LAST_MESSAGES_COUNT_FIELD_DESC = new TField("lastMessagesCount", TType.I32, 3);
  static final TField _STATUS_FIELD_DESC = new TField("status", TType.I32, 4);

  String _channelId;
  static const int CHANNELID = 2;
  int _lastMessagesCount = 0;
  static const int LASTMESSAGESCOUNT = 3;
  int _status = 0;
  static const int STATUS = 4;

  bool __isset_lastMessagesCount = false;
  bool __isset_status = false;

  getMessageBoxListByStatus_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // lastMessagesCount
  int get lastMessagesCount => this._lastMessagesCount;

  set lastMessagesCount(int lastMessagesCount) {
    this._lastMessagesCount = lastMessagesCount;
    this.__isset_lastMessagesCount = true;
  }

  bool isSetLastMessagesCount() => this.__isset_lastMessagesCount;

  unsetLastMessagesCount() {
    this.__isset_lastMessagesCount = false;
  }

  // status
  int get status => this._status;

  set status(int status) {
    this._status = status;
    this.__isset_status = true;
  }

  bool isSetStatus() => this.__isset_status;

  unsetStatus() {
    this.__isset_status = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case LASTMESSAGESCOUNT:
        return this.lastMessagesCount;
      case STATUS:
        return this.status;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case LASTMESSAGESCOUNT:
        if (value == null) {
          unsetLastMessagesCount();
        } else {
          this.lastMessagesCount = value;
        }
        break;

      case STATUS:
        if (value == null) {
          unsetStatus();
        } else {
          this.status = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case LASTMESSAGESCOUNT:
        return isSetLastMessagesCount();
      case STATUS:
        return isSetStatus();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTMESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.lastMessagesCount = iprot.readI32();
            this.__isset_lastMessagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STATUS:
          if (field.type == TType.I32) {
            this.status = iprot.readI32();
            this.__isset_status = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_LAST_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.lastMessagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_STATUS_FIELD_DESC);
    oprot.writeI32(this.status);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxListByStatus_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("lastMessagesCount:");
    ret.write(this.lastMessagesCount);

    ret.write(", ");
    ret.write("status:");
    ret.write(this.status);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxListByStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxListByStatus_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<TMessageBox> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxListByStatus_result() {
  }

  // success
  List<TMessageBox> get success => this._success;

  set success(List<TMessageBox> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1022 = iprot.readListBegin();
              this.success = new List<TMessageBox>();
              for (int _i1023 = 0; _i1023 < _list1022.length; ++_i1023) {
                TMessageBox _elem1024;
                _elem1024 = new TMessageBox();
                _elem1024.read(iprot);
                this.success.add(_elem1024);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1025 in this.success) {
          elem1025.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxListByStatus_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxWrapUp_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxWrapUp_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);

  String _mid;
  static const int MID = 2;


  getMessageBoxWrapUp_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxWrapUp_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxWrapUp_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxWrapUp_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMessageBoxWrapUp _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxWrapUp_result() {
  }

  // success
  TMessageBoxWrapUp get success => this._success;

  set success(TMessageBoxWrapUp success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMessageBoxWrapUp();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxWrapUp_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxWrapUpList_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxWrapUpList_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I32, 2);
  static final TField _MESSAGE_BOX_COUNT_FIELD_DESC = new TField("messageBoxCount", TType.I32, 3);

  int _start = 0;
  static const int START = 2;
  int _messageBoxCount = 0;
  static const int MESSAGEBOXCOUNT = 3;

  bool __isset_start = false;
  bool __isset_messageBoxCount = false;

  getMessageBoxWrapUpList_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // messageBoxCount
  int get messageBoxCount => this._messageBoxCount;

  set messageBoxCount(int messageBoxCount) {
    this._messageBoxCount = messageBoxCount;
    this.__isset_messageBoxCount = true;
  }

  bool isSetMessageBoxCount() => this.__isset_messageBoxCount;

  unsetMessageBoxCount() {
    this.__isset_messageBoxCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case MESSAGEBOXCOUNT:
        return this.messageBoxCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case MESSAGEBOXCOUNT:
        if (value == null) {
          unsetMessageBoxCount();
        } else {
          this.messageBoxCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case MESSAGEBOXCOUNT:
        return isSetMessageBoxCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I32) {
            this.start = iprot.readI32();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEBOXCOUNT:
          if (field.type == TType.I32) {
            this.messageBoxCount = iprot.readI32();
            this.__isset_messageBoxCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI32(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_MESSAGE_BOX_COUNT_FIELD_DESC);
    oprot.writeI32(this.messageBoxCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxWrapUpList_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("messageBoxCount:");
    ret.write(this.messageBoxCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxWrapUpList_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxWrapUpList_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMessageBoxWrapUpResponse _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxWrapUpList_result() {
  }

  // success
  TMessageBoxWrapUpResponse get success => this._success;

  set success(TMessageBoxWrapUpResponse success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMessageBoxWrapUpResponse();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxWrapUpList_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessagesBySequenceNumber_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessagesBySequenceNumber_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 3);
  static final TField _START_SEQ_FIELD_DESC = new TField("startSeq", TType.I64, 4);
  static final TField _END_SEQ_FIELD_DESC = new TField("endSeq", TType.I64, 5);

  String _channelId;
  static const int CHANNELID = 2;
  String _messageBoxId;
  static const int MESSAGEBOXID = 3;
  int _startSeq = 0;
  static const int STARTSEQ = 4;
  int _endSeq = 0;
  static const int ENDSEQ = 5;

  bool __isset_startSeq = false;
  bool __isset_endSeq = false;

  getMessagesBySequenceNumber_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // startSeq
  int get startSeq => this._startSeq;

  set startSeq(int startSeq) {
    this._startSeq = startSeq;
    this.__isset_startSeq = true;
  }

  bool isSetStartSeq() => this.__isset_startSeq;

  unsetStartSeq() {
    this.__isset_startSeq = false;
  }

  // endSeq
  int get endSeq => this._endSeq;

  set endSeq(int endSeq) {
    this._endSeq = endSeq;
    this.__isset_endSeq = true;
  }

  bool isSetEndSeq() => this.__isset_endSeq;

  unsetEndSeq() {
    this.__isset_endSeq = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case MESSAGEBOXID:
        return this.messageBoxId;
      case STARTSEQ:
        return this.startSeq;
      case ENDSEQ:
        return this.endSeq;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case STARTSEQ:
        if (value == null) {
          unsetStartSeq();
        } else {
          this.startSeq = value;
        }
        break;

      case ENDSEQ:
        if (value == null) {
          unsetEndSeq();
        } else {
          this.endSeq = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case STARTSEQ:
        return isSetStartSeq();
      case ENDSEQ:
        return isSetEndSeq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STARTSEQ:
          if (field.type == TType.I64) {
            this.startSeq = iprot.readI64();
            this.__isset_startSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ENDSEQ:
          if (field.type == TType.I64) {
            this.endSeq = iprot.readI64();
            this.__isset_endSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_START_SEQ_FIELD_DESC);
    oprot.writeI64(this.startSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_END_SEQ_FIELD_DESC);
    oprot.writeI64(this.endSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessagesBySequenceNumber_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("startSeq:");
    ret.write(this.startSeq);

    ret.write(", ");
    ret.write("endSeq:");
    ret.write(this.endSeq);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessagesBySequenceNumber_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessagesBySequenceNumber_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessagesBySequenceNumber_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1026 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1027 = 0; _i1027 < _list1026.length; ++_i1027) {
                Message _elem1028;
                _elem1028 = new Message();
                _elem1028.read(iprot);
                this.success.add(_elem1028);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1029 in this.success) {
          elem1029.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessagesBySequenceNumber_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNextMessages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNextMessages_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);
  static final TField _START_SEQ_FIELD_DESC = new TField("startSeq", TType.I64, 3);
  static final TField _MESSAGES_COUNT_FIELD_DESC = new TField("messagesCount", TType.I32, 4);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;
  int _startSeq = 0;
  static const int STARTSEQ = 3;
  int _messagesCount = 0;
  static const int MESSAGESCOUNT = 4;

  bool __isset_startSeq = false;
  bool __isset_messagesCount = false;

  getNextMessages_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // startSeq
  int get startSeq => this._startSeq;

  set startSeq(int startSeq) {
    this._startSeq = startSeq;
    this.__isset_startSeq = true;
  }

  bool isSetStartSeq() => this.__isset_startSeq;

  unsetStartSeq() {
    this.__isset_startSeq = false;
  }

  // messagesCount
  int get messagesCount => this._messagesCount;

  set messagesCount(int messagesCount) {
    this._messagesCount = messagesCount;
    this.__isset_messagesCount = true;
  }

  bool isSetMessagesCount() => this.__isset_messagesCount;

  unsetMessagesCount() {
    this.__isset_messagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      case STARTSEQ:
        return this.startSeq;
      case MESSAGESCOUNT:
        return this.messagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case STARTSEQ:
        if (value == null) {
          unsetStartSeq();
        } else {
          this.startSeq = value;
        }
        break;

      case MESSAGESCOUNT:
        if (value == null) {
          unsetMessagesCount();
        } else {
          this.messagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case STARTSEQ:
        return isSetStartSeq();
      case MESSAGESCOUNT:
        return isSetMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STARTSEQ:
          if (field.type == TType.I64) {
            this.startSeq = iprot.readI64();
            this.__isset_startSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.messagesCount = iprot.readI32();
            this.__isset_messagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_START_SEQ_FIELD_DESC);
    oprot.writeI64(this.startSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.messagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNextMessages_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("startSeq:");
    ret.write(this.startSeq);

    ret.write(", ");
    ret.write("messagesCount:");
    ret.write(this.messagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNextMessages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNextMessages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getNextMessages_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1030 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1031 = 0; _i1031 < _list1030.length; ++_i1031) {
                Message _elem1032;
                _elem1032 = new Message();
                _elem1032.read(iprot);
                this.success.add(_elem1032);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1033 in this.success) {
          elem1033.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNextMessages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNotificationPolicy_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNotificationPolicy_args");
  static final TField _CARRIER_FIELD_DESC = new TField("carrier", TType.I32, 2);

  int _carrier;
  static const int CARRIER = 2;

  bool __isset_carrier = false;

  getNotificationPolicy_args() {
  }

  // carrier
  int get carrier => this._carrier;

  set carrier(int carrier) {
    this._carrier = carrier;
    this.__isset_carrier = true;
  }

  bool isSetCarrier() => this.__isset_carrier;

  unsetCarrier() {
    this.__isset_carrier = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CARRIER:
        return this.carrier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CARRIER:
        if (value == null) {
          unsetCarrier();
        } else {
          this.carrier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CARRIER:
        return isSetCarrier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CARRIER:
          if (field.type == TType.I32) {
            this.carrier = iprot.readI32();
            this.__isset_carrier = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_CARRIER_FIELD_DESC);
    oprot.writeI32(this.carrier);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNotificationPolicy_args(");

    ret.write("carrier:");
    String carrier_name = CarrierCode.VALUES_TO_NAMES[this.carrier];
    if (carrier_name != null) {
      ret.write(carrier_name);
      ret.write(" (");
    }
    ret.write(this.carrier);
    if (carrier_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCarrier() && !CarrierCode.VALID_VALUES.contains(carrier)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'carrier' has been assigned the invalid value $carrier");
    }
  }

}

class getNotificationPolicy_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNotificationPolicy_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<int> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getNotificationPolicy_result() {
  }

  // success
  List<int> get success => this._success;

  set success(List<int> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1034 = iprot.readListBegin();
              this.success = new List<int>();
              for (int _i1035 = 0; _i1035 < _list1034.length; ++_i1035) {
                int _elem1036;
                _elem1036 = iprot.readI32();
                this.success.add(_elem1036);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.I32, this.success.length));
        for (var elem1037 in this.success) {
          oprot.writeI32(elem1037);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNotificationPolicy_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPreviousMessages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPreviousMessages_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);
  static final TField _END_SEQ_FIELD_DESC = new TField("endSeq", TType.I64, 3);
  static final TField _MESSAGES_COUNT_FIELD_DESC = new TField("messagesCount", TType.I32, 4);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;
  int _endSeq = 0;
  static const int ENDSEQ = 3;
  int _messagesCount = 0;
  static const int MESSAGESCOUNT = 4;

  bool __isset_endSeq = false;
  bool __isset_messagesCount = false;

  getPreviousMessages_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // endSeq
  int get endSeq => this._endSeq;

  set endSeq(int endSeq) {
    this._endSeq = endSeq;
    this.__isset_endSeq = true;
  }

  bool isSetEndSeq() => this.__isset_endSeq;

  unsetEndSeq() {
    this.__isset_endSeq = false;
  }

  // messagesCount
  int get messagesCount => this._messagesCount;

  set messagesCount(int messagesCount) {
    this._messagesCount = messagesCount;
    this.__isset_messagesCount = true;
  }

  bool isSetMessagesCount() => this.__isset_messagesCount;

  unsetMessagesCount() {
    this.__isset_messagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      case ENDSEQ:
        return this.endSeq;
      case MESSAGESCOUNT:
        return this.messagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case ENDSEQ:
        if (value == null) {
          unsetEndSeq();
        } else {
          this.endSeq = value;
        }
        break;

      case MESSAGESCOUNT:
        if (value == null) {
          unsetMessagesCount();
        } else {
          this.messagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case ENDSEQ:
        return isSetEndSeq();
      case MESSAGESCOUNT:
        return isSetMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ENDSEQ:
          if (field.type == TType.I64) {
            this.endSeq = iprot.readI64();
            this.__isset_endSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.messagesCount = iprot.readI32();
            this.__isset_messagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_END_SEQ_FIELD_DESC);
    oprot.writeI64(this.endSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.messagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPreviousMessages_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("endSeq:");
    ret.write(this.endSeq);

    ret.write(", ");
    ret.write("messagesCount:");
    ret.write(this.messagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPreviousMessages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPreviousMessages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPreviousMessages_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1038 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1039 = 0; _i1039 < _list1038.length; ++_i1039) {
                Message _elem1040;
                _elem1040 = new Message();
                _elem1040.read(iprot);
                this.success.add(_elem1040);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1041 in this.success) {
          elem1041.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPreviousMessages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProfile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProfile_args");



  getProfile_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProfile_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProfile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProfile_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Profile _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProfile_result() {
  }

  // success
  Profile get success => this._success;

  set success(Profile success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Profile();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProfile_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProximityMatchCandidateList_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProximityMatchCandidateList_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  getProximityMatchCandidateList_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProximityMatchCandidateList_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProximityMatchCandidateList_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProximityMatchCandidateList_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProximityMatchCandidateResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProximityMatchCandidateList_result() {
  }

  // success
  ProximityMatchCandidateResult get success => this._success;

  set success(ProximityMatchCandidateResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProximityMatchCandidateResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProximityMatchCandidateList_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProximityMatchCandidates_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProximityMatchCandidates_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  getProximityMatchCandidates_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProximityMatchCandidates_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProximityMatchCandidates_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProximityMatchCandidates_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.SET, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Set<Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProximityMatchCandidates_result() {
  }

  // success
  Set<Contact> get success => this._success;

  set success(Set<Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.SET) {
            {
              TSet _set1042 = iprot.readSetBegin();
              this.success = new Set<Contact>();
              for (int _i1043 = 0; _i1043 < _set1042.length; ++_i1043) {
                Contact _elem1044;
                _elem1044 = new Contact();
                _elem1044.read(iprot);
                this.success.add(_elem1044);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.STRUCT, this.success.length));
        for (var elem1045 in this.success) {
          elem1045.write(oprot);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProximityMatchCandidates_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRecentMessages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRecentMessages_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);
  static final TField _MESSAGES_COUNT_FIELD_DESC = new TField("messagesCount", TType.I32, 3);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;
  int _messagesCount = 0;
  static const int MESSAGESCOUNT = 3;

  bool __isset_messagesCount = false;

  getRecentMessages_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // messagesCount
  int get messagesCount => this._messagesCount;

  set messagesCount(int messagesCount) {
    this._messagesCount = messagesCount;
    this.__isset_messagesCount = true;
  }

  bool isSetMessagesCount() => this.__isset_messagesCount;

  unsetMessagesCount() {
    this.__isset_messagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      case MESSAGESCOUNT:
        return this.messagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case MESSAGESCOUNT:
        if (value == null) {
          unsetMessagesCount();
        } else {
          this.messagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case MESSAGESCOUNT:
        return isSetMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.messagesCount = iprot.readI32();
            this.__isset_messagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.messagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRecentMessages_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("messagesCount:");
    ret.write(this.messagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRecentMessages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRecentMessages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRecentMessages_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1046 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1047 = 0; _i1047 < _list1046.length; ++_i1047) {
                Message _elem1048;
                _elem1048 = new Message();
                _elem1048.read(iprot);
                this.success.add(_elem1048);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1049 in this.success) {
          elem1049.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRecentMessages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRecommendationIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRecommendationIds_args");



  getRecommendationIds_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRecommendationIds_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRecommendationIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRecommendationIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRecommendationIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1050 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1051 = 0; _i1051 < _list1050.length; ++_i1051) {
                String _elem1052;
                _elem1052 = iprot.readString();
                this.success.add(_elem1052);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1053 in this.success) {
          oprot.writeString(elem1053);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRecommendationIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRoom_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRoom_args");
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 2);

  String _roomId;
  static const int ROOMID = 2;


  getRoom_args() {
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return this.roomId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return isSetRoomId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRoom_args(");

    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRoom_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRoom_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Room _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRoom_result() {
  }

  // success
  Room get success => this._success;

  set success(Room success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Room();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRoom_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRSAKeyInfo_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRSAKeyInfo_args");
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 2);

  int _provider;
  static const int PROVIDER = 2;

  bool __isset_provider = false;

  getRSAKeyInfo_args() {
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return this.provider;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return isSetProvider();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRSAKeyInfo_args(");

    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class getRSAKeyInfo_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRSAKeyInfo_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  RSAKey _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRSAKeyInfo_result() {
  }

  // success
  RSAKey get success => this._success;

  set success(RSAKey success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RSAKey();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRSAKeyInfo_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getServerTime_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getServerTime_args");



  getServerTime_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getServerTime_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getServerTime_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getServerTime_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  getServerTime_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getServerTime_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSessions_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSessions_args");



  getSessions_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSessions_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSessions_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSessions_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<LoginSession> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getSessions_result() {
  }

  // success
  List<LoginSession> get success => this._success;

  set success(List<LoginSession> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1054 = iprot.readListBegin();
              this.success = new List<LoginSession>();
              for (int _i1055 = 0; _i1055 < _list1054.length; ++_i1055) {
                LoginSession _elem1056;
                _elem1056 = new LoginSession();
                _elem1056.read(iprot);
                this.success.add(_elem1056);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1057 in this.success) {
          elem1057.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSessions_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSettings_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSettings_args");



  getSettings_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSettings_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSettings_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSettings_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Settings _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getSettings_result() {
  }

  // success
  Settings get success => this._success;

  set success(Settings success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Settings();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSettings_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupsV2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupsV2_args");
  static final TField _GROUP_IDS_FIELD_DESC = new TField("groupIds", TType.LIST, 2);

  List<String> _groupIds;
  static const int GROUPIDS = 2;


  getGroupsV2_args() {
  }

  // groupIds
  List<String> get groupIds => this._groupIds;

  set groupIds(List<String> groupIds) {
    this._groupIds = groupIds;
  }

  bool isSetGroupIds() => this.groupIds != null;

  unsetGroupIds() {
    this.groupIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPIDS:
        return this.groupIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPIDS:
        if (value == null) {
          unsetGroupIds();
        } else {
          this.groupIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPIDS:
        return isSetGroupIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1058 = iprot.readListBegin();
              this.groupIds = new List<String>();
              for (int _i1059 = 0; _i1059 < _list1058.length; ++_i1059) {
                String _elem1060;
                _elem1060 = iprot.readString();
                this.groupIds.add(_elem1060);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupIds != null) {
      oprot.writeFieldBegin(_GROUP_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.groupIds.length));
        for (var elem1061 in this.groupIds) {
          oprot.writeString(elem1061);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupsV2_args(");

    ret.write("groupIds:");
    if (this.groupIds == null) {
      ret.write("null");
    } else {
      ret.write(this.groupIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupsV2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupsV2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Group> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupsV2_result() {
  }

  // success
  List<Group> get success => this._success;

  set success(List<Group> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1062 = iprot.readListBegin();
              this.success = new List<Group>();
              for (int _i1063 = 0; _i1063 < _list1062.length; ++_i1063) {
                Group _elem1064;
                _elem1064 = new Group();
                _elem1064.read(iprot);
                this.success.add(_elem1064);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1065 in this.success) {
          elem1065.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupsV2_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSettingsAttributes_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSettingsAttributes_args");
  static final TField _ATTR_BITSET_FIELD_DESC = new TField("attrBitset", TType.I32, 2);

  int _attrBitset = 0;
  static const int ATTRBITSET = 2;

  bool __isset_attrBitset = false;

  getSettingsAttributes_args() {
  }

  // attrBitset
  int get attrBitset => this._attrBitset;

  set attrBitset(int attrBitset) {
    this._attrBitset = attrBitset;
    this.__isset_attrBitset = true;
  }

  bool isSetAttrBitset() => this.__isset_attrBitset;

  unsetAttrBitset() {
    this.__isset_attrBitset = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ATTRBITSET:
        return this.attrBitset;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ATTRBITSET:
        if (value == null) {
          unsetAttrBitset();
        } else {
          this.attrBitset = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ATTRBITSET:
        return isSetAttrBitset();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ATTRBITSET:
          if (field.type == TType.I32) {
            this.attrBitset = iprot.readI32();
            this.__isset_attrBitset = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ATTR_BITSET_FIELD_DESC);
    oprot.writeI32(this.attrBitset);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSettingsAttributes_args(");

    ret.write("attrBitset:");
    ret.write(this.attrBitset);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSettingsAttributes_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSettingsAttributes_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Settings _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getSettingsAttributes_result() {
  }

  // success
  Settings get success => this._success;

  set success(Settings success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Settings();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSettingsAttributes_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSystemConfiguration_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSystemConfiguration_args");



  getSystemConfiguration_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSystemConfiguration_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSystemConfiguration_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSystemConfiguration_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  SystemConfiguration _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getSystemConfiguration_result() {
  }

  // success
  SystemConfiguration get success => this._success;

  set success(SystemConfiguration success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SystemConfiguration();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSystemConfiguration_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserTicket_args");



  getUserTicket_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserTicket_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Ticket _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getUserTicket_result() {
  }

  // success
  Ticket get success => this._success;

  set success(Ticket success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Ticket();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getWapInvitation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getWapInvitation_args");
  static final TField _INVITATION_HASH_FIELD_DESC = new TField("invitationHash", TType.STRING, 2);

  String _invitationHash;
  static const int INVITATIONHASH = 2;


  getWapInvitation_args() {
  }

  // invitationHash
  String get invitationHash => this._invitationHash;

  set invitationHash(String invitationHash) {
    this._invitationHash = invitationHash;
  }

  bool isSetInvitationHash() => this.invitationHash != null;

  unsetInvitationHash() {
    this.invitationHash = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case INVITATIONHASH:
        return this.invitationHash;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case INVITATIONHASH:
        if (value == null) {
          unsetInvitationHash();
        } else {
          this.invitationHash = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case INVITATIONHASH:
        return isSetInvitationHash();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case INVITATIONHASH:
          if (field.type == TType.STRING) {
            this.invitationHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.invitationHash != null) {
      oprot.writeFieldBegin(_INVITATION_HASH_FIELD_DESC);
      oprot.writeString(this.invitationHash);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getWapInvitation_args(");

    ret.write("invitationHash:");
    if (this.invitationHash == null) {
      ret.write("null");
    } else {
      ret.write(this.invitationHash);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getWapInvitation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getWapInvitation_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  WapInvitation _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getWapInvitation_result() {
  }

  // success
  WapInvitation get success => this._success;

  set success(WapInvitation success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new WapInvitation();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getWapInvitation_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class invalidateUserTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("invalidateUserTicket_args");



  invalidateUserTicket_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("invalidateUserTicket_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class invalidateUserTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("invalidateUserTicket_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  invalidateUserTicket_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("invalidateUserTicket_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteFriendsBySms_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteFriendsBySms_args");
  static final TField _PHONE_NUMBER_LIST_FIELD_DESC = new TField("phoneNumberList", TType.LIST, 2);

  List<String> _phoneNumberList;
  static const int PHONENUMBERLIST = 2;


  inviteFriendsBySms_args() {
  }

  // phoneNumberList
  List<String> get phoneNumberList => this._phoneNumberList;

  set phoneNumberList(List<String> phoneNumberList) {
    this._phoneNumberList = phoneNumberList;
  }

  bool isSetPhoneNumberList() => this.phoneNumberList != null;

  unsetPhoneNumberList() {
    this.phoneNumberList = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PHONENUMBERLIST:
        return this.phoneNumberList;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PHONENUMBERLIST:
        if (value == null) {
          unsetPhoneNumberList();
        } else {
          this.phoneNumberList = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PHONENUMBERLIST:
        return isSetPhoneNumberList();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PHONENUMBERLIST:
          if (field.type == TType.LIST) {
            {
              TList _list1066 = iprot.readListBegin();
              this.phoneNumberList = new List<String>();
              for (int _i1067 = 0; _i1067 < _list1066.length; ++_i1067) {
                String _elem1068;
                _elem1068 = iprot.readString();
                this.phoneNumberList.add(_elem1068);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.phoneNumberList != null) {
      oprot.writeFieldBegin(_PHONE_NUMBER_LIST_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.phoneNumberList.length));
        for (var elem1069 in this.phoneNumberList) {
          oprot.writeString(elem1069);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteFriendsBySms_args(");

    ret.write("phoneNumberList:");
    if (this.phoneNumberList == null) {
      ret.write("null");
    } else {
      ret.write(this.phoneNumberList);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteFriendsBySms_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteFriendsBySms_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  inviteFriendsBySms_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteFriendsBySms_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteIntoGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteIntoGroup_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupId;
  static const int GROUPID = 2;
  List<String> _contactIds;
  static const int CONTACTIDS = 3;

  bool __isset_reqSeq = false;

  inviteIntoGroup_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPID:
        return this.groupId;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPID:
        return isSetGroupId();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1070 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i1071 = 0; _i1071 < _list1070.length; ++_i1071) {
                String _elem1072;
                _elem1072 = iprot.readString();
                this.contactIds.add(_elem1072);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem1073 in this.contactIds) {
          oprot.writeString(elem1073);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteIntoGroup_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteIntoGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteIntoGroup_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  inviteIntoGroup_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteIntoGroup_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteIntoRoom_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteIntoRoom_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 2);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _roomId;
  static const int ROOMID = 2;
  List<String> _contactIds;
  static const int CONTACTIDS = 3;

  bool __isset_reqSeq = false;

  inviteIntoRoom_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ROOMID:
        return this.roomId;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ROOMID:
        return isSetRoomId();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1074 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i1075 = 0; _i1075 < _list1074.length; ++_i1075) {
                String _elem1076;
                _elem1076 = iprot.readString();
                this.contactIds.add(_elem1076);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem1077 in this.contactIds) {
          oprot.writeString(elem1077);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteIntoRoom_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteIntoRoom_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteIntoRoom_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  inviteIntoRoom_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteIntoRoom_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteViaEmail_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteViaEmail_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _EMAIL_FIELD_DESC = new TField("email", TType.STRING, 2);
  static final TField _NAME_FIELD_DESC = new TField("name", TType.STRING, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _email;
  static const int EMAIL = 2;
  String _name;
  static const int NAME = 3;

  bool __isset_reqSeq = false;

  inviteViaEmail_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // email
  String get email => this._email;

  set email(String email) {
    this._email = email;
  }

  bool isSetEmail() => this.email != null;

  unsetEmail() {
    this.email = null;
  }

  // name
  String get name => this._name;

  set name(String name) {
    this._name = name;
  }

  bool isSetName() => this.name != null;

  unsetName() {
    this.name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case EMAIL:
        return this.email;
      case NAME:
        return this.name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case EMAIL:
        if (value == null) {
          unsetEmail();
        } else {
          this.email = value;
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          this.name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case EMAIL:
        return isSetEmail();
      case NAME:
        return isSetName();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EMAIL:
          if (field.type == TType.STRING) {
            this.email = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NAME:
          if (field.type == TType.STRING) {
            this.name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.email != null) {
      oprot.writeFieldBegin(_EMAIL_FIELD_DESC);
      oprot.writeString(this.email);
      oprot.writeFieldEnd();
    }
    if (this.name != null) {
      oprot.writeFieldBegin(_NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteViaEmail_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("email:");
    if (this.email == null) {
      ret.write("null");
    } else {
      ret.write(this.email);
    }

    ret.write(", ");
    ret.write("name:");
    if (this.name == null) {
      ret.write("null");
    } else {
      ret.write(this.name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteViaEmail_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteViaEmail_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  inviteViaEmail_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteViaEmail_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isIdentityIdentifierAvailable_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isIdentityIdentifierAvailable_args");
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 3);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 2);

  int _provider;
  static const int PROVIDER = 3;
  String _identifier;
  static const int IDENTIFIER = 2;

  bool __isset_provider = false;

  isIdentityIdentifierAvailable_args() {
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return this.provider;
      case IDENTIFIER:
        return this.identifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return isSetProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isIdentityIdentifierAvailable_args(");

    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class isIdentityIdentifierAvailable_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isIdentityIdentifierAvailable_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  isIdentityIdentifierAvailable_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isIdentityIdentifierAvailable_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isUseridAvailable_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isUseridAvailable_args");
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);

  String _userid;
  static const int USERID = 2;


  isUseridAvailable_args() {
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERID:
        return this.userid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERID:
        return isSetUserid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isUseridAvailable_args(");

    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isUseridAvailable_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isUseridAvailable_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  isUseridAvailable_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isUseridAvailable_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class kickoutFromGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("kickoutFromGroup_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupId;
  static const int GROUPID = 2;
  List<String> _contactIds;
  static const int CONTACTIDS = 3;

  bool __isset_reqSeq = false;

  kickoutFromGroup_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPID:
        return this.groupId;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPID:
        return isSetGroupId();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1078 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i1079 = 0; _i1079 < _list1078.length; ++_i1079) {
                String _elem1080;
                _elem1080 = iprot.readString();
                this.contactIds.add(_elem1080);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem1081 in this.contactIds) {
          oprot.writeString(elem1081);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("kickoutFromGroup_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class kickoutFromGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("kickoutFromGroup_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  kickoutFromGroup_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("kickoutFromGroup_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reissueGroupTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reissueGroupTicket_args");
  static final TField _GROUP_MID_FIELD_DESC = new TField("groupMid", TType.STRING, 1);

  String _groupMid;
  static const int GROUPMID = 1;


  reissueGroupTicket_args() {
  }

  // groupMid
  String get groupMid => this._groupMid;

  set groupMid(String groupMid) {
    this._groupMid = groupMid;
  }

  bool isSetGroupMid() => this.groupMid != null;

  unsetGroupMid() {
    this.groupMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPMID:
        return this.groupMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPMID:
        if (value == null) {
          unsetGroupMid();
        } else {
          this.groupMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPMID:
        return isSetGroupMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPMID:
          if (field.type == TType.STRING) {
            this.groupMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupMid != null) {
      oprot.writeFieldBegin(_GROUP_MID_FIELD_DESC);
      oprot.writeString(this.groupMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reissueGroupTicket_args(");

    ret.write("groupMid:");
    if (this.groupMid == null) {
      ret.write("null");
    } else {
      ret.write(this.groupMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reissueGroupTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reissueGroupTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reissueGroupTicket_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reissueGroupTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findGroupByTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findGroupByTicket_args");
  static final TField _TICKET_ID_FIELD_DESC = new TField("ticketId", TType.STRING, 1);

  String _ticketId;
  static const int TICKETID = 1;


  findGroupByTicket_args() {
  }

  // ticketId
  String get ticketId => this._ticketId;

  set ticketId(String ticketId) {
    this._ticketId = ticketId;
  }

  bool isSetTicketId() => this.ticketId != null;

  unsetTicketId() {
    this.ticketId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TICKETID:
        return this.ticketId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TICKETID:
        if (value == null) {
          unsetTicketId();
        } else {
          this.ticketId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TICKETID:
        return isSetTicketId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TICKETID:
          if (field.type == TType.STRING) {
            this.ticketId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ticketId != null) {
      oprot.writeFieldBegin(_TICKET_ID_FIELD_DESC);
      oprot.writeString(this.ticketId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findGroupByTicket_args(");

    ret.write("ticketId:");
    if (this.ticketId == null) {
      ret.write("null");
    } else {
      ret.write(this.ticketId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findGroupByTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findGroupByTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Group _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findGroupByTicket_result() {
  }

  // success
  Group get success => this._success;

  set success(Group success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Group();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findGroupByTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class leaveGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("leaveGroup_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupId;
  static const int GROUPID = 2;

  bool __isset_reqSeq = false;

  leaveGroup_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("leaveGroup_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class leaveGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("leaveGroup_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  leaveGroup_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("leaveGroup_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class leaveRoom_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("leaveRoom_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _roomId;
  static const int ROOMID = 2;

  bool __isset_reqSeq = false;

  leaveRoom_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ROOMID:
        return this.roomId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ROOMID:
        return isSetRoomId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("leaveRoom_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class leaveRoom_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("leaveRoom_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  leaveRoom_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("leaveRoom_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithIdentityCredential_args");
  static final TField _IDENTITY_PROVIDER_FIELD_DESC = new TField("identityProvider", TType.I32, 8);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 3);
  static final TField _PASSWORD_FIELD_DESC = new TField("password", TType.STRING, 4);
  static final TField _KEEP_LOGGED_IN_FIELD_DESC = new TField("keepLoggedIn", TType.BOOL, 5);
  static final TField _ACCESS_LOCATION_FIELD_DESC = new TField("accessLocation", TType.STRING, 6);
  static final TField _SYSTEM_NAME_FIELD_DESC = new TField("systemName", TType.STRING, 7);
  static final TField _CERTIFICATE_FIELD_DESC = new TField("certificate", TType.STRING, 9);

  int _identityProvider;
  static const int IDENTITYPROVIDER = 8;
  String _identifier;
  static const int IDENTIFIER = 3;
  String _password;
  static const int PASSWORD = 4;
  bool _keepLoggedIn = false;
  static const int KEEPLOGGEDIN = 5;
  String _accessLocation;
  static const int ACCESSLOCATION = 6;
  String _systemName;
  static const int SYSTEMNAME = 7;
  String _certificate;
  static const int CERTIFICATE = 9;

  bool __isset_identityProvider = false;
  bool __isset_keepLoggedIn = false;

  loginWithIdentityCredential_args() {
  }

  // identityProvider
  int get identityProvider => this._identityProvider;

  set identityProvider(int identityProvider) {
    this._identityProvider = identityProvider;
    this.__isset_identityProvider = true;
  }

  bool isSetIdentityProvider() => this.__isset_identityProvider;

  unsetIdentityProvider() {
    this.__isset_identityProvider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // password
  String get password => this._password;

  set password(String password) {
    this._password = password;
  }

  bool isSetPassword() => this.password != null;

  unsetPassword() {
    this.password = null;
  }

  // keepLoggedIn
  bool get keepLoggedIn => this._keepLoggedIn;

  set keepLoggedIn(bool keepLoggedIn) {
    this._keepLoggedIn = keepLoggedIn;
    this.__isset_keepLoggedIn = true;
  }

  bool isSetKeepLoggedIn() => this.__isset_keepLoggedIn;

  unsetKeepLoggedIn() {
    this.__isset_keepLoggedIn = false;
  }

  // accessLocation
  String get accessLocation => this._accessLocation;

  set accessLocation(String accessLocation) {
    this._accessLocation = accessLocation;
  }

  bool isSetAccessLocation() => this.accessLocation != null;

  unsetAccessLocation() {
    this.accessLocation = null;
  }

  // systemName
  String get systemName => this._systemName;

  set systemName(String systemName) {
    this._systemName = systemName;
  }

  bool isSetSystemName() => this.systemName != null;

  unsetSystemName() {
    this.systemName = null;
  }

  // certificate
  String get certificate => this._certificate;

  set certificate(String certificate) {
    this._certificate = certificate;
  }

  bool isSetCertificate() => this.certificate != null;

  unsetCertificate() {
    this.certificate = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        return this.identityProvider;
      case IDENTIFIER:
        return this.identifier;
      case PASSWORD:
        return this.password;
      case KEEPLOGGEDIN:
        return this.keepLoggedIn;
      case ACCESSLOCATION:
        return this.accessLocation;
      case SYSTEMNAME:
        return this.systemName;
      case CERTIFICATE:
        return this.certificate;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        if (value == null) {
          unsetIdentityProvider();
        } else {
          this.identityProvider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          this.password = value;
        }
        break;

      case KEEPLOGGEDIN:
        if (value == null) {
          unsetKeepLoggedIn();
        } else {
          this.keepLoggedIn = value;
        }
        break;

      case ACCESSLOCATION:
        if (value == null) {
          unsetAccessLocation();
        } else {
          this.accessLocation = value;
        }
        break;

      case SYSTEMNAME:
        if (value == null) {
          unsetSystemName();
        } else {
          this.systemName = value;
        }
        break;

      case CERTIFICATE:
        if (value == null) {
          unsetCertificate();
        } else {
          this.certificate = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        return isSetIdentityProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      case PASSWORD:
        return isSetPassword();
      case KEEPLOGGEDIN:
        return isSetKeepLoggedIn();
      case ACCESSLOCATION:
        return isSetAccessLocation();
      case SYSTEMNAME:
        return isSetSystemName();
      case CERTIFICATE:
        return isSetCertificate();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDENTITYPROVIDER:
          if (field.type == TType.I32) {
            this.identityProvider = iprot.readI32();
            this.__isset_identityProvider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PASSWORD:
          if (field.type == TType.STRING) {
            this.password = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEEPLOGGEDIN:
          if (field.type == TType.BOOL) {
            this.keepLoggedIn = iprot.readBool();
            this.__isset_keepLoggedIn = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ACCESSLOCATION:
          if (field.type == TType.STRING) {
            this.accessLocation = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMNAME:
          if (field.type == TType.STRING) {
            this.systemName = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CERTIFICATE:
          if (field.type == TType.STRING) {
            this.certificate = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    if (this.password != null) {
      oprot.writeFieldBegin(_PASSWORD_FIELD_DESC);
      oprot.writeString(this.password);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_KEEP_LOGGED_IN_FIELD_DESC);
    oprot.writeBool(this.keepLoggedIn);
    oprot.writeFieldEnd();
    if (this.accessLocation != null) {
      oprot.writeFieldBegin(_ACCESS_LOCATION_FIELD_DESC);
      oprot.writeString(this.accessLocation);
      oprot.writeFieldEnd();
    }
    if (this.systemName != null) {
      oprot.writeFieldBegin(_SYSTEM_NAME_FIELD_DESC);
      oprot.writeString(this.systemName);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_IDENTITY_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.identityProvider);
    oprot.writeFieldEnd();
    if (this.certificate != null) {
      oprot.writeFieldBegin(_CERTIFICATE_FIELD_DESC);
      oprot.writeString(this.certificate);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithIdentityCredential_args(");

    ret.write("identityProvider:");
    String identityProvider_name = IdentityProvider.VALUES_TO_NAMES[this.identityProvider];
    if (identityProvider_name != null) {
      ret.write(identityProvider_name);
      ret.write(" (");
    }
    ret.write(this.identityProvider);
    if (identityProvider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("password:");
    if (this.password == null) {
      ret.write("null");
    } else {
      ret.write(this.password);
    }

    ret.write(", ");
    ret.write("keepLoggedIn:");
    ret.write(this.keepLoggedIn);

    ret.write(", ");
    ret.write("accessLocation:");
    if (this.accessLocation == null) {
      ret.write("null");
    } else {
      ret.write(this.accessLocation);
    }

    ret.write(", ");
    ret.write("systemName:");
    if (this.systemName == null) {
      ret.write("null");
    } else {
      ret.write(this.systemName);
    }

    ret.write(", ");
    ret.write("certificate:");
    if (this.certificate == null) {
      ret.write("null");
    } else {
      ret.write(this.certificate);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetIdentityProvider() && !IdentityProvider.VALID_VALUES.contains(identityProvider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'identityProvider' has been assigned the invalid value $identityProvider");
    }
  }

}

class loginWithIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithIdentityCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  loginWithIdentityCredential_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithIdentityCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithIdentityCredentialForCertificate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithIdentityCredentialForCertificate_args");
  static final TField _IDENTITY_PROVIDER_FIELD_DESC = new TField("identityProvider", TType.I32, 8);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 3);
  static final TField _PASSWORD_FIELD_DESC = new TField("password", TType.STRING, 4);
  static final TField _KEEP_LOGGED_IN_FIELD_DESC = new TField("keepLoggedIn", TType.BOOL, 5);
  static final TField _ACCESS_LOCATION_FIELD_DESC = new TField("accessLocation", TType.STRING, 6);
  static final TField _SYSTEM_NAME_FIELD_DESC = new TField("systemName", TType.STRING, 7);
  static final TField _CERTIFICATE_FIELD_DESC = new TField("certificate", TType.STRING, 9);

  int _identityProvider;
  static const int IDENTITYPROVIDER = 8;
  String _identifier;
  static const int IDENTIFIER = 3;
  String _password;
  static const int PASSWORD = 4;
  bool _keepLoggedIn = false;
  static const int KEEPLOGGEDIN = 5;
  String _accessLocation;
  static const int ACCESSLOCATION = 6;
  String _systemName;
  static const int SYSTEMNAME = 7;
  String _certificate;
  static const int CERTIFICATE = 9;

  bool __isset_identityProvider = false;
  bool __isset_keepLoggedIn = false;

  loginWithIdentityCredentialForCertificate_args() {
  }

  // identityProvider
  int get identityProvider => this._identityProvider;

  set identityProvider(int identityProvider) {
    this._identityProvider = identityProvider;
    this.__isset_identityProvider = true;
  }

  bool isSetIdentityProvider() => this.__isset_identityProvider;

  unsetIdentityProvider() {
    this.__isset_identityProvider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // password
  String get password => this._password;

  set password(String password) {
    this._password = password;
  }

  bool isSetPassword() => this.password != null;

  unsetPassword() {
    this.password = null;
  }

  // keepLoggedIn
  bool get keepLoggedIn => this._keepLoggedIn;

  set keepLoggedIn(bool keepLoggedIn) {
    this._keepLoggedIn = keepLoggedIn;
    this.__isset_keepLoggedIn = true;
  }

  bool isSetKeepLoggedIn() => this.__isset_keepLoggedIn;

  unsetKeepLoggedIn() {
    this.__isset_keepLoggedIn = false;
  }

  // accessLocation
  String get accessLocation => this._accessLocation;

  set accessLocation(String accessLocation) {
    this._accessLocation = accessLocation;
  }

  bool isSetAccessLocation() => this.accessLocation != null;

  unsetAccessLocation() {
    this.accessLocation = null;
  }

  // systemName
  String get systemName => this._systemName;

  set systemName(String systemName) {
    this._systemName = systemName;
  }

  bool isSetSystemName() => this.systemName != null;

  unsetSystemName() {
    this.systemName = null;
  }

  // certificate
  String get certificate => this._certificate;

  set certificate(String certificate) {
    this._certificate = certificate;
  }

  bool isSetCertificate() => this.certificate != null;

  unsetCertificate() {
    this.certificate = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        return this.identityProvider;
      case IDENTIFIER:
        return this.identifier;
      case PASSWORD:
        return this.password;
      case KEEPLOGGEDIN:
        return this.keepLoggedIn;
      case ACCESSLOCATION:
        return this.accessLocation;
      case SYSTEMNAME:
        return this.systemName;
      case CERTIFICATE:
        return this.certificate;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        if (value == null) {
          unsetIdentityProvider();
        } else {
          this.identityProvider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          this.password = value;
        }
        break;

      case KEEPLOGGEDIN:
        if (value == null) {
          unsetKeepLoggedIn();
        } else {
          this.keepLoggedIn = value;
        }
        break;

      case ACCESSLOCATION:
        if (value == null) {
          unsetAccessLocation();
        } else {
          this.accessLocation = value;
        }
        break;

      case SYSTEMNAME:
        if (value == null) {
          unsetSystemName();
        } else {
          this.systemName = value;
        }
        break;

      case CERTIFICATE:
        if (value == null) {
          unsetCertificate();
        } else {
          this.certificate = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        return isSetIdentityProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      case PASSWORD:
        return isSetPassword();
      case KEEPLOGGEDIN:
        return isSetKeepLoggedIn();
      case ACCESSLOCATION:
        return isSetAccessLocation();
      case SYSTEMNAME:
        return isSetSystemName();
      case CERTIFICATE:
        return isSetCertificate();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDENTITYPROVIDER:
          if (field.type == TType.I32) {
            this.identityProvider = iprot.readI32();
            this.__isset_identityProvider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PASSWORD:
          if (field.type == TType.STRING) {
            this.password = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEEPLOGGEDIN:
          if (field.type == TType.BOOL) {
            this.keepLoggedIn = iprot.readBool();
            this.__isset_keepLoggedIn = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ACCESSLOCATION:
          if (field.type == TType.STRING) {
            this.accessLocation = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMNAME:
          if (field.type == TType.STRING) {
            this.systemName = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CERTIFICATE:
          if (field.type == TType.STRING) {
            this.certificate = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    if (this.password != null) {
      oprot.writeFieldBegin(_PASSWORD_FIELD_DESC);
      oprot.writeString(this.password);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_KEEP_LOGGED_IN_FIELD_DESC);
    oprot.writeBool(this.keepLoggedIn);
    oprot.writeFieldEnd();
    if (this.accessLocation != null) {
      oprot.writeFieldBegin(_ACCESS_LOCATION_FIELD_DESC);
      oprot.writeString(this.accessLocation);
      oprot.writeFieldEnd();
    }
    if (this.systemName != null) {
      oprot.writeFieldBegin(_SYSTEM_NAME_FIELD_DESC);
      oprot.writeString(this.systemName);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_IDENTITY_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.identityProvider);
    oprot.writeFieldEnd();
    if (this.certificate != null) {
      oprot.writeFieldBegin(_CERTIFICATE_FIELD_DESC);
      oprot.writeString(this.certificate);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithIdentityCredentialForCertificate_args(");

    ret.write("identityProvider:");
    String identityProvider_name = IdentityProvider.VALUES_TO_NAMES[this.identityProvider];
    if (identityProvider_name != null) {
      ret.write(identityProvider_name);
      ret.write(" (");
    }
    ret.write(this.identityProvider);
    if (identityProvider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("password:");
    if (this.password == null) {
      ret.write("null");
    } else {
      ret.write(this.password);
    }

    ret.write(", ");
    ret.write("keepLoggedIn:");
    ret.write(this.keepLoggedIn);

    ret.write(", ");
    ret.write("accessLocation:");
    if (this.accessLocation == null) {
      ret.write("null");
    } else {
      ret.write(this.accessLocation);
    }

    ret.write(", ");
    ret.write("systemName:");
    if (this.systemName == null) {
      ret.write("null");
    } else {
      ret.write(this.systemName);
    }

    ret.write(", ");
    ret.write("certificate:");
    if (this.certificate == null) {
      ret.write("null");
    } else {
      ret.write(this.certificate);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetIdentityProvider() && !IdentityProvider.VALID_VALUES.contains(identityProvider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'identityProvider' has been assigned the invalid value $identityProvider");
    }
  }

}

class loginWithIdentityCredentialForCertificate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithIdentityCredentialForCertificate_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  LoginResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  loginWithIdentityCredentialForCertificate_result() {
  }

  // success
  LoginResult get success => this._success;

  set success(LoginResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new LoginResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithIdentityCredentialForCertificate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithVerifier_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithVerifier_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 3);

  String _verifier;
  static const int VERIFIER = 3;


  loginWithVerifier_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithVerifier_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithVerifier_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithVerifier_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  loginWithVerifier_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithVerifier_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithVerifierForCerificate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithVerifierForCerificate_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 3);

  String _verifier;
  static const int VERIFIER = 3;


  loginWithVerifierForCerificate_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithVerifierForCerificate_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithVerifierForCerificate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithVerifierForCerificate_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  LoginResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  loginWithVerifierForCerificate_result() {
  }

  // success
  LoginResult get success => this._success;

  set success(LoginResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new LoginResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithVerifierForCerificate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithVerifierForCertificate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithVerifierForCertificate_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 3);

  String _verifier;
  static const int VERIFIER = 3;


  loginWithVerifierForCertificate_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithVerifierForCertificate_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class loginWithVerifierForCertificate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("loginWithVerifierForCertificate_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  LoginResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  loginWithVerifierForCertificate_result() {
  }

  // success
  LoginResult get success => this._success;

  set success(LoginResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new LoginResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("loginWithVerifierForCertificate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class logout_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("logout_args");



  logout_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("logout_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class logout_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("logout_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  logout_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("logout_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class logoutSession_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("logoutSession_args");
  static final TField _TOKEN_KEY_FIELD_DESC = new TField("tokenKey", TType.STRING, 2);

  String _tokenKey;
  static const int TOKENKEY = 2;


  logoutSession_args() {
  }

  // tokenKey
  String get tokenKey => this._tokenKey;

  set tokenKey(String tokenKey) {
    this._tokenKey = tokenKey;
  }

  bool isSetTokenKey() => this.tokenKey != null;

  unsetTokenKey() {
    this.tokenKey = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TOKENKEY:
        return this.tokenKey;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TOKENKEY:
        if (value == null) {
          unsetTokenKey();
        } else {
          this.tokenKey = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TOKENKEY:
        return isSetTokenKey();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKENKEY:
          if (field.type == TType.STRING) {
            this.tokenKey = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.tokenKey != null) {
      oprot.writeFieldBegin(_TOKEN_KEY_FIELD_DESC);
      oprot.writeString(this.tokenKey);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("logoutSession_args(");

    ret.write("tokenKey:");
    if (this.tokenKey == null) {
      ret.write("null");
    } else {
      ret.write(this.tokenKey);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class logoutSession_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("logoutSession_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  logoutSession_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("logoutSession_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class noop_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("noop_args");



  noop_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("noop_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class noop_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("noop_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  noop_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("noop_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifiedRedirect_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifiedRedirect_args");
  static final TField _PARAM_MAP_FIELD_DESC = new TField("paramMap", TType.MAP, 2);

  Map<String, String> _paramMap;
  static const int PARAMMAP = 2;


  notifiedRedirect_args() {
  }

  // paramMap
  Map<String, String> get paramMap => this._paramMap;

  set paramMap(Map<String, String> paramMap) {
    this._paramMap = paramMap;
  }

  bool isSetParamMap() => this.paramMap != null;

  unsetParamMap() {
    this.paramMap = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PARAMMAP:
        return this.paramMap;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PARAMMAP:
        if (value == null) {
          unsetParamMap();
        } else {
          this.paramMap = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PARAMMAP:
        return isSetParamMap();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PARAMMAP:
          if (field.type == TType.MAP) {
            {
              TMap _map1082 = iprot.readMapBegin();
              this.paramMap = new Map<String, String>();
              for (int _i1083 = 0; _i1083 < _map1082.length; ++_i1083) {
                String _key1084;
                String _val1085;
                _key1084 = iprot.readString();
                _val1085 = iprot.readString();
                this.paramMap[_key1084] = _val1085;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.paramMap != null) {
      oprot.writeFieldBegin(_PARAM_MAP_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.paramMap.length));
        for (var elem1087 in this.paramMap.keys) {
          oprot.writeString(elem1087);
          oprot.writeString(this.paramMap[elem1087]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifiedRedirect_args(");

    ret.write("paramMap:");
    if (this.paramMap == null) {
      ret.write("null");
    } else {
      ret.write(this.paramMap);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifiedRedirect_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifiedRedirect_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifiedRedirect_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifiedRedirect_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyBuddyOnAir_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyBuddyOnAir_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _RECEIVER_MIDS_FIELD_DESC = new TField("receiverMids", TType.LIST, 2);

  int _seq = 0;
  static const int SEQ = 1;
  List<String> _receiverMids;
  static const int RECEIVERMIDS = 2;

  bool __isset_seq = false;

  notifyBuddyOnAir_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // receiverMids
  List<String> get receiverMids => this._receiverMids;

  set receiverMids(List<String> receiverMids) {
    this._receiverMids = receiverMids;
  }

  bool isSetReceiverMids() => this.receiverMids != null;

  unsetReceiverMids() {
    this.receiverMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case RECEIVERMIDS:
        return this.receiverMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case RECEIVERMIDS:
        if (value == null) {
          unsetReceiverMids();
        } else {
          this.receiverMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case RECEIVERMIDS:
        return isSetReceiverMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1088 = iprot.readListBegin();
              this.receiverMids = new List<String>();
              for (int _i1089 = 0; _i1089 < _list1088.length; ++_i1089) {
                String _elem1090;
                _elem1090 = iprot.readString();
                this.receiverMids.add(_elem1090);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.receiverMids != null) {
      oprot.writeFieldBegin(_RECEIVER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.receiverMids.length));
        for (var elem1091 in this.receiverMids) {
          oprot.writeString(elem1091);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyBuddyOnAir_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("receiverMids:");
    if (this.receiverMids == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyBuddyOnAir_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyBuddyOnAir_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  notifyBuddyOnAir_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1092 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i1093 = 0; _i1093 < _map1092.length; ++_i1093) {
                String _key1094;
                String _val1095;
                _key1094 = iprot.readString();
                _val1095 = iprot.readString();
                this.success[_key1094] = _val1095;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem1097 in this.success.keys) {
          oprot.writeString(elem1097);
          oprot.writeString(this.success[elem1097]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyBuddyOnAir_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyIndividualEvent_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyIndividualEvent_args");
  static final TField _NOTIFICATION_STATUS_FIELD_DESC = new TField("notificationStatus", TType.I32, 2);
  static final TField _RECEIVER_MIDS_FIELD_DESC = new TField("receiverMids", TType.LIST, 3);

  int _notificationStatus;
  static const int NOTIFICATIONSTATUS = 2;
  List<String> _receiverMids;
  static const int RECEIVERMIDS = 3;

  bool __isset_notificationStatus = false;

  notifyIndividualEvent_args() {
  }

  // notificationStatus
  int get notificationStatus => this._notificationStatus;

  set notificationStatus(int notificationStatus) {
    this._notificationStatus = notificationStatus;
    this.__isset_notificationStatus = true;
  }

  bool isSetNotificationStatus() => this.__isset_notificationStatus;

  unsetNotificationStatus() {
    this.__isset_notificationStatus = false;
  }

  // receiverMids
  List<String> get receiverMids => this._receiverMids;

  set receiverMids(List<String> receiverMids) {
    this._receiverMids = receiverMids;
  }

  bool isSetReceiverMids() => this.receiverMids != null;

  unsetReceiverMids() {
    this.receiverMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case NOTIFICATIONSTATUS:
        return this.notificationStatus;
      case RECEIVERMIDS:
        return this.receiverMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case NOTIFICATIONSTATUS:
        if (value == null) {
          unsetNotificationStatus();
        } else {
          this.notificationStatus = value;
        }
        break;

      case RECEIVERMIDS:
        if (value == null) {
          unsetReceiverMids();
        } else {
          this.receiverMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case NOTIFICATIONSTATUS:
        return isSetNotificationStatus();
      case RECEIVERMIDS:
        return isSetReceiverMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case NOTIFICATIONSTATUS:
          if (field.type == TType.I32) {
            this.notificationStatus = iprot.readI32();
            this.__isset_notificationStatus = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1098 = iprot.readListBegin();
              this.receiverMids = new List<String>();
              for (int _i1099 = 0; _i1099 < _list1098.length; ++_i1099) {
                String _elem1100;
                _elem1100 = iprot.readString();
                this.receiverMids.add(_elem1100);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_NOTIFICATION_STATUS_FIELD_DESC);
    oprot.writeI32(this.notificationStatus);
    oprot.writeFieldEnd();
    if (this.receiverMids != null) {
      oprot.writeFieldBegin(_RECEIVER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.receiverMids.length));
        for (var elem1101 in this.receiverMids) {
          oprot.writeString(elem1101);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyIndividualEvent_args(");

    ret.write("notificationStatus:");
    String notificationStatus_name = NotificationStatus.VALUES_TO_NAMES[this.notificationStatus];
    if (notificationStatus_name != null) {
      ret.write(notificationStatus_name);
      ret.write(" (");
    }
    ret.write(this.notificationStatus);
    if (notificationStatus_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("receiverMids:");
    if (this.receiverMids == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetNotificationStatus() && !NotificationStatus.VALID_VALUES.contains(notificationStatus)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'notificationStatus' has been assigned the invalid value $notificationStatus");
    }
  }

}

class notifyIndividualEvent_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyIndividualEvent_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifyIndividualEvent_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyIndividualEvent_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyInstalled_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyInstalled_args");
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 2);
  static final TField _APPLICATION_TYPE_WITH_EXTENSIONS_FIELD_DESC = new TField("applicationTypeWithExtensions", TType.STRING, 3);

  String _udidHash;
  static const int UDIDHASH = 2;
  String _applicationTypeWithExtensions;
  static const int APPLICATIONTYPEWITHEXTENSIONS = 3;


  notifyInstalled_args() {
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // applicationTypeWithExtensions
  String get applicationTypeWithExtensions => this._applicationTypeWithExtensions;

  set applicationTypeWithExtensions(String applicationTypeWithExtensions) {
    this._applicationTypeWithExtensions = applicationTypeWithExtensions;
  }

  bool isSetApplicationTypeWithExtensions() => this.applicationTypeWithExtensions != null;

  unsetApplicationTypeWithExtensions() {
    this.applicationTypeWithExtensions = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case UDIDHASH:
        return this.udidHash;
      case APPLICATIONTYPEWITHEXTENSIONS:
        return this.applicationTypeWithExtensions;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case APPLICATIONTYPEWITHEXTENSIONS:
        if (value == null) {
          unsetApplicationTypeWithExtensions();
        } else {
          this.applicationTypeWithExtensions = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case UDIDHASH:
        return isSetUdidHash();
      case APPLICATIONTYPEWITHEXTENSIONS:
        return isSetApplicationTypeWithExtensions();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case APPLICATIONTYPEWITHEXTENSIONS:
          if (field.type == TType.STRING) {
            this.applicationTypeWithExtensions = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.applicationTypeWithExtensions != null) {
      oprot.writeFieldBegin(_APPLICATION_TYPE_WITH_EXTENSIONS_FIELD_DESC);
      oprot.writeString(this.applicationTypeWithExtensions);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyInstalled_args(");

    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("applicationTypeWithExtensions:");
    if (this.applicationTypeWithExtensions == null) {
      ret.write("null");
    } else {
      ret.write(this.applicationTypeWithExtensions);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyInstalled_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyInstalled_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifyInstalled_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyInstalled_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyRegistrationComplete_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyRegistrationComplete_args");
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 2);
  static final TField _APPLICATION_TYPE_WITH_EXTENSIONS_FIELD_DESC = new TField("applicationTypeWithExtensions", TType.STRING, 3);

  String _udidHash;
  static const int UDIDHASH = 2;
  String _applicationTypeWithExtensions;
  static const int APPLICATIONTYPEWITHEXTENSIONS = 3;


  notifyRegistrationComplete_args() {
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // applicationTypeWithExtensions
  String get applicationTypeWithExtensions => this._applicationTypeWithExtensions;

  set applicationTypeWithExtensions(String applicationTypeWithExtensions) {
    this._applicationTypeWithExtensions = applicationTypeWithExtensions;
  }

  bool isSetApplicationTypeWithExtensions() => this.applicationTypeWithExtensions != null;

  unsetApplicationTypeWithExtensions() {
    this.applicationTypeWithExtensions = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case UDIDHASH:
        return this.udidHash;
      case APPLICATIONTYPEWITHEXTENSIONS:
        return this.applicationTypeWithExtensions;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case APPLICATIONTYPEWITHEXTENSIONS:
        if (value == null) {
          unsetApplicationTypeWithExtensions();
        } else {
          this.applicationTypeWithExtensions = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case UDIDHASH:
        return isSetUdidHash();
      case APPLICATIONTYPEWITHEXTENSIONS:
        return isSetApplicationTypeWithExtensions();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case APPLICATIONTYPEWITHEXTENSIONS:
          if (field.type == TType.STRING) {
            this.applicationTypeWithExtensions = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.applicationTypeWithExtensions != null) {
      oprot.writeFieldBegin(_APPLICATION_TYPE_WITH_EXTENSIONS_FIELD_DESC);
      oprot.writeString(this.applicationTypeWithExtensions);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyRegistrationComplete_args(");

    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("applicationTypeWithExtensions:");
    if (this.applicationTypeWithExtensions == null) {
      ret.write("null");
    } else {
      ret.write(this.applicationTypeWithExtensions);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyRegistrationComplete_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyRegistrationComplete_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifyRegistrationComplete_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyRegistrationComplete_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifySleep_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifySleep_args");
  static final TField _LAST_REV_FIELD_DESC = new TField("lastRev", TType.I64, 2);
  static final TField _BADGE_FIELD_DESC = new TField("badge", TType.I32, 3);

  int _lastRev = 0;
  static const int LASTREV = 2;
  int _badge = 0;
  static const int BADGE = 3;

  bool __isset_lastRev = false;
  bool __isset_badge = false;

  notifySleep_args() {
  }

  // lastRev
  int get lastRev => this._lastRev;

  set lastRev(int lastRev) {
    this._lastRev = lastRev;
    this.__isset_lastRev = true;
  }

  bool isSetLastRev() => this.__isset_lastRev;

  unsetLastRev() {
    this.__isset_lastRev = false;
  }

  // badge
  int get badge => this._badge;

  set badge(int badge) {
    this._badge = badge;
    this.__isset_badge = true;
  }

  bool isSetBadge() => this.__isset_badge;

  unsetBadge() {
    this.__isset_badge = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTREV:
        return this.lastRev;
      case BADGE:
        return this.badge;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTREV:
        if (value == null) {
          unsetLastRev();
        } else {
          this.lastRev = value;
        }
        break;

      case BADGE:
        if (value == null) {
          unsetBadge();
        } else {
          this.badge = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTREV:
        return isSetLastRev();
      case BADGE:
        return isSetBadge();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTREV:
          if (field.type == TType.I64) {
            this.lastRev = iprot.readI64();
            this.__isset_lastRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case BADGE:
          if (field.type == TType.I32) {
            this.badge = iprot.readI32();
            this.__isset_badge = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_REV_FIELD_DESC);
    oprot.writeI64(this.lastRev);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_BADGE_FIELD_DESC);
    oprot.writeI32(this.badge);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifySleep_args(");

    ret.write("lastRev:");
    ret.write(this.lastRev);

    ret.write(", ");
    ret.write("badge:");
    ret.write(this.badge);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifySleep_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifySleep_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifySleep_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifySleep_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyUpdated_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyUpdated_args");
  static final TField _LAST_REV_FIELD_DESC = new TField("lastRev", TType.I64, 2);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 3);

  int _lastRev = 0;
  static const int LASTREV = 2;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 3;

  bool __isset_lastRev = false;

  notifyUpdated_args() {
  }

  // lastRev
  int get lastRev => this._lastRev;

  set lastRev(int lastRev) {
    this._lastRev = lastRev;
    this.__isset_lastRev = true;
  }

  bool isSetLastRev() => this.__isset_lastRev;

  unsetLastRev() {
    this.__isset_lastRev = false;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTREV:
        return this.lastRev;
      case DEVICEINFO:
        return this.deviceInfo;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTREV:
        if (value == null) {
          unsetLastRev();
        } else {
          this.lastRev = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTREV:
        return isSetLastRev();
      case DEVICEINFO:
        return isSetDeviceInfo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTREV:
          if (field.type == TType.I64) {
            this.lastRev = iprot.readI64();
            this.__isset_lastRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_REV_FIELD_DESC);
    oprot.writeI64(this.lastRev);
    oprot.writeFieldEnd();
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyUpdated_args(");

    ret.write("lastRev:");
    ret.write(this.lastRev);

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyUpdated_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyUpdated_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifyUpdated_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyUpdated_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class openProximityMatch_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("openProximityMatch_args");
  static final TField _LOCATION_FIELD_DESC = new TField("location", TType.STRUCT, 2);

  Location _location;
  static const int LOCATION = 2;


  openProximityMatch_args() {
  }

  // location
  Location get location => this._location;

  set location(Location location) {
    this._location = location;
  }

  bool isSetLocation() => this.location != null;

  unsetLocation() {
    this.location = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCATION:
        return this.location;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCATION:
        if (value == null) {
          unsetLocation();
        } else {
          this.location = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCATION:
        return isSetLocation();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCATION:
          if (field.type == TType.STRUCT) {
            this.location = new Location();
            this.location.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.location != null) {
      oprot.writeFieldBegin(_LOCATION_FIELD_DESC);
      this.location.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("openProximityMatch_args(");

    ret.write("location:");
    if (this.location == null) {
      ret.write("null");
    } else {
      ret.write(this.location);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class openProximityMatch_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("openProximityMatch_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  openProximityMatch_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("openProximityMatch_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerBuddyUser_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerBuddyUser_args");
  static final TField _BUDDY_ID_FIELD_DESC = new TField("buddyId", TType.STRING, 2);
  static final TField _REGISTRAR_PASSWORD_FIELD_DESC = new TField("registrarPassword", TType.STRING, 3);

  String _buddyId;
  static const int BUDDYID = 2;
  String _registrarPassword;
  static const int REGISTRARPASSWORD = 3;


  registerBuddyUser_args() {
  }

  // buddyId
  String get buddyId => this._buddyId;

  set buddyId(String buddyId) {
    this._buddyId = buddyId;
  }

  bool isSetBuddyId() => this.buddyId != null;

  unsetBuddyId() {
    this.buddyId = null;
  }

  // registrarPassword
  String get registrarPassword => this._registrarPassword;

  set registrarPassword(String registrarPassword) {
    this._registrarPassword = registrarPassword;
  }

  bool isSetRegistrarPassword() => this.registrarPassword != null;

  unsetRegistrarPassword() {
    this.registrarPassword = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case BUDDYID:
        return this.buddyId;
      case REGISTRARPASSWORD:
        return this.registrarPassword;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case BUDDYID:
        if (value == null) {
          unsetBuddyId();
        } else {
          this.buddyId = value;
        }
        break;

      case REGISTRARPASSWORD:
        if (value == null) {
          unsetRegistrarPassword();
        } else {
          this.registrarPassword = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case BUDDYID:
        return isSetBuddyId();
      case REGISTRARPASSWORD:
        return isSetRegistrarPassword();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case BUDDYID:
          if (field.type == TType.STRING) {
            this.buddyId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REGISTRARPASSWORD:
          if (field.type == TType.STRING) {
            this.registrarPassword = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.buddyId != null) {
      oprot.writeFieldBegin(_BUDDY_ID_FIELD_DESC);
      oprot.writeString(this.buddyId);
      oprot.writeFieldEnd();
    }
    if (this.registrarPassword != null) {
      oprot.writeFieldBegin(_REGISTRAR_PASSWORD_FIELD_DESC);
      oprot.writeString(this.registrarPassword);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerBuddyUser_args(");

    ret.write("buddyId:");
    if (this.buddyId == null) {
      ret.write("null");
    } else {
      ret.write(this.buddyId);
    }

    ret.write(", ");
    ret.write("registrarPassword:");
    if (this.registrarPassword == null) {
      ret.write("null");
    } else {
      ret.write(this.registrarPassword);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerBuddyUser_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerBuddyUser_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerBuddyUser_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerBuddyUser_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerBuddyUserid_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerBuddyUserid_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 2);
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 3);

  int _seq = 0;
  static const int SEQ = 2;
  String _userid;
  static const int USERID = 3;

  bool __isset_seq = false;

  registerBuddyUserid_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case USERID:
        return this.userid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case USERID:
        return isSetUserid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerBuddyUserid_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerBuddyUserid_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerBuddyUserid_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  registerBuddyUserid_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerBuddyUserid_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerDevice_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDevice_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  registerDevice_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDevice_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerDevice_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDevice_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerDevice_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDevice_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerDeviceWithIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDeviceWithIdentityCredential_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 5);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 3);
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 4);

  String _sessionId;
  static const int SESSIONID = 2;
  int _provider;
  static const int PROVIDER = 5;
  String _identifier;
  static const int IDENTIFIER = 3;
  String _verifier;
  static const int VERIFIER = 4;

  bool __isset_provider = false;

  registerDeviceWithIdentityCredential_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case PROVIDER:
        return this.provider;
      case IDENTIFIER:
        return this.identifier;
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case PROVIDER:
        return isSetProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDeviceWithIdentityCredential_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class registerDeviceWithIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDeviceWithIdentityCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerDeviceWithIdentityCredential_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDeviceWithIdentityCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerDeviceWithoutPhoneNumber_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDeviceWithoutPhoneNumber_args");
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 2);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 3);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 4);

  String _region;
  static const int REGION = 2;
  String _udidHash;
  static const int UDIDHASH = 3;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 4;


  registerDeviceWithoutPhoneNumber_args() {
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGION:
        return this.region;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGION:
        return isSetRegion();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDeviceWithoutPhoneNumber_args(");

    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerDeviceWithoutPhoneNumber_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDeviceWithoutPhoneNumber_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerDeviceWithoutPhoneNumber_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDeviceWithoutPhoneNumber_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerDeviceWithoutPhoneNumberWithIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDeviceWithoutPhoneNumberWithIdentityCredential_args");
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 2);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 3);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 4);
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 5);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 6);
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 7);
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 8);
  static final TField _MIGRATION_PINCODE_SESSION_ID_FIELD_DESC = new TField("migrationPincodeSessionId", TType.STRING, 9);

  String _region;
  static const int REGION = 2;
  String _udidHash;
  static const int UDIDHASH = 3;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 4;
  int _provider;
  static const int PROVIDER = 5;
  String _identifier;
  static const int IDENTIFIER = 6;
  String _verifier;
  static const int VERIFIER = 7;
  String _mid;
  static const int MID = 8;
  String _migrationPincodeSessionId;
  static const int MIGRATIONPINCODESESSIONID = 9;

  bool __isset_provider = false;

  registerDeviceWithoutPhoneNumberWithIdentityCredential_args() {
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // migrationPincodeSessionId
  String get migrationPincodeSessionId => this._migrationPincodeSessionId;

  set migrationPincodeSessionId(String migrationPincodeSessionId) {
    this._migrationPincodeSessionId = migrationPincodeSessionId;
  }

  bool isSetMigrationPincodeSessionId() => this.migrationPincodeSessionId != null;

  unsetMigrationPincodeSessionId() {
    this.migrationPincodeSessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGION:
        return this.region;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      case PROVIDER:
        return this.provider;
      case IDENTIFIER:
        return this.identifier;
      case VERIFIER:
        return this.verifier;
      case MID:
        return this.mid;
      case MIGRATIONPINCODESESSIONID:
        return this.migrationPincodeSessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case MIGRATIONPINCODESESSIONID:
        if (value == null) {
          unsetMigrationPincodeSessionId();
        } else {
          this.migrationPincodeSessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGION:
        return isSetRegion();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      case PROVIDER:
        return isSetProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      case VERIFIER:
        return isSetVerifier();
      case MID:
        return isSetMid();
      case MIGRATIONPINCODESESSIONID:
        return isSetMigrationPincodeSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MIGRATIONPINCODESESSIONID:
          if (field.type == TType.STRING) {
            this.migrationPincodeSessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId != null) {
      oprot.writeFieldBegin(_MIGRATION_PINCODE_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.migrationPincodeSessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDeviceWithoutPhoneNumberWithIdentityCredential_args(");

    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(", ");
    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(", ");
    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("migrationPincodeSessionId:");
    if (this.migrationPincodeSessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.migrationPincodeSessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class registerDeviceWithoutPhoneNumberWithIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerDeviceWithoutPhoneNumberWithIdentityCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerDeviceWithoutPhoneNumberWithIdentityCredential_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerDeviceWithoutPhoneNumberWithIdentityCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerUserid_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerUserid_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _userid;
  static const int USERID = 2;

  bool __isset_reqSeq = false;

  registerUserid_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case USERID:
        return this.userid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case USERID:
        return isSetUserid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerUserid_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerUserid_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerUserid_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  registerUserid_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerUserid_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWapDevice_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWapDevice_args");
  static final TField _INVITATION_HASH_FIELD_DESC = new TField("invitationHash", TType.STRING, 2);
  static final TField _GUID_HASH_FIELD_DESC = new TField("guidHash", TType.STRING, 3);
  static final TField _EMAIL_FIELD_DESC = new TField("email", TType.STRING, 4);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 5);

  String _invitationHash;
  static const int INVITATIONHASH = 2;
  String _guidHash;
  static const int GUIDHASH = 3;
  String _email;
  static const int EMAIL = 4;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 5;


  registerWapDevice_args() {
  }

  // invitationHash
  String get invitationHash => this._invitationHash;

  set invitationHash(String invitationHash) {
    this._invitationHash = invitationHash;
  }

  bool isSetInvitationHash() => this.invitationHash != null;

  unsetInvitationHash() {
    this.invitationHash = null;
  }

  // guidHash
  String get guidHash => this._guidHash;

  set guidHash(String guidHash) {
    this._guidHash = guidHash;
  }

  bool isSetGuidHash() => this.guidHash != null;

  unsetGuidHash() {
    this.guidHash = null;
  }

  // email
  String get email => this._email;

  set email(String email) {
    this._email = email;
  }

  bool isSetEmail() => this.email != null;

  unsetEmail() {
    this.email = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case INVITATIONHASH:
        return this.invitationHash;
      case GUIDHASH:
        return this.guidHash;
      case EMAIL:
        return this.email;
      case DEVICEINFO:
        return this.deviceInfo;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case INVITATIONHASH:
        if (value == null) {
          unsetInvitationHash();
        } else {
          this.invitationHash = value;
        }
        break;

      case GUIDHASH:
        if (value == null) {
          unsetGuidHash();
        } else {
          this.guidHash = value;
        }
        break;

      case EMAIL:
        if (value == null) {
          unsetEmail();
        } else {
          this.email = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case INVITATIONHASH:
        return isSetInvitationHash();
      case GUIDHASH:
        return isSetGuidHash();
      case EMAIL:
        return isSetEmail();
      case DEVICEINFO:
        return isSetDeviceInfo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case INVITATIONHASH:
          if (field.type == TType.STRING) {
            this.invitationHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUIDHASH:
          if (field.type == TType.STRING) {
            this.guidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EMAIL:
          if (field.type == TType.STRING) {
            this.email = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.invitationHash != null) {
      oprot.writeFieldBegin(_INVITATION_HASH_FIELD_DESC);
      oprot.writeString(this.invitationHash);
      oprot.writeFieldEnd();
    }
    if (this.guidHash != null) {
      oprot.writeFieldBegin(_GUID_HASH_FIELD_DESC);
      oprot.writeString(this.guidHash);
      oprot.writeFieldEnd();
    }
    if (this.email != null) {
      oprot.writeFieldBegin(_EMAIL_FIELD_DESC);
      oprot.writeString(this.email);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWapDevice_args(");

    ret.write("invitationHash:");
    if (this.invitationHash == null) {
      ret.write("null");
    } else {
      ret.write(this.invitationHash);
    }

    ret.write(", ");
    ret.write("guidHash:");
    if (this.guidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.guidHash);
    }

    ret.write(", ");
    ret.write("email:");
    if (this.email == null) {
      ret.write("null");
    } else {
      ret.write(this.email);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWapDevice_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWapDevice_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerWapDevice_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWapDevice_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithExistingSnsIdAndIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithExistingSnsIdAndIdentityCredential_args");
  static final TField _IDENTITY_CREDENTIAL_FIELD_DESC = new TField("identityCredential", TType.STRUCT, 2);
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 3);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 4);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 5);

  IdentityCredential _identityCredential;
  static const int IDENTITYCREDENTIAL = 2;
  String _region;
  static const int REGION = 3;
  String _udidHash;
  static const int UDIDHASH = 4;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 5;


  registerWithExistingSnsIdAndIdentityCredential_args() {
  }

  // identityCredential
  IdentityCredential get identityCredential => this._identityCredential;

  set identityCredential(IdentityCredential identityCredential) {
    this._identityCredential = identityCredential;
  }

  bool isSetIdentityCredential() => this.identityCredential != null;

  unsetIdentityCredential() {
    this.identityCredential = null;
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDENTITYCREDENTIAL:
        return this.identityCredential;
      case REGION:
        return this.region;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDENTITYCREDENTIAL:
        if (value == null) {
          unsetIdentityCredential();
        } else {
          this.identityCredential = value;
        }
        break;

      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDENTITYCREDENTIAL:
        return isSetIdentityCredential();
      case REGION:
        return isSetRegion();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDENTITYCREDENTIAL:
          if (field.type == TType.STRUCT) {
            this.identityCredential = new IdentityCredential();
            this.identityCredential.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identityCredential != null) {
      oprot.writeFieldBegin(_IDENTITY_CREDENTIAL_FIELD_DESC);
      this.identityCredential.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithExistingSnsIdAndIdentityCredential_args(");

    ret.write("identityCredential:");
    if (this.identityCredential == null) {
      ret.write("null");
    } else {
      ret.write(this.identityCredential);
    }

    ret.write(", ");
    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithExistingSnsIdAndIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithExistingSnsIdAndIdentityCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerWithExistingSnsIdAndIdentityCredential_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithExistingSnsIdAndIdentityCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithSnsId_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithSnsId_args");
  static final TField _SNS_ID_TYPE_FIELD_DESC = new TField("snsIdType", TType.I32, 2);
  static final TField _SNS_ACCESS_TOKEN_FIELD_DESC = new TField("snsAccessToken", TType.STRING, 3);
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 4);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 5);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 6);
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 7);

  int _snsIdType;
  static const int SNSIDTYPE = 2;
  String _snsAccessToken;
  static const int SNSACCESSTOKEN = 3;
  String _region;
  static const int REGION = 4;
  String _udidHash;
  static const int UDIDHASH = 5;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 6;
  String _mid;
  static const int MID = 7;

  bool __isset_snsIdType = false;

  registerWithSnsId_args() {
  }

  // snsIdType
  int get snsIdType => this._snsIdType;

  set snsIdType(int snsIdType) {
    this._snsIdType = snsIdType;
    this.__isset_snsIdType = true;
  }

  bool isSetSnsIdType() => this.__isset_snsIdType;

  unsetSnsIdType() {
    this.__isset_snsIdType = false;
  }

  // snsAccessToken
  String get snsAccessToken => this._snsAccessToken;

  set snsAccessToken(String snsAccessToken) {
    this._snsAccessToken = snsAccessToken;
  }

  bool isSetSnsAccessToken() => this.snsAccessToken != null;

  unsetSnsAccessToken() {
    this.snsAccessToken = null;
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return this.snsIdType;
      case SNSACCESSTOKEN:
        return this.snsAccessToken;
      case REGION:
        return this.region;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SNSIDTYPE:
        if (value == null) {
          unsetSnsIdType();
        } else {
          this.snsIdType = value;
        }
        break;

      case SNSACCESSTOKEN:
        if (value == null) {
          unsetSnsAccessToken();
        } else {
          this.snsAccessToken = value;
        }
        break;

      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return isSetSnsIdType();
      case SNSACCESSTOKEN:
        return isSetSnsAccessToken();
      case REGION:
        return isSetRegion();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SNSIDTYPE:
          if (field.type == TType.I32) {
            this.snsIdType = iprot.readI32();
            this.__isset_snsIdType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SNSACCESSTOKEN:
          if (field.type == TType.STRING) {
            this.snsAccessToken = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SNS_ID_TYPE_FIELD_DESC);
    oprot.writeI32(this.snsIdType);
    oprot.writeFieldEnd();
    if (this.snsAccessToken != null) {
      oprot.writeFieldBegin(_SNS_ACCESS_TOKEN_FIELD_DESC);
      oprot.writeString(this.snsAccessToken);
      oprot.writeFieldEnd();
    }
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithSnsId_args(");

    ret.write("snsIdType:");
    String snsIdType_name = SnsIdType.VALUES_TO_NAMES[this.snsIdType];
    if (snsIdType_name != null) {
      ret.write(snsIdType_name);
      ret.write(" (");
    }
    ret.write(this.snsIdType);
    if (snsIdType_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("snsAccessToken:");
    if (this.snsAccessToken == null) {
      ret.write("null");
    } else {
      ret.write(this.snsAccessToken);
    }

    ret.write(", ");
    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(", ");
    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSnsIdType() && !SnsIdType.VALID_VALUES.contains(snsIdType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'snsIdType' has been assigned the invalid value $snsIdType");
    }
  }

}

class registerWithSnsId_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithSnsId_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  RegisterWithSnsIdResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerWithSnsId_result() {
  }

  // success
  RegisterWithSnsIdResult get success => this._success;

  set success(RegisterWithSnsIdResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RegisterWithSnsIdResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithSnsId_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerWithSnsIdAndIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithSnsIdAndIdentityCredential_args");
  static final TField _SNS_ID_TYPE_FIELD_DESC = new TField("snsIdType", TType.I32, 2);
  static final TField _SNS_ACCESS_TOKEN_FIELD_DESC = new TField("snsAccessToken", TType.STRING, 3);
  static final TField _IDENTITY_CREDENTIAL_FIELD_DESC = new TField("identityCredential", TType.STRUCT, 4);
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 5);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 6);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 7);

  int _snsIdType;
  static const int SNSIDTYPE = 2;
  String _snsAccessToken;
  static const int SNSACCESSTOKEN = 3;
  IdentityCredential _identityCredential;
  static const int IDENTITYCREDENTIAL = 4;
  String _region;
  static const int REGION = 5;
  String _udidHash;
  static const int UDIDHASH = 6;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 7;

  bool __isset_snsIdType = false;

  registerWithSnsIdAndIdentityCredential_args() {
  }

  // snsIdType
  int get snsIdType => this._snsIdType;

  set snsIdType(int snsIdType) {
    this._snsIdType = snsIdType;
    this.__isset_snsIdType = true;
  }

  bool isSetSnsIdType() => this.__isset_snsIdType;

  unsetSnsIdType() {
    this.__isset_snsIdType = false;
  }

  // snsAccessToken
  String get snsAccessToken => this._snsAccessToken;

  set snsAccessToken(String snsAccessToken) {
    this._snsAccessToken = snsAccessToken;
  }

  bool isSetSnsAccessToken() => this.snsAccessToken != null;

  unsetSnsAccessToken() {
    this.snsAccessToken = null;
  }

  // identityCredential
  IdentityCredential get identityCredential => this._identityCredential;

  set identityCredential(IdentityCredential identityCredential) {
    this._identityCredential = identityCredential;
  }

  bool isSetIdentityCredential() => this.identityCredential != null;

  unsetIdentityCredential() {
    this.identityCredential = null;
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return this.snsIdType;
      case SNSACCESSTOKEN:
        return this.snsAccessToken;
      case IDENTITYCREDENTIAL:
        return this.identityCredential;
      case REGION:
        return this.region;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SNSIDTYPE:
        if (value == null) {
          unsetSnsIdType();
        } else {
          this.snsIdType = value;
        }
        break;

      case SNSACCESSTOKEN:
        if (value == null) {
          unsetSnsAccessToken();
        } else {
          this.snsAccessToken = value;
        }
        break;

      case IDENTITYCREDENTIAL:
        if (value == null) {
          unsetIdentityCredential();
        } else {
          this.identityCredential = value;
        }
        break;

      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return isSetSnsIdType();
      case SNSACCESSTOKEN:
        return isSetSnsAccessToken();
      case IDENTITYCREDENTIAL:
        return isSetIdentityCredential();
      case REGION:
        return isSetRegion();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SNSIDTYPE:
          if (field.type == TType.I32) {
            this.snsIdType = iprot.readI32();
            this.__isset_snsIdType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SNSACCESSTOKEN:
          if (field.type == TType.STRING) {
            this.snsAccessToken = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTITYCREDENTIAL:
          if (field.type == TType.STRUCT) {
            this.identityCredential = new IdentityCredential();
            this.identityCredential.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SNS_ID_TYPE_FIELD_DESC);
    oprot.writeI32(this.snsIdType);
    oprot.writeFieldEnd();
    if (this.snsAccessToken != null) {
      oprot.writeFieldBegin(_SNS_ACCESS_TOKEN_FIELD_DESC);
      oprot.writeString(this.snsAccessToken);
      oprot.writeFieldEnd();
    }
    if (this.identityCredential != null) {
      oprot.writeFieldBegin(_IDENTITY_CREDENTIAL_FIELD_DESC);
      this.identityCredential.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithSnsIdAndIdentityCredential_args(");

    ret.write("snsIdType:");
    String snsIdType_name = SnsIdType.VALUES_TO_NAMES[this.snsIdType];
    if (snsIdType_name != null) {
      ret.write(snsIdType_name);
      ret.write(" (");
    }
    ret.write(this.snsIdType);
    if (snsIdType_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("snsAccessToken:");
    if (this.snsAccessToken == null) {
      ret.write("null");
    } else {
      ret.write(this.snsAccessToken);
    }

    ret.write(", ");
    ret.write("identityCredential:");
    if (this.identityCredential == null) {
      ret.write("null");
    } else {
      ret.write(this.identityCredential);
    }

    ret.write(", ");
    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSnsIdType() && !SnsIdType.VALID_VALUES.contains(snsIdType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'snsIdType' has been assigned the invalid value $snsIdType");
    }
  }

}

class registerWithSnsIdAndIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerWithSnsIdAndIdentityCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerWithSnsIdAndIdentityCredential_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerWithSnsIdAndIdentityCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reissueDeviceCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reissueDeviceCredential_args");



  reissueDeviceCredential_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reissueDeviceCredential_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reissueDeviceCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reissueDeviceCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reissueDeviceCredential_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reissueDeviceCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reissueUserTicket_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reissueUserTicket_args");
  static final TField _EXPIRATION_TIME_FIELD_DESC = new TField("expirationTime", TType.I64, 3);
  static final TField _MAX_USE_COUNT_FIELD_DESC = new TField("maxUseCount", TType.I32, 4);

  int _expirationTime = 0;
  static const int EXPIRATIONTIME = 3;
  int _maxUseCount = 0;
  static const int MAXUSECOUNT = 4;

  bool __isset_expirationTime = false;
  bool __isset_maxUseCount = false;

  reissueUserTicket_args() {
  }

  // expirationTime
  int get expirationTime => this._expirationTime;

  set expirationTime(int expirationTime) {
    this._expirationTime = expirationTime;
    this.__isset_expirationTime = true;
  }

  bool isSetExpirationTime() => this.__isset_expirationTime;

  unsetExpirationTime() {
    this.__isset_expirationTime = false;
  }

  // maxUseCount
  int get maxUseCount => this._maxUseCount;

  set maxUseCount(int maxUseCount) {
    this._maxUseCount = maxUseCount;
    this.__isset_maxUseCount = true;
  }

  bool isSetMaxUseCount() => this.__isset_maxUseCount;

  unsetMaxUseCount() {
    this.__isset_maxUseCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case EXPIRATIONTIME:
        return this.expirationTime;
      case MAXUSECOUNT:
        return this.maxUseCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case EXPIRATIONTIME:
        if (value == null) {
          unsetExpirationTime();
        } else {
          this.expirationTime = value;
        }
        break;

      case MAXUSECOUNT:
        if (value == null) {
          unsetMaxUseCount();
        } else {
          this.maxUseCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case EXPIRATIONTIME:
        return isSetExpirationTime();
      case MAXUSECOUNT:
        return isSetMaxUseCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case EXPIRATIONTIME:
          if (field.type == TType.I64) {
            this.expirationTime = iprot.readI64();
            this.__isset_expirationTime = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXUSECOUNT:
          if (field.type == TType.I32) {
            this.maxUseCount = iprot.readI32();
            this.__isset_maxUseCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_EXPIRATION_TIME_FIELD_DESC);
    oprot.writeI64(this.expirationTime);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_MAX_USE_COUNT_FIELD_DESC);
    oprot.writeI32(this.maxUseCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reissueUserTicket_args(");

    ret.write("expirationTime:");
    ret.write(this.expirationTime);

    ret.write(", ");
    ret.write("maxUseCount:");
    ret.write(this.maxUseCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reissueUserTicket_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reissueUserTicket_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reissueUserTicket_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reissueUserTicket_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageReadRange_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageReadRange_args");
  static final TField _CHAT_IDS_FIELD_DESC = new TField("chatIds", TType.LIST, 2);

  List<String> _chatIds;
  static const int CHATIDS = 2;


  getMessageReadRange_args() {
  }

  // chatIds
  List<String> get chatIds => this._chatIds;

  set chatIds(List<String> chatIds) {
    this._chatIds = chatIds;
  }

  bool isSetChatIds() => this.chatIds != null;

  unsetChatIds() {
    this.chatIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATIDS:
        return this.chatIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATIDS:
        if (value == null) {
          unsetChatIds();
        } else {
          this.chatIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATIDS:
        return isSetChatIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1102 = iprot.readListBegin();
              this.chatIds = new List<String>();
              for (int _i1103 = 0; _i1103 < _list1102.length; ++_i1103) {
                String _elem1104;
                _elem1104 = iprot.readString();
                this.chatIds.add(_elem1104);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatIds != null) {
      oprot.writeFieldBegin(_CHAT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.chatIds.length));
        for (var elem1105 in this.chatIds) {
          oprot.writeString(elem1105);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageReadRange_args(");

    ret.write("chatIds:");
    if (this.chatIds == null) {
      ret.write("null");
    } else {
      ret.write(this.chatIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageReadRange_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageReadRange_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<TMessageReadRange> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageReadRange_result() {
  }

  // success
  List<TMessageReadRange> get success => this._success;

  set success(List<TMessageReadRange> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1106 = iprot.readListBegin();
              this.success = new List<TMessageReadRange>();
              for (int _i1107 = 0; _i1107 < _list1106.length; ++_i1107) {
                TMessageReadRange _elem1108;
                _elem1108 = new TMessageReadRange();
                _elem1108.read(iprot);
                this.success.add(_elem1108);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1109 in this.success) {
          elem1109.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageReadRange_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class rejectGroupInvitation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rejectGroupInvitation_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupId;
  static const int GROUPID = 2;

  bool __isset_reqSeq = false;

  rejectGroupInvitation_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rejectGroupInvitation_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class rejectGroupInvitation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rejectGroupInvitation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  rejectGroupInvitation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rejectGroupInvitation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class releaseSession_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("releaseSession_args");



  releaseSession_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("releaseSession_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class releaseSession_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("releaseSession_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  releaseSession_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("releaseSession_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeAllMessages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeAllMessages_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _LAST_MESSAGE_ID_FIELD_DESC = new TField("lastMessageId", TType.STRING, 2);

  int _seq = 0;
  static const int SEQ = 1;
  String _lastMessageId;
  static const int LASTMESSAGEID = 2;

  bool __isset_seq = false;

  removeAllMessages_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // lastMessageId
  String get lastMessageId => this._lastMessageId;

  set lastMessageId(String lastMessageId) {
    this._lastMessageId = lastMessageId;
  }

  bool isSetLastMessageId() => this.lastMessageId != null;

  unsetLastMessageId() {
    this.lastMessageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case LASTMESSAGEID:
        return this.lastMessageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case LASTMESSAGEID:
        if (value == null) {
          unsetLastMessageId();
        } else {
          this.lastMessageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case LASTMESSAGEID:
        return isSetLastMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTMESSAGEID:
          if (field.type == TType.STRING) {
            this.lastMessageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.lastMessageId != null) {
      oprot.writeFieldBegin(_LAST_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.lastMessageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeAllMessages_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("lastMessageId:");
    if (this.lastMessageId == null) {
      ret.write("null");
    } else {
      ret.write(this.lastMessageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeAllMessages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeAllMessages_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  removeAllMessages_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeAllMessages_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeBuddyLocation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeBuddyLocation_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);
  static final TField _INDEX_FIELD_DESC = new TField("index", TType.I32, 3);

  String _mid;
  static const int MID = 2;
  int _index = 0;
  static const int INDEX = 3;

  bool __isset_index = false;

  removeBuddyLocation_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // index
  int get index => this._index;

  set index(int index) {
    this._index = index;
    this.__isset_index = true;
  }

  bool isSetIndex() => this.__isset_index;

  unsetIndex() {
    this.__isset_index = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      case INDEX:
        return this.index;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case INDEX:
        if (value == null) {
          unsetIndex();
        } else {
          this.index = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      case INDEX:
        return isSetIndex();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INDEX:
          if (field.type == TType.I32) {
            this.index = iprot.readI32();
            this.__isset_index = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_INDEX_FIELD_DESC);
    oprot.writeI32(this.index);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeBuddyLocation_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("index:");
    ret.write(this.index);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeBuddyLocation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeBuddyLocation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  removeBuddyLocation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeBuddyLocation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeMessage_args");
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 2);

  String _messageId;
  static const int MESSAGEID = 2;


  removeMessage_args() {
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEID:
        return this.messageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEID:
        return isSetMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeMessage_args(");

    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeMessage_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  removeMessage_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeMessage_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class makeUserAddMyselfAsContact_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("makeUserAddMyselfAsContact_args");
  static final TField _CONTACT_OWNER_MID_FIELD_DESC = new TField("contactOwnerMid", TType.STRING, 1);

  String _contactOwnerMid;
  static const int CONTACTOWNERMID = 1;


  makeUserAddMyselfAsContact_args() {
  }

  // contactOwnerMid
  String get contactOwnerMid => this._contactOwnerMid;

  set contactOwnerMid(String contactOwnerMid) {
    this._contactOwnerMid = contactOwnerMid;
  }

  bool isSetContactOwnerMid() => this.contactOwnerMid != null;

  unsetContactOwnerMid() {
    this.contactOwnerMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CONTACTOWNERMID:
        return this.contactOwnerMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CONTACTOWNERMID:
        if (value == null) {
          unsetContactOwnerMid();
        } else {
          this.contactOwnerMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CONTACTOWNERMID:
        return isSetContactOwnerMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CONTACTOWNERMID:
          if (field.type == TType.STRING) {
            this.contactOwnerMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.contactOwnerMid != null) {
      oprot.writeFieldBegin(_CONTACT_OWNER_MID_FIELD_DESC);
      oprot.writeString(this.contactOwnerMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("makeUserAddMyselfAsContact_args(");

    ret.write("contactOwnerMid:");
    if (this.contactOwnerMid == null) {
      ret.write("null");
    } else {
      ret.write(this.contactOwnerMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class makeUserAddMyselfAsContact_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("makeUserAddMyselfAsContact_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ContactTransition _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  makeUserAddMyselfAsContact_result() {
  }

  // success
  ContactTransition get success => this._success;

  set success(ContactTransition success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ContactTransition();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("makeUserAddMyselfAsContact_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeMessageFromMyHome_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeMessageFromMyHome_args");
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 2);

  String _messageId;
  static const int MESSAGEID = 2;


  removeMessageFromMyHome_args() {
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEID:
        return this.messageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEID:
        return isSetMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeMessageFromMyHome_args(");

    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeMessageFromMyHome_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeMessageFromMyHome_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  removeMessageFromMyHome_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeMessageFromMyHome_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeSnsId_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeSnsId_args");
  static final TField _SNS_ID_TYPE_FIELD_DESC = new TField("snsIdType", TType.I32, 2);

  int _snsIdType;
  static const int SNSIDTYPE = 2;

  bool __isset_snsIdType = false;

  removeSnsId_args() {
  }

  // snsIdType
  int get snsIdType => this._snsIdType;

  set snsIdType(int snsIdType) {
    this._snsIdType = snsIdType;
    this.__isset_snsIdType = true;
  }

  bool isSetSnsIdType() => this.__isset_snsIdType;

  unsetSnsIdType() {
    this.__isset_snsIdType = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return this.snsIdType;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SNSIDTYPE:
        if (value == null) {
          unsetSnsIdType();
        } else {
          this.snsIdType = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SNSIDTYPE:
        return isSetSnsIdType();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SNSIDTYPE:
          if (field.type == TType.I32) {
            this.snsIdType = iprot.readI32();
            this.__isset_snsIdType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SNS_ID_TYPE_FIELD_DESC);
    oprot.writeI32(this.snsIdType);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeSnsId_args(");

    ret.write("snsIdType:");
    String snsIdType_name = SnsIdType.VALUES_TO_NAMES[this.snsIdType];
    if (snsIdType_name != null) {
      ret.write(snsIdType_name);
      ret.write(" (");
    }
    ret.write(this.snsIdType);
    if (snsIdType_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSnsIdType() && !SnsIdType.VALID_VALUES.contains(snsIdType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'snsIdType' has been assigned the invalid value $snsIdType");
    }
  }

}

class removeSnsId_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeSnsId_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  removeSnsId_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeSnsId_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class report_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("report_args");
  static final TField _SYNC_OP_REVISION_FIELD_DESC = new TField("syncOpRevision", TType.I64, 2);
  static final TField _CATEGORY_FIELD_DESC = new TField("category", TType.I32, 3);
  static final TField _REPORT_FIELD_DESC = new TField("report", TType.STRING, 4);

  int _syncOpRevision = 0;
  static const int SYNCOPREVISION = 2;
  int _category;
  static const int CATEGORY = 3;
  String _report;
  static const int REPORT = 4;

  bool __isset_syncOpRevision = false;
  bool __isset_category = false;

  report_args() {
  }

  // syncOpRevision
  int get syncOpRevision => this._syncOpRevision;

  set syncOpRevision(int syncOpRevision) {
    this._syncOpRevision = syncOpRevision;
    this.__isset_syncOpRevision = true;
  }

  bool isSetSyncOpRevision() => this.__isset_syncOpRevision;

  unsetSyncOpRevision() {
    this.__isset_syncOpRevision = false;
  }

  // category
  int get category => this._category;

  set category(int category) {
    this._category = category;
    this.__isset_category = true;
  }

  bool isSetCategory() => this.__isset_category;

  unsetCategory() {
    this.__isset_category = false;
  }

  // report
  String get report => this._report;

  set report(String report) {
    this._report = report;
  }

  bool isSetReport() => this.report != null;

  unsetReport() {
    this.report = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return this.syncOpRevision;
      case CATEGORY:
        return this.category;
      case REPORT:
        return this.report;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SYNCOPREVISION:
        if (value == null) {
          unsetSyncOpRevision();
        } else {
          this.syncOpRevision = value;
        }
        break;

      case CATEGORY:
        if (value == null) {
          unsetCategory();
        } else {
          this.category = value;
        }
        break;

      case REPORT:
        if (value == null) {
          unsetReport();
        } else {
          this.report = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return isSetSyncOpRevision();
      case CATEGORY:
        return isSetCategory();
      case REPORT:
        return isSetReport();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SYNCOPREVISION:
          if (field.type == TType.I64) {
            this.syncOpRevision = iprot.readI64();
            this.__isset_syncOpRevision = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CATEGORY:
          if (field.type == TType.I32) {
            this.category = iprot.readI32();
            this.__isset_category = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REPORT:
          if (field.type == TType.STRING) {
            this.report = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SYNC_OP_REVISION_FIELD_DESC);
    oprot.writeI64(this.syncOpRevision);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_CATEGORY_FIELD_DESC);
    oprot.writeI32(this.category);
    oprot.writeFieldEnd();
    if (this.report != null) {
      oprot.writeFieldBegin(_REPORT_FIELD_DESC);
      oprot.writeString(this.report);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("report_args(");

    ret.write("syncOpRevision:");
    ret.write(this.syncOpRevision);

    ret.write(", ");
    ret.write("category:");
    String category_name = SyncCategory.VALUES_TO_NAMES[this.category];
    if (category_name != null) {
      ret.write(category_name);
      ret.write(" (");
    }
    ret.write(this.category);
    if (category_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("report:");
    if (this.report == null) {
      ret.write("null");
    } else {
      ret.write(this.report);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCategory() && !SyncCategory.VALID_VALUES.contains(category)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'category' has been assigned the invalid value $category");
    }
  }

}

class report_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("report_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  report_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("report_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportContacts_args");
  static final TField _SYNC_OP_REVISION_FIELD_DESC = new TField("syncOpRevision", TType.I64, 2);
  static final TField _CATEGORY_FIELD_DESC = new TField("category", TType.I32, 3);
  static final TField _CONTACT_REPORTS_FIELD_DESC = new TField("contactReports", TType.LIST, 4);
  static final TField _ACTION_TYPE_FIELD_DESC = new TField("actionType", TType.I32, 5);

  int _syncOpRevision = 0;
  static const int SYNCOPREVISION = 2;
  int _category;
  static const int CATEGORY = 3;
  List<ContactReport> _contactReports;
  static const int CONTACTREPORTS = 4;
  int _actionType;
  static const int ACTIONTYPE = 5;

  bool __isset_syncOpRevision = false;
  bool __isset_category = false;
  bool __isset_actionType = false;

  reportContacts_args() {
  }

  // syncOpRevision
  int get syncOpRevision => this._syncOpRevision;

  set syncOpRevision(int syncOpRevision) {
    this._syncOpRevision = syncOpRevision;
    this.__isset_syncOpRevision = true;
  }

  bool isSetSyncOpRevision() => this.__isset_syncOpRevision;

  unsetSyncOpRevision() {
    this.__isset_syncOpRevision = false;
  }

  // category
  int get category => this._category;

  set category(int category) {
    this._category = category;
    this.__isset_category = true;
  }

  bool isSetCategory() => this.__isset_category;

  unsetCategory() {
    this.__isset_category = false;
  }

  // contactReports
  List<ContactReport> get contactReports => this._contactReports;

  set contactReports(List<ContactReport> contactReports) {
    this._contactReports = contactReports;
  }

  bool isSetContactReports() => this.contactReports != null;

  unsetContactReports() {
    this.contactReports = null;
  }

  // actionType
  int get actionType => this._actionType;

  set actionType(int actionType) {
    this._actionType = actionType;
    this.__isset_actionType = true;
  }

  bool isSetActionType() => this.__isset_actionType;

  unsetActionType() {
    this.__isset_actionType = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return this.syncOpRevision;
      case CATEGORY:
        return this.category;
      case CONTACTREPORTS:
        return this.contactReports;
      case ACTIONTYPE:
        return this.actionType;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SYNCOPREVISION:
        if (value == null) {
          unsetSyncOpRevision();
        } else {
          this.syncOpRevision = value;
        }
        break;

      case CATEGORY:
        if (value == null) {
          unsetCategory();
        } else {
          this.category = value;
        }
        break;

      case CONTACTREPORTS:
        if (value == null) {
          unsetContactReports();
        } else {
          this.contactReports = value;
        }
        break;

      case ACTIONTYPE:
        if (value == null) {
          unsetActionType();
        } else {
          this.actionType = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return isSetSyncOpRevision();
      case CATEGORY:
        return isSetCategory();
      case CONTACTREPORTS:
        return isSetContactReports();
      case ACTIONTYPE:
        return isSetActionType();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SYNCOPREVISION:
          if (field.type == TType.I64) {
            this.syncOpRevision = iprot.readI64();
            this.__isset_syncOpRevision = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CATEGORY:
          if (field.type == TType.I32) {
            this.category = iprot.readI32();
            this.__isset_category = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTREPORTS:
          if (field.type == TType.LIST) {
            {
              TList _list1110 = iprot.readListBegin();
              this.contactReports = new List<ContactReport>();
              for (int _i1111 = 0; _i1111 < _list1110.length; ++_i1111) {
                ContactReport _elem1112;
                _elem1112 = new ContactReport();
                _elem1112.read(iprot);
                this.contactReports.add(_elem1112);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ACTIONTYPE:
          if (field.type == TType.I32) {
            this.actionType = iprot.readI32();
            this.__isset_actionType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SYNC_OP_REVISION_FIELD_DESC);
    oprot.writeI64(this.syncOpRevision);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_CATEGORY_FIELD_DESC);
    oprot.writeI32(this.category);
    oprot.writeFieldEnd();
    if (this.contactReports != null) {
      oprot.writeFieldBegin(_CONTACT_REPORTS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.contactReports.length));
        for (var elem1113 in this.contactReports) {
          elem1113.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_ACTION_TYPE_FIELD_DESC);
    oprot.writeI32(this.actionType);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportContacts_args(");

    ret.write("syncOpRevision:");
    ret.write(this.syncOpRevision);

    ret.write(", ");
    ret.write("category:");
    String category_name = SyncCategory.VALUES_TO_NAMES[this.category];
    if (category_name != null) {
      ret.write(category_name);
      ret.write(" (");
    }
    ret.write(this.category);
    if (category_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("contactReports:");
    if (this.contactReports == null) {
      ret.write("null");
    } else {
      ret.write(this.contactReports);
    }

    ret.write(", ");
    ret.write("actionType:");
    String actionType_name = SyncActionType.VALUES_TO_NAMES[this.actionType];
    if (actionType_name != null) {
      ret.write(actionType_name);
      ret.write(" (");
    }
    ret.write(this.actionType);
    if (actionType_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCategory() && !SyncCategory.VALID_VALUES.contains(category)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'category' has been assigned the invalid value $category");
    }
    if (isSetActionType() && !SyncActionType.VALID_VALUES.contains(actionType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'actionType' has been assigned the invalid value $actionType");
    }
  }

}

class reportContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<ContactReportResult> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reportContacts_result() {
  }

  // success
  List<ContactReportResult> get success => this._success;

  set success(List<ContactReportResult> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1114 = iprot.readListBegin();
              this.success = new List<ContactReportResult>();
              for (int _i1115 = 0; _i1115 < _list1114.length; ++_i1115) {
                ContactReportResult _elem1116;
                _elem1116 = new ContactReportResult();
                _elem1116.read(iprot);
                this.success.add(_elem1116);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1117 in this.success) {
          elem1117.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportGroups_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportGroups_args");
  static final TField _SYNC_OP_REVISION_FIELD_DESC = new TField("syncOpRevision", TType.I64, 2);
  static final TField _GROUPS_FIELD_DESC = new TField("groups", TType.LIST, 3);

  int _syncOpRevision = 0;
  static const int SYNCOPREVISION = 2;
  List<Group> _groups;
  static const int GROUPS = 3;

  bool __isset_syncOpRevision = false;

  reportGroups_args() {
  }

  // syncOpRevision
  int get syncOpRevision => this._syncOpRevision;

  set syncOpRevision(int syncOpRevision) {
    this._syncOpRevision = syncOpRevision;
    this.__isset_syncOpRevision = true;
  }

  bool isSetSyncOpRevision() => this.__isset_syncOpRevision;

  unsetSyncOpRevision() {
    this.__isset_syncOpRevision = false;
  }

  // groups
  List<Group> get groups => this._groups;

  set groups(List<Group> groups) {
    this._groups = groups;
  }

  bool isSetGroups() => this.groups != null;

  unsetGroups() {
    this.groups = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return this.syncOpRevision;
      case GROUPS:
        return this.groups;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SYNCOPREVISION:
        if (value == null) {
          unsetSyncOpRevision();
        } else {
          this.syncOpRevision = value;
        }
        break;

      case GROUPS:
        if (value == null) {
          unsetGroups();
        } else {
          this.groups = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return isSetSyncOpRevision();
      case GROUPS:
        return isSetGroups();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SYNCOPREVISION:
          if (field.type == TType.I64) {
            this.syncOpRevision = iprot.readI64();
            this.__isset_syncOpRevision = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPS:
          if (field.type == TType.LIST) {
            {
              TList _list1118 = iprot.readListBegin();
              this.groups = new List<Group>();
              for (int _i1119 = 0; _i1119 < _list1118.length; ++_i1119) {
                Group _elem1120;
                _elem1120 = new Group();
                _elem1120.read(iprot);
                this.groups.add(_elem1120);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SYNC_OP_REVISION_FIELD_DESC);
    oprot.writeI64(this.syncOpRevision);
    oprot.writeFieldEnd();
    if (this.groups != null) {
      oprot.writeFieldBegin(_GROUPS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.groups.length));
        for (var elem1121 in this.groups) {
          elem1121.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportGroups_args(");

    ret.write("syncOpRevision:");
    ret.write(this.syncOpRevision);

    ret.write(", ");
    ret.write("groups:");
    if (this.groups == null) {
      ret.write("null");
    } else {
      ret.write(this.groups);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportGroups_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportGroups_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportGroups_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportGroups_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportProfile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportProfile_args");
  static final TField _SYNC_OP_REVISION_FIELD_DESC = new TField("syncOpRevision", TType.I64, 2);
  static final TField _PROFILE_FIELD_DESC = new TField("profile", TType.STRUCT, 3);

  int _syncOpRevision = 0;
  static const int SYNCOPREVISION = 2;
  Profile _profile;
  static const int PROFILE = 3;

  bool __isset_syncOpRevision = false;

  reportProfile_args() {
  }

  // syncOpRevision
  int get syncOpRevision => this._syncOpRevision;

  set syncOpRevision(int syncOpRevision) {
    this._syncOpRevision = syncOpRevision;
    this.__isset_syncOpRevision = true;
  }

  bool isSetSyncOpRevision() => this.__isset_syncOpRevision;

  unsetSyncOpRevision() {
    this.__isset_syncOpRevision = false;
  }

  // profile
  Profile get profile => this._profile;

  set profile(Profile profile) {
    this._profile = profile;
  }

  bool isSetProfile() => this.profile != null;

  unsetProfile() {
    this.profile = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return this.syncOpRevision;
      case PROFILE:
        return this.profile;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SYNCOPREVISION:
        if (value == null) {
          unsetSyncOpRevision();
        } else {
          this.syncOpRevision = value;
        }
        break;

      case PROFILE:
        if (value == null) {
          unsetProfile();
        } else {
          this.profile = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return isSetSyncOpRevision();
      case PROFILE:
        return isSetProfile();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SYNCOPREVISION:
          if (field.type == TType.I64) {
            this.syncOpRevision = iprot.readI64();
            this.__isset_syncOpRevision = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PROFILE:
          if (field.type == TType.STRUCT) {
            this.profile = new Profile();
            this.profile.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SYNC_OP_REVISION_FIELD_DESC);
    oprot.writeI64(this.syncOpRevision);
    oprot.writeFieldEnd();
    if (this.profile != null) {
      oprot.writeFieldBegin(_PROFILE_FIELD_DESC);
      this.profile.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportProfile_args(");

    ret.write("syncOpRevision:");
    ret.write(this.syncOpRevision);

    ret.write(", ");
    ret.write("profile:");
    if (this.profile == null) {
      ret.write("null");
    } else {
      ret.write(this.profile);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportProfile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportProfile_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportProfile_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportProfile_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportRooms_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportRooms_args");
  static final TField _SYNC_OP_REVISION_FIELD_DESC = new TField("syncOpRevision", TType.I64, 2);
  static final TField _ROOMS_FIELD_DESC = new TField("rooms", TType.LIST, 3);

  int _syncOpRevision = 0;
  static const int SYNCOPREVISION = 2;
  List<Room> _rooms;
  static const int ROOMS = 3;

  bool __isset_syncOpRevision = false;

  reportRooms_args() {
  }

  // syncOpRevision
  int get syncOpRevision => this._syncOpRevision;

  set syncOpRevision(int syncOpRevision) {
    this._syncOpRevision = syncOpRevision;
    this.__isset_syncOpRevision = true;
  }

  bool isSetSyncOpRevision() => this.__isset_syncOpRevision;

  unsetSyncOpRevision() {
    this.__isset_syncOpRevision = false;
  }

  // rooms
  List<Room> get rooms => this._rooms;

  set rooms(List<Room> rooms) {
    this._rooms = rooms;
  }

  bool isSetRooms() => this.rooms != null;

  unsetRooms() {
    this.rooms = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return this.syncOpRevision;
      case ROOMS:
        return this.rooms;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SYNCOPREVISION:
        if (value == null) {
          unsetSyncOpRevision();
        } else {
          this.syncOpRevision = value;
        }
        break;

      case ROOMS:
        if (value == null) {
          unsetRooms();
        } else {
          this.rooms = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return isSetSyncOpRevision();
      case ROOMS:
        return isSetRooms();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SYNCOPREVISION:
          if (field.type == TType.I64) {
            this.syncOpRevision = iprot.readI64();
            this.__isset_syncOpRevision = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROOMS:
          if (field.type == TType.LIST) {
            {
              TList _list1122 = iprot.readListBegin();
              this.rooms = new List<Room>();
              for (int _i1123 = 0; _i1123 < _list1122.length; ++_i1123) {
                Room _elem1124;
                _elem1124 = new Room();
                _elem1124.read(iprot);
                this.rooms.add(_elem1124);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SYNC_OP_REVISION_FIELD_DESC);
    oprot.writeI64(this.syncOpRevision);
    oprot.writeFieldEnd();
    if (this.rooms != null) {
      oprot.writeFieldBegin(_ROOMS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.rooms.length));
        for (var elem1125 in this.rooms) {
          elem1125.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportRooms_args(");

    ret.write("syncOpRevision:");
    ret.write(this.syncOpRevision);

    ret.write(", ");
    ret.write("rooms:");
    if (this.rooms == null) {
      ret.write("null");
    } else {
      ret.write(this.rooms);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportRooms_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportRooms_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportRooms_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportRooms_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactByMetaTag_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactByMetaTag_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);
  static final TField _REFERENCE_FIELD_DESC = new TField("reference", TType.STRING, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _userid;
  static const int USERID = 2;
  String _reference;
  static const int REFERENCE = 3;

  bool __isset_reqSeq = false;

  findAndAddContactByMetaTag_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  // reference
  String get reference => this._reference;

  set reference(String reference) {
    this._reference = reference;
  }

  bool isSetReference() => this.reference != null;

  unsetReference() {
    this.reference = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case USERID:
        return this.userid;
      case REFERENCE:
        return this.reference;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      case REFERENCE:
        if (value == null) {
          unsetReference();
        } else {
          this.reference = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case USERID:
        return isSetUserid();
      case REFERENCE:
        return isSetReference();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REFERENCE:
          if (field.type == TType.STRING) {
            this.reference = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    if (this.reference != null) {
      oprot.writeFieldBegin(_REFERENCE_FIELD_DESC);
      oprot.writeString(this.reference);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactByMetaTag_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(", ");
    ret.write("reference:");
    if (this.reference == null) {
      ret.write("null");
    } else {
      ret.write(this.reference);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findAndAddContactByMetaTag_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findAndAddContactByMetaTag_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findAndAddContactByMetaTag_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findAndAddContactByMetaTag_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportSettings_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportSettings_args");
  static final TField _SYNC_OP_REVISION_FIELD_DESC = new TField("syncOpRevision", TType.I64, 2);
  static final TField _SETTINGS_FIELD_DESC = new TField("settings", TType.STRUCT, 3);

  int _syncOpRevision = 0;
  static const int SYNCOPREVISION = 2;
  Settings _settings;
  static const int SETTINGS = 3;

  bool __isset_syncOpRevision = false;

  reportSettings_args() {
  }

  // syncOpRevision
  int get syncOpRevision => this._syncOpRevision;

  set syncOpRevision(int syncOpRevision) {
    this._syncOpRevision = syncOpRevision;
    this.__isset_syncOpRevision = true;
  }

  bool isSetSyncOpRevision() => this.__isset_syncOpRevision;

  unsetSyncOpRevision() {
    this.__isset_syncOpRevision = false;
  }

  // settings
  Settings get settings => this._settings;

  set settings(Settings settings) {
    this._settings = settings;
  }

  bool isSetSettings() => this.settings != null;

  unsetSettings() {
    this.settings = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return this.syncOpRevision;
      case SETTINGS:
        return this.settings;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SYNCOPREVISION:
        if (value == null) {
          unsetSyncOpRevision();
        } else {
          this.syncOpRevision = value;
        }
        break;

      case SETTINGS:
        if (value == null) {
          unsetSettings();
        } else {
          this.settings = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SYNCOPREVISION:
        return isSetSyncOpRevision();
      case SETTINGS:
        return isSetSettings();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SYNCOPREVISION:
          if (field.type == TType.I64) {
            this.syncOpRevision = iprot.readI64();
            this.__isset_syncOpRevision = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SETTINGS:
          if (field.type == TType.STRUCT) {
            this.settings = new Settings();
            this.settings.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SYNC_OP_REVISION_FIELD_DESC);
    oprot.writeI64(this.syncOpRevision);
    oprot.writeFieldEnd();
    if (this.settings != null) {
      oprot.writeFieldBegin(_SETTINGS_FIELD_DESC);
      this.settings.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportSettings_args(");

    ret.write("syncOpRevision:");
    ret.write(this.syncOpRevision);

    ret.write(", ");
    ret.write("settings:");
    if (this.settings == null) {
      ret.write("null");
    } else {
      ret.write(this.settings);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportSettings_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportSettings_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportSettings_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportSettings_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportSpam_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportSpam_args");
  static final TField _CHAT_MID_FIELD_DESC = new TField("chatMid", TType.STRING, 2);
  static final TField _MEMBER_MIDS_FIELD_DESC = new TField("memberMids", TType.LIST, 3);
  static final TField _SPAMMER_REASONS_FIELD_DESC = new TField("spammerReasons", TType.LIST, 4);
  static final TField _SENDER_MIDS_FIELD_DESC = new TField("senderMids", TType.LIST, 5);
  static final TField _SPAM_MESSAGE_IDS_FIELD_DESC = new TField("spamMessageIds", TType.LIST, 6);
  static final TField _SPAM_MESSAGES_FIELD_DESC = new TField("spamMessages", TType.LIST, 7);

  String _chatMid;
  static const int CHATMID = 2;
  List<String> _memberMids;
  static const int MEMBERMIDS = 3;
  List<int> _spammerReasons;
  static const int SPAMMERREASONS = 4;
  List<String> _senderMids;
  static const int SENDERMIDS = 5;
  List<String> _spamMessageIds;
  static const int SPAMMESSAGEIDS = 6;
  List<String> _spamMessages;
  static const int SPAMMESSAGES = 7;


  reportSpam_args() {
  }

  // chatMid
  String get chatMid => this._chatMid;

  set chatMid(String chatMid) {
    this._chatMid = chatMid;
  }

  bool isSetChatMid() => this.chatMid != null;

  unsetChatMid() {
    this.chatMid = null;
  }

  // memberMids
  List<String> get memberMids => this._memberMids;

  set memberMids(List<String> memberMids) {
    this._memberMids = memberMids;
  }

  bool isSetMemberMids() => this.memberMids != null;

  unsetMemberMids() {
    this.memberMids = null;
  }

  // spammerReasons
  List<int> get spammerReasons => this._spammerReasons;

  set spammerReasons(List<int> spammerReasons) {
    this._spammerReasons = spammerReasons;
  }

  bool isSetSpammerReasons() => this.spammerReasons != null;

  unsetSpammerReasons() {
    this.spammerReasons = null;
  }

  // senderMids
  List<String> get senderMids => this._senderMids;

  set senderMids(List<String> senderMids) {
    this._senderMids = senderMids;
  }

  bool isSetSenderMids() => this.senderMids != null;

  unsetSenderMids() {
    this.senderMids = null;
  }

  // spamMessageIds
  List<String> get spamMessageIds => this._spamMessageIds;

  set spamMessageIds(List<String> spamMessageIds) {
    this._spamMessageIds = spamMessageIds;
  }

  bool isSetSpamMessageIds() => this.spamMessageIds != null;

  unsetSpamMessageIds() {
    this.spamMessageIds = null;
  }

  // spamMessages
  List<String> get spamMessages => this._spamMessages;

  set spamMessages(List<String> spamMessages) {
    this._spamMessages = spamMessages;
  }

  bool isSetSpamMessages() => this.spamMessages != null;

  unsetSpamMessages() {
    this.spamMessages = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return this.chatMid;
      case MEMBERMIDS:
        return this.memberMids;
      case SPAMMERREASONS:
        return this.spammerReasons;
      case SENDERMIDS:
        return this.senderMids;
      case SPAMMESSAGEIDS:
        return this.spamMessageIds;
      case SPAMMESSAGES:
        return this.spamMessages;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATMID:
        if (value == null) {
          unsetChatMid();
        } else {
          this.chatMid = value;
        }
        break;

      case MEMBERMIDS:
        if (value == null) {
          unsetMemberMids();
        } else {
          this.memberMids = value;
        }
        break;

      case SPAMMERREASONS:
        if (value == null) {
          unsetSpammerReasons();
        } else {
          this.spammerReasons = value;
        }
        break;

      case SENDERMIDS:
        if (value == null) {
          unsetSenderMids();
        } else {
          this.senderMids = value;
        }
        break;

      case SPAMMESSAGEIDS:
        if (value == null) {
          unsetSpamMessageIds();
        } else {
          this.spamMessageIds = value;
        }
        break;

      case SPAMMESSAGES:
        if (value == null) {
          unsetSpamMessages();
        } else {
          this.spamMessages = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return isSetChatMid();
      case MEMBERMIDS:
        return isSetMemberMids();
      case SPAMMERREASONS:
        return isSetSpammerReasons();
      case SENDERMIDS:
        return isSetSenderMids();
      case SPAMMESSAGEIDS:
        return isSetSpamMessageIds();
      case SPAMMESSAGES:
        return isSetSpamMessages();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATMID:
          if (field.type == TType.STRING) {
            this.chatMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MEMBERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1126 = iprot.readListBegin();
              this.memberMids = new List<String>();
              for (int _i1127 = 0; _i1127 < _list1126.length; ++_i1127) {
                String _elem1128;
                _elem1128 = iprot.readString();
                this.memberMids.add(_elem1128);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SPAMMERREASONS:
          if (field.type == TType.LIST) {
            {
              TList _list1129 = iprot.readListBegin();
              this.spammerReasons = new List<int>();
              for (int _i1130 = 0; _i1130 < _list1129.length; ++_i1130) {
                int _elem1131;
                _elem1131 = iprot.readI32();
                this.spammerReasons.add(_elem1131);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SENDERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1132 = iprot.readListBegin();
              this.senderMids = new List<String>();
              for (int _i1133 = 0; _i1133 < _list1132.length; ++_i1133) {
                String _elem1134;
                _elem1134 = iprot.readString();
                this.senderMids.add(_elem1134);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SPAMMESSAGEIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1135 = iprot.readListBegin();
              this.spamMessageIds = new List<String>();
              for (int _i1136 = 0; _i1136 < _list1135.length; ++_i1136) {
                String _elem1137;
                _elem1137 = iprot.readString();
                this.spamMessageIds.add(_elem1137);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SPAMMESSAGES:
          if (field.type == TType.LIST) {
            {
              TList _list1138 = iprot.readListBegin();
              this.spamMessages = new List<String>();
              for (int _i1139 = 0; _i1139 < _list1138.length; ++_i1139) {
                String _elem1140;
                _elem1140 = iprot.readString();
                this.spamMessages.add(_elem1140);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatMid != null) {
      oprot.writeFieldBegin(_CHAT_MID_FIELD_DESC);
      oprot.writeString(this.chatMid);
      oprot.writeFieldEnd();
    }
    if (this.memberMids != null) {
      oprot.writeFieldBegin(_MEMBER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.memberMids.length));
        for (var elem1141 in this.memberMids) {
          oprot.writeString(elem1141);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.spammerReasons != null) {
      oprot.writeFieldBegin(_SPAMMER_REASONS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.I32, this.spammerReasons.length));
        for (var elem1142 in this.spammerReasons) {
          oprot.writeI32(elem1142);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.senderMids != null) {
      oprot.writeFieldBegin(_SENDER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.senderMids.length));
        for (var elem1143 in this.senderMids) {
          oprot.writeString(elem1143);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.spamMessageIds != null) {
      oprot.writeFieldBegin(_SPAM_MESSAGE_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.spamMessageIds.length));
        for (var elem1144 in this.spamMessageIds) {
          oprot.writeString(elem1144);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.spamMessages != null) {
      oprot.writeFieldBegin(_SPAM_MESSAGES_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.spamMessages.length));
        for (var elem1145 in this.spamMessages) {
          oprot.writeString(elem1145);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportSpam_args(");

    ret.write("chatMid:");
    if (this.chatMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatMid);
    }

    ret.write(", ");
    ret.write("memberMids:");
    if (this.memberMids == null) {
      ret.write("null");
    } else {
      ret.write(this.memberMids);
    }

    ret.write(", ");
    ret.write("spammerReasons:");
    if (this.spammerReasons == null) {
      ret.write("null");
    } else {
      ret.write(this.spammerReasons);
    }

    ret.write(", ");
    ret.write("senderMids:");
    if (this.senderMids == null) {
      ret.write("null");
    } else {
      ret.write(this.senderMids);
    }

    ret.write(", ");
    ret.write("spamMessageIds:");
    if (this.spamMessageIds == null) {
      ret.write("null");
    } else {
      ret.write(this.spamMessageIds);
    }

    ret.write(", ");
    ret.write("spamMessages:");
    if (this.spamMessages == null) {
      ret.write("null");
    } else {
      ret.write(this.spamMessages);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportSpam_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportSpam_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportSpam_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportSpam_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportSpammer_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportSpammer_args");
  static final TField _SPAMMER_MID_FIELD_DESC = new TField("spammerMid", TType.STRING, 2);
  static final TField _SPAMMER_REASONS_FIELD_DESC = new TField("spammerReasons", TType.LIST, 3);
  static final TField _SPAM_MESSAGE_IDS_FIELD_DESC = new TField("spamMessageIds", TType.LIST, 4);

  String _spammerMid;
  static const int SPAMMERMID = 2;
  List<int> _spammerReasons;
  static const int SPAMMERREASONS = 3;
  List<String> _spamMessageIds;
  static const int SPAMMESSAGEIDS = 4;


  reportSpammer_args() {
  }

  // spammerMid
  String get spammerMid => this._spammerMid;

  set spammerMid(String spammerMid) {
    this._spammerMid = spammerMid;
  }

  bool isSetSpammerMid() => this.spammerMid != null;

  unsetSpammerMid() {
    this.spammerMid = null;
  }

  // spammerReasons
  List<int> get spammerReasons => this._spammerReasons;

  set spammerReasons(List<int> spammerReasons) {
    this._spammerReasons = spammerReasons;
  }

  bool isSetSpammerReasons() => this.spammerReasons != null;

  unsetSpammerReasons() {
    this.spammerReasons = null;
  }

  // spamMessageIds
  List<String> get spamMessageIds => this._spamMessageIds;

  set spamMessageIds(List<String> spamMessageIds) {
    this._spamMessageIds = spamMessageIds;
  }

  bool isSetSpamMessageIds() => this.spamMessageIds != null;

  unsetSpamMessageIds() {
    this.spamMessageIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SPAMMERMID:
        return this.spammerMid;
      case SPAMMERREASONS:
        return this.spammerReasons;
      case SPAMMESSAGEIDS:
        return this.spamMessageIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SPAMMERMID:
        if (value == null) {
          unsetSpammerMid();
        } else {
          this.spammerMid = value;
        }
        break;

      case SPAMMERREASONS:
        if (value == null) {
          unsetSpammerReasons();
        } else {
          this.spammerReasons = value;
        }
        break;

      case SPAMMESSAGEIDS:
        if (value == null) {
          unsetSpamMessageIds();
        } else {
          this.spamMessageIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SPAMMERMID:
        return isSetSpammerMid();
      case SPAMMERREASONS:
        return isSetSpammerReasons();
      case SPAMMESSAGEIDS:
        return isSetSpamMessageIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SPAMMERMID:
          if (field.type == TType.STRING) {
            this.spammerMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SPAMMERREASONS:
          if (field.type == TType.LIST) {
            {
              TList _list1146 = iprot.readListBegin();
              this.spammerReasons = new List<int>();
              for (int _i1147 = 0; _i1147 < _list1146.length; ++_i1147) {
                int _elem1148;
                _elem1148 = iprot.readI32();
                this.spammerReasons.add(_elem1148);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SPAMMESSAGEIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1149 = iprot.readListBegin();
              this.spamMessageIds = new List<String>();
              for (int _i1150 = 0; _i1150 < _list1149.length; ++_i1150) {
                String _elem1151;
                _elem1151 = iprot.readString();
                this.spamMessageIds.add(_elem1151);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.spammerMid != null) {
      oprot.writeFieldBegin(_SPAMMER_MID_FIELD_DESC);
      oprot.writeString(this.spammerMid);
      oprot.writeFieldEnd();
    }
    if (this.spammerReasons != null) {
      oprot.writeFieldBegin(_SPAMMER_REASONS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.I32, this.spammerReasons.length));
        for (var elem1152 in this.spammerReasons) {
          oprot.writeI32(elem1152);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.spamMessageIds != null) {
      oprot.writeFieldBegin(_SPAM_MESSAGE_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.spamMessageIds.length));
        for (var elem1153 in this.spamMessageIds) {
          oprot.writeString(elem1153);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportSpammer_args(");

    ret.write("spammerMid:");
    if (this.spammerMid == null) {
      ret.write("null");
    } else {
      ret.write(this.spammerMid);
    }

    ret.write(", ");
    ret.write("spammerReasons:");
    if (this.spammerReasons == null) {
      ret.write("null");
    } else {
      ret.write(this.spammerReasons);
    }

    ret.write(", ");
    ret.write("spamMessageIds:");
    if (this.spamMessageIds == null) {
      ret.write("null");
    } else {
      ret.write(this.spamMessageIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reportSpammer_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportSpammer_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  reportSpammer_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportSpammer_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestAccountPasswordReset_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestAccountPasswordReset_args");
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 4);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 2);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 5);

  int _provider;
  static const int PROVIDER = 4;
  String _identifier;
  static const int IDENTIFIER = 2;
  String _locale;
  static const int LOCALE = 5;

  bool __isset_provider = false;

  requestAccountPasswordReset_args() {
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return this.provider;
      case IDENTIFIER:
        return this.identifier;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return isSetProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestAccountPasswordReset_args(");

    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class requestAccountPasswordReset_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestAccountPasswordReset_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  requestAccountPasswordReset_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestAccountPasswordReset_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestEmailConfirmation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestEmailConfirmation_args");
  static final TField _EMAIL_CONFIRMATION_FIELD_DESC = new TField("emailConfirmation", TType.STRUCT, 2);

  EmailConfirmation _emailConfirmation;
  static const int EMAILCONFIRMATION = 2;


  requestEmailConfirmation_args() {
  }

  // emailConfirmation
  EmailConfirmation get emailConfirmation => this._emailConfirmation;

  set emailConfirmation(EmailConfirmation emailConfirmation) {
    this._emailConfirmation = emailConfirmation;
  }

  bool isSetEmailConfirmation() => this.emailConfirmation != null;

  unsetEmailConfirmation() {
    this.emailConfirmation = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case EMAILCONFIRMATION:
        return this.emailConfirmation;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case EMAILCONFIRMATION:
        if (value == null) {
          unsetEmailConfirmation();
        } else {
          this.emailConfirmation = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case EMAILCONFIRMATION:
        return isSetEmailConfirmation();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case EMAILCONFIRMATION:
          if (field.type == TType.STRUCT) {
            this.emailConfirmation = new EmailConfirmation();
            this.emailConfirmation.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.emailConfirmation != null) {
      oprot.writeFieldBegin(_EMAIL_CONFIRMATION_FIELD_DESC);
      this.emailConfirmation.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestEmailConfirmation_args(");

    ret.write("emailConfirmation:");
    if (this.emailConfirmation == null) {
      ret.write("null");
    } else {
      ret.write(this.emailConfirmation);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestEmailConfirmation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestEmailConfirmation_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  EmailConfirmationSession _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  requestEmailConfirmation_result() {
  }

  // success
  EmailConfirmationSession get success => this._success;

  set success(EmailConfirmationSession success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new EmailConfirmationSession();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestEmailConfirmation_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestIdentityUnbind_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestIdentityUnbind_args");
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 4);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 2);

  int _provider;
  static const int PROVIDER = 4;
  String _identifier;
  static const int IDENTIFIER = 2;

  bool __isset_provider = false;

  requestIdentityUnbind_args() {
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return this.provider;
      case IDENTIFIER:
        return this.identifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PROVIDER:
        return isSetProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestIdentityUnbind_args(");

    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class requestIdentityUnbind_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestIdentityUnbind_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  requestIdentityUnbind_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestIdentityUnbind_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class resendEmailConfirmation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("resendEmailConfirmation_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 2);

  String _verifier;
  static const int VERIFIER = 2;


  resendEmailConfirmation_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("resendEmailConfirmation_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class resendEmailConfirmation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("resendEmailConfirmation_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  EmailConfirmationSession _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  resendEmailConfirmation_result() {
  }

  // success
  EmailConfirmationSession get success => this._success;

  set success(EmailConfirmationSession success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new EmailConfirmationSession();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("resendEmailConfirmation_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class resendPinCode_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("resendPinCode_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  resendPinCode_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("resendPinCode_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class resendPinCode_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("resendPinCode_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  resendPinCode_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("resendPinCode_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class resendPinCodeBySMS_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("resendPinCodeBySMS_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);

  String _sessionId;
  static const int SESSIONID = 2;


  resendPinCodeBySMS_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("resendPinCodeBySMS_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class resendPinCodeBySMS_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("resendPinCodeBySMS_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  resendPinCodeBySMS_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("resendPinCodeBySMS_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendChatChecked_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendChatChecked_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _CONSUMER_FIELD_DESC = new TField("consumer", TType.STRING, 2);
  static final TField _LAST_MESSAGE_ID_FIELD_DESC = new TField("lastMessageId", TType.STRING, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _consumer;
  static const int CONSUMER = 2;
  String _lastMessageId;
  static const int LASTMESSAGEID = 3;

  bool __isset_seq = false;

  sendChatChecked_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // consumer
  String get consumer => this._consumer;

  set consumer(String consumer) {
    this._consumer = consumer;
  }

  bool isSetConsumer() => this.consumer != null;

  unsetConsumer() {
    this.consumer = null;
  }

  // lastMessageId
  String get lastMessageId => this._lastMessageId;

  set lastMessageId(String lastMessageId) {
    this._lastMessageId = lastMessageId;
  }

  bool isSetLastMessageId() => this.lastMessageId != null;

  unsetLastMessageId() {
    this.lastMessageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case CONSUMER:
        return this.consumer;
      case LASTMESSAGEID:
        return this.lastMessageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case CONSUMER:
        if (value == null) {
          unsetConsumer();
        } else {
          this.consumer = value;
        }
        break;

      case LASTMESSAGEID:
        if (value == null) {
          unsetLastMessageId();
        } else {
          this.lastMessageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case CONSUMER:
        return isSetConsumer();
      case LASTMESSAGEID:
        return isSetLastMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMER:
          if (field.type == TType.STRING) {
            this.consumer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTMESSAGEID:
          if (field.type == TType.STRING) {
            this.lastMessageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.consumer != null) {
      oprot.writeFieldBegin(_CONSUMER_FIELD_DESC);
      oprot.writeString(this.consumer);
      oprot.writeFieldEnd();
    }
    if (this.lastMessageId != null) {
      oprot.writeFieldBegin(_LAST_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.lastMessageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendChatChecked_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("consumer:");
    if (this.consumer == null) {
      ret.write("null");
    } else {
      ret.write(this.consumer);
    }

    ret.write(", ");
    ret.write("lastMessageId:");
    if (this.lastMessageId == null) {
      ret.write("null");
    } else {
      ret.write(this.lastMessageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendChatChecked_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendChatChecked_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendChatChecked_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendChatChecked_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageAwaitCommit_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageAwaitCommit_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  int _seq = 0;
  static const int SEQ = 1;
  Message _message;
  static const int MESSAGE = 2;

  bool __isset_seq = false;

  sendMessageAwaitCommit_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageAwaitCommit_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageAwaitCommit_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageAwaitCommit_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  CommitMessageResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendMessageAwaitCommit_result() {
  }

  // success
  CommitMessageResult get success => this._success;

  set success(CommitMessageResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new CommitMessageResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageAwaitCommit_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendChatRemoved_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendChatRemoved_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _CONSUMER_FIELD_DESC = new TField("consumer", TType.STRING, 2);
  static final TField _LAST_MESSAGE_ID_FIELD_DESC = new TField("lastMessageId", TType.STRING, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _consumer;
  static const int CONSUMER = 2;
  String _lastMessageId;
  static const int LASTMESSAGEID = 3;

  bool __isset_seq = false;

  sendChatRemoved_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // consumer
  String get consumer => this._consumer;

  set consumer(String consumer) {
    this._consumer = consumer;
  }

  bool isSetConsumer() => this.consumer != null;

  unsetConsumer() {
    this.consumer = null;
  }

  // lastMessageId
  String get lastMessageId => this._lastMessageId;

  set lastMessageId(String lastMessageId) {
    this._lastMessageId = lastMessageId;
  }

  bool isSetLastMessageId() => this.lastMessageId != null;

  unsetLastMessageId() {
    this.lastMessageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case CONSUMER:
        return this.consumer;
      case LASTMESSAGEID:
        return this.lastMessageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case CONSUMER:
        if (value == null) {
          unsetConsumer();
        } else {
          this.consumer = value;
        }
        break;

      case LASTMESSAGEID:
        if (value == null) {
          unsetLastMessageId();
        } else {
          this.lastMessageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case CONSUMER:
        return isSetConsumer();
      case LASTMESSAGEID:
        return isSetLastMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMER:
          if (field.type == TType.STRING) {
            this.consumer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LASTMESSAGEID:
          if (field.type == TType.STRING) {
            this.lastMessageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.consumer != null) {
      oprot.writeFieldBegin(_CONSUMER_FIELD_DESC);
      oprot.writeString(this.consumer);
      oprot.writeFieldEnd();
    }
    if (this.lastMessageId != null) {
      oprot.writeFieldBegin(_LAST_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.lastMessageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendChatRemoved_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("consumer:");
    if (this.consumer == null) {
      ret.write("null");
    } else {
      ret.write(this.consumer);
    }

    ret.write(", ");
    ret.write("lastMessageId:");
    if (this.lastMessageId == null) {
      ret.write("null");
    } else {
      ret.write(this.lastMessageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendChatRemoved_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendChatRemoved_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendChatRemoved_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendChatRemoved_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendContentPreviewUpdated_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendContentPreviewUpdated_args");
  static final TField _ESQ_FIELD_DESC = new TField("esq", TType.I32, 1);
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 2);
  static final TField _RECEIVER_MIDS_FIELD_DESC = new TField("receiverMids", TType.LIST, 3);

  int _esq = 0;
  static const int ESQ = 1;
  String _messageId;
  static const int MESSAGEID = 2;
  List<String> _receiverMids;
  static const int RECEIVERMIDS = 3;

  bool __isset_esq = false;

  sendContentPreviewUpdated_args() {
  }

  // esq
  int get esq => this._esq;

  set esq(int esq) {
    this._esq = esq;
    this.__isset_esq = true;
  }

  bool isSetEsq() => this.__isset_esq;

  unsetEsq() {
    this.__isset_esq = false;
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  // receiverMids
  List<String> get receiverMids => this._receiverMids;

  set receiverMids(List<String> receiverMids) {
    this._receiverMids = receiverMids;
  }

  bool isSetReceiverMids() => this.receiverMids != null;

  unsetReceiverMids() {
    this.receiverMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ESQ:
        return this.esq;
      case MESSAGEID:
        return this.messageId;
      case RECEIVERMIDS:
        return this.receiverMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ESQ:
        if (value == null) {
          unsetEsq();
        } else {
          this.esq = value;
        }
        break;

      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      case RECEIVERMIDS:
        if (value == null) {
          unsetReceiverMids();
        } else {
          this.receiverMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ESQ:
        return isSetEsq();
      case MESSAGEID:
        return isSetMessageId();
      case RECEIVERMIDS:
        return isSetReceiverMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ESQ:
          if (field.type == TType.I32) {
            this.esq = iprot.readI32();
            this.__isset_esq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECEIVERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1154 = iprot.readListBegin();
              this.receiverMids = new List<String>();
              for (int _i1155 = 0; _i1155 < _list1154.length; ++_i1155) {
                String _elem1156;
                _elem1156 = iprot.readString();
                this.receiverMids.add(_elem1156);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ESQ_FIELD_DESC);
    oprot.writeI32(this.esq);
    oprot.writeFieldEnd();
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    if (this.receiverMids != null) {
      oprot.writeFieldBegin(_RECEIVER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.receiverMids.length));
        for (var elem1157 in this.receiverMids) {
          oprot.writeString(elem1157);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendContentPreviewUpdated_args(");

    ret.write("esq:");
    ret.write(this.esq);

    ret.write(", ");
    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(", ");
    ret.write("receiverMids:");
    if (this.receiverMids == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendContentPreviewUpdated_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendContentPreviewUpdated_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendContentPreviewUpdated_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1158 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i1159 = 0; _i1159 < _map1158.length; ++_i1159) {
                String _key1160;
                String _val1161;
                _key1160 = iprot.readString();
                _val1161 = iprot.readString();
                this.success[_key1160] = _val1161;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem1163 in this.success.keys) {
          oprot.writeString(elem1163);
          oprot.writeString(this.success[elem1163]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendContentPreviewUpdated_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendContentReceipt_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendContentReceipt_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _CONSUMER_FIELD_DESC = new TField("consumer", TType.STRING, 2);
  static final TField _MESSAGE_ID_FIELD_DESC = new TField("messageId", TType.STRING, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _consumer;
  static const int CONSUMER = 2;
  String _messageId;
  static const int MESSAGEID = 3;

  bool __isset_seq = false;

  sendContentReceipt_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // consumer
  String get consumer => this._consumer;

  set consumer(String consumer) {
    this._consumer = consumer;
  }

  bool isSetConsumer() => this.consumer != null;

  unsetConsumer() {
    this.consumer = null;
  }

  // messageId
  String get messageId => this._messageId;

  set messageId(String messageId) {
    this._messageId = messageId;
  }

  bool isSetMessageId() => this.messageId != null;

  unsetMessageId() {
    this.messageId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case CONSUMER:
        return this.consumer;
      case MESSAGEID:
        return this.messageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case CONSUMER:
        if (value == null) {
          unsetConsumer();
        } else {
          this.consumer = value;
        }
        break;

      case MESSAGEID:
        if (value == null) {
          unsetMessageId();
        } else {
          this.messageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case CONSUMER:
        return isSetConsumer();
      case MESSAGEID:
        return isSetMessageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMER:
          if (field.type == TType.STRING) {
            this.consumer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEID:
          if (field.type == TType.STRING) {
            this.messageId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.consumer != null) {
      oprot.writeFieldBegin(_CONSUMER_FIELD_DESC);
      oprot.writeString(this.consumer);
      oprot.writeFieldEnd();
    }
    if (this.messageId != null) {
      oprot.writeFieldBegin(_MESSAGE_ID_FIELD_DESC);
      oprot.writeString(this.messageId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendContentReceipt_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("consumer:");
    if (this.consumer == null) {
      ret.write("null");
    } else {
      ret.write(this.consumer);
    }

    ret.write(", ");
    ret.write("messageId:");
    if (this.messageId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendContentReceipt_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendContentReceipt_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendContentReceipt_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendContentReceipt_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendDummyPush_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendDummyPush_args");



  sendDummyPush_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendDummyPush_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendDummyPush_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendDummyPush_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendDummyPush_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendDummyPush_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeE2EEPublicKey_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeE2EEPublicKey_args");
  static final TField _PUBLIC_KEY_FIELD_DESC = new TField("publicKey", TType.STRUCT, 2);

  E2EEPublicKey _publicKey;
  static const int PUBLICKEY = 2;


  removeE2EEPublicKey_args() {
  }

  // publicKey
  E2EEPublicKey get publicKey => this._publicKey;

  set publicKey(E2EEPublicKey publicKey) {
    this._publicKey = publicKey;
  }

  bool isSetPublicKey() => this.publicKey != null;

  unsetPublicKey() {
    this.publicKey = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PUBLICKEY:
        return this.publicKey;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PUBLICKEY:
        if (value == null) {
          unsetPublicKey();
        } else {
          this.publicKey = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PUBLICKEY:
        return isSetPublicKey();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PUBLICKEY:
          if (field.type == TType.STRUCT) {
            this.publicKey = new E2EEPublicKey();
            this.publicKey.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.publicKey != null) {
      oprot.writeFieldBegin(_PUBLIC_KEY_FIELD_DESC);
      this.publicKey.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeE2EEPublicKey_args(");

    ret.write("publicKey:");
    if (this.publicKey == null) {
      ret.write("null");
    } else {
      ret.write(this.publicKey);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class removeE2EEPublicKey_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeE2EEPublicKey_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  removeE2EEPublicKey_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeE2EEPublicKey_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class negotiateE2EEPublicKey_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("negotiateE2EEPublicKey_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);

  String _mid;
  static const int MID = 2;


  negotiateE2EEPublicKey_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("negotiateE2EEPublicKey_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class negotiateE2EEPublicKey_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("negotiateE2EEPublicKey_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  E2EENegotiationResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  negotiateE2EEPublicKey_result() {
  }

  // success
  E2EENegotiationResult get success => this._success;

  set success(E2EENegotiationResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new E2EENegotiationResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("negotiateE2EEPublicKey_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getE2EEPublicKey_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getE2EEPublicKey_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);
  static final TField _VERSION_FIELD_DESC = new TField("version", TType.I32, 3);
  static final TField _KEY_ID_FIELD_DESC = new TField("keyId", TType.I32, 4);

  String _mid;
  static const int MID = 2;
  int _version = 0;
  static const int VERSION = 3;
  int _keyId = 0;
  static const int KEYID = 4;

  bool __isset_version = false;
  bool __isset_keyId = false;

  getE2EEPublicKey_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // version
  int get version => this._version;

  set version(int version) {
    this._version = version;
    this.__isset_version = true;
  }

  bool isSetVersion() => this.__isset_version;

  unsetVersion() {
    this.__isset_version = false;
  }

  // keyId
  int get keyId => this._keyId;

  set keyId(int keyId) {
    this._keyId = keyId;
    this.__isset_keyId = true;
  }

  bool isSetKeyId() => this.__isset_keyId;

  unsetKeyId() {
    this.__isset_keyId = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      case VERSION:
        return this.version;
      case KEYID:
        return this.keyId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case VERSION:
        if (value == null) {
          unsetVersion();
        } else {
          this.version = value;
        }
        break;

      case KEYID:
        if (value == null) {
          unsetKeyId();
        } else {
          this.keyId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      case VERSION:
        return isSetVersion();
      case KEYID:
        return isSetKeyId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VERSION:
          if (field.type == TType.I32) {
            this.version = iprot.readI32();
            this.__isset_version = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEYID:
          if (field.type == TType.I32) {
            this.keyId = iprot.readI32();
            this.__isset_keyId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_VERSION_FIELD_DESC);
    oprot.writeI32(this.version);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_KEY_ID_FIELD_DESC);
    oprot.writeI32(this.keyId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getE2EEPublicKey_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("version:");
    ret.write(this.version);

    ret.write(", ");
    ret.write("keyId:");
    ret.write(this.keyId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getE2EEPublicKey_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getE2EEPublicKey_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  E2EEPublicKey _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getE2EEPublicKey_result() {
  }

  // success
  E2EEPublicKey get success => this._success;

  set success(E2EEPublicKey success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new E2EEPublicKey();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getE2EEPublicKey_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestE2EEKeyExchange_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestE2EEKeyExchange_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _TEMPORAL_PUBLIC_KEY_FIELD_DESC = new TField("temporalPublicKey", TType.STRING, 2);
  static final TField _PUBLIC_KEY_FIELD_DESC = new TField("publicKey", TType.STRUCT, 3);
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 4);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Uint8List _temporalPublicKey;
  static const int TEMPORALPUBLICKEY = 2;
  E2EEPublicKey _publicKey;
  static const int PUBLICKEY = 3;
  Uint8List _verifier;
  static const int VERIFIER = 4;

  bool __isset_reqSeq = false;

  requestE2EEKeyExchange_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // temporalPublicKey
  Uint8List get temporalPublicKey => this._temporalPublicKey;

  set temporalPublicKey(Uint8List temporalPublicKey) {
    this._temporalPublicKey = temporalPublicKey;
  }

  bool isSetTemporalPublicKey() => this.temporalPublicKey != null;

  unsetTemporalPublicKey() {
    this.temporalPublicKey = null;
  }

  // publicKey
  E2EEPublicKey get publicKey => this._publicKey;

  set publicKey(E2EEPublicKey publicKey) {
    this._publicKey = publicKey;
  }

  bool isSetPublicKey() => this.publicKey != null;

  unsetPublicKey() {
    this.publicKey = null;
  }

  // verifier
  Uint8List get verifier => this._verifier;

  set verifier(Uint8List verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case TEMPORALPUBLICKEY:
        return this.temporalPublicKey;
      case PUBLICKEY:
        return this.publicKey;
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case TEMPORALPUBLICKEY:
        if (value == null) {
          unsetTemporalPublicKey();
        } else {
          this.temporalPublicKey = value;
        }
        break;

      case PUBLICKEY:
        if (value == null) {
          unsetPublicKey();
        } else {
          this.publicKey = value;
        }
        break;

      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case TEMPORALPUBLICKEY:
        return isSetTemporalPublicKey();
      case PUBLICKEY:
        return isSetPublicKey();
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TEMPORALPUBLICKEY:
          if (field.type == TType.STRING) {
            this.temporalPublicKey = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PUBLICKEY:
          if (field.type == TType.STRUCT) {
            this.publicKey = new E2EEPublicKey();
            this.publicKey.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.temporalPublicKey != null) {
      oprot.writeFieldBegin(_TEMPORAL_PUBLIC_KEY_FIELD_DESC);
      oprot.writeBinary(this.temporalPublicKey);
      oprot.writeFieldEnd();
    }
    if (this.publicKey != null) {
      oprot.writeFieldBegin(_PUBLIC_KEY_FIELD_DESC);
      this.publicKey.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeBinary(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestE2EEKeyExchange_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("temporalPublicKey:");
    if (this.temporalPublicKey == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(", ");
    ret.write("publicKey:");
    if (this.publicKey == null) {
      ret.write("null");
    } else {
      ret.write(this.publicKey);
    }

    ret.write(", ");
    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class requestE2EEKeyExchange_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("requestE2EEKeyExchange_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  requestE2EEKeyExchange_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("requestE2EEKeyExchange_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLastE2EEPublicKeys_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getLastE2EEPublicKeys_args");
  static final TField _CHAT_MID_FIELD_DESC = new TField("chatMid", TType.STRING, 2);

  String _chatMid;
  static const int CHATMID = 2;


  getLastE2EEPublicKeys_args() {
  }

  // chatMid
  String get chatMid => this._chatMid;

  set chatMid(String chatMid) {
    this._chatMid = chatMid;
  }

  bool isSetChatMid() => this.chatMid != null;

  unsetChatMid() {
    this.chatMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return this.chatMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATMID:
        if (value == null) {
          unsetChatMid();
        } else {
          this.chatMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return isSetChatMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATMID:
          if (field.type == TType.STRING) {
            this.chatMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatMid != null) {
      oprot.writeFieldBegin(_CHAT_MID_FIELD_DESC);
      oprot.writeString(this.chatMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getLastE2EEPublicKeys_args(");

    ret.write("chatMid:");
    if (this.chatMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLastE2EEPublicKeys_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getLastE2EEPublicKeys_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, E2EEPublicKey> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getLastE2EEPublicKeys_result() {
  }

  // success
  Map<String, E2EEPublicKey> get success => this._success;

  set success(Map<String, E2EEPublicKey> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1164 = iprot.readMapBegin();
              this.success = new Map<String, E2EEPublicKey>();
              for (int _i1165 = 0; _i1165 < _map1164.length; ++_i1165) {
                String _key1166;
                E2EEPublicKey _val1167;
                _key1166 = iprot.readString();
                _val1167 = new E2EEPublicKey();
                _val1167.read(iprot);
                this.success[_key1166] = _val1167;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem1169 in this.success.keys) {
          oprot.writeString(elem1169);
          this.success[elem1169].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getLastE2EEPublicKeys_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerE2EEPublicKey_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerE2EEPublicKey_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _PUBLIC_KEY_FIELD_DESC = new TField("publicKey", TType.STRUCT, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  E2EEPublicKey _publicKey;
  static const int PUBLICKEY = 2;

  bool __isset_reqSeq = false;

  registerE2EEPublicKey_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // publicKey
  E2EEPublicKey get publicKey => this._publicKey;

  set publicKey(E2EEPublicKey publicKey) {
    this._publicKey = publicKey;
  }

  bool isSetPublicKey() => this.publicKey != null;

  unsetPublicKey() {
    this.publicKey = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case PUBLICKEY:
        return this.publicKey;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case PUBLICKEY:
        if (value == null) {
          unsetPublicKey();
        } else {
          this.publicKey = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case PUBLICKEY:
        return isSetPublicKey();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PUBLICKEY:
          if (field.type == TType.STRUCT) {
            this.publicKey = new E2EEPublicKey();
            this.publicKey.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.publicKey != null) {
      oprot.writeFieldBegin(_PUBLIC_KEY_FIELD_DESC);
      this.publicKey.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerE2EEPublicKey_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("publicKey:");
    if (this.publicKey == null) {
      ret.write("null");
    } else {
      ret.write(this.publicKey);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerE2EEPublicKey_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerE2EEPublicKey_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  E2EEPublicKey _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerE2EEPublicKey_result() {
  }

  // success
  E2EEPublicKey get success => this._success;

  set success(E2EEPublicKey success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new E2EEPublicKey();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerE2EEPublicKey_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getE2EEPublicKeys_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getE2EEPublicKeys_args");



  getE2EEPublicKeys_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getE2EEPublicKeys_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getE2EEPublicKeys_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getE2EEPublicKeys_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<E2EEPublicKey> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getE2EEPublicKeys_result() {
  }

  // success
  List<E2EEPublicKey> get success => this._success;

  set success(List<E2EEPublicKey> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1170 = iprot.readListBegin();
              this.success = new List<E2EEPublicKey>();
              for (int _i1171 = 0; _i1171 < _list1170.length; ++_i1171) {
                E2EEPublicKey _elem1172;
                _elem1172 = new E2EEPublicKey();
                _elem1172.read(iprot);
                this.success.add(_elem1172);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1173 in this.success) {
          elem1173.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getE2EEPublicKeys_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getE2EEPublicKeysEx_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getE2EEPublicKeysEx_args");
  static final TField _IGNORE_E2_EESTATUS_FIELD_DESC = new TField("ignoreE2EEStatus", TType.BOOL, 2);

  bool _ignoreE2EEStatus = false;
  static const int IGNOREE2EESTATUS = 2;

  bool __isset_ignoreE2EEStatus = false;

  getE2EEPublicKeysEx_args() {
  }

  // ignoreE2EEStatus
  bool get ignoreE2EEStatus => this._ignoreE2EEStatus;

  set ignoreE2EEStatus(bool ignoreE2EEStatus) {
    this._ignoreE2EEStatus = ignoreE2EEStatus;
    this.__isset_ignoreE2EEStatus = true;
  }

  bool isSetIgnoreE2EEStatus() => this.__isset_ignoreE2EEStatus;

  unsetIgnoreE2EEStatus() {
    this.__isset_ignoreE2EEStatus = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IGNOREE2EESTATUS:
        return this.ignoreE2EEStatus;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IGNOREE2EESTATUS:
        if (value == null) {
          unsetIgnoreE2EEStatus();
        } else {
          this.ignoreE2EEStatus = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IGNOREE2EESTATUS:
        return isSetIgnoreE2EEStatus();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IGNOREE2EESTATUS:
          if (field.type == TType.BOOL) {
            this.ignoreE2EEStatus = iprot.readBool();
            this.__isset_ignoreE2EEStatus = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_IGNORE_E2_EESTATUS_FIELD_DESC);
    oprot.writeBool(this.ignoreE2EEStatus);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getE2EEPublicKeysEx_args(");

    ret.write("ignoreE2EEStatus:");
    ret.write(this.ignoreE2EEStatus);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getE2EEPublicKeysEx_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getE2EEPublicKeysEx_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<E2EEPublicKey> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getE2EEPublicKeysEx_result() {
  }

  // success
  List<E2EEPublicKey> get success => this._success;

  set success(List<E2EEPublicKey> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1174 = iprot.readListBegin();
              this.success = new List<E2EEPublicKey>();
              for (int _i1175 = 0; _i1175 < _list1174.length; ++_i1175) {
                E2EEPublicKey _elem1176;
                _elem1176 = new E2EEPublicKey();
                _elem1176.read(iprot);
                this.success.add(_elem1176);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1177 in this.success) {
          elem1177.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getE2EEPublicKeysEx_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getReadMessageOpsInBulk_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getReadMessageOpsInBulk_args");
  static final TField _CHAT_IDS_FIELD_DESC = new TField("chatIds", TType.LIST, 2);

  List<String> _chatIds;
  static const int CHATIDS = 2;


  getReadMessageOpsInBulk_args() {
  }

  // chatIds
  List<String> get chatIds => this._chatIds;

  set chatIds(List<String> chatIds) {
    this._chatIds = chatIds;
  }

  bool isSetChatIds() => this.chatIds != null;

  unsetChatIds() {
    this.chatIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATIDS:
        return this.chatIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATIDS:
        if (value == null) {
          unsetChatIds();
        } else {
          this.chatIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATIDS:
        return isSetChatIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1178 = iprot.readListBegin();
              this.chatIds = new List<String>();
              for (int _i1179 = 0; _i1179 < _list1178.length; ++_i1179) {
                String _elem1180;
                _elem1180 = iprot.readString();
                this.chatIds.add(_elem1180);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatIds != null) {
      oprot.writeFieldBegin(_CHAT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.chatIds.length));
        for (var elem1181 in this.chatIds) {
          oprot.writeString(elem1181);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getReadMessageOpsInBulk_args(");

    ret.write("chatIds:");
    if (this.chatIds == null) {
      ret.write("null");
    } else {
      ret.write(this.chatIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getReadMessageOpsInBulk_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getReadMessageOpsInBulk_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Operation> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getReadMessageOpsInBulk_result() {
  }

  // success
  List<Operation> get success => this._success;

  set success(List<Operation> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1182 = iprot.readListBegin();
              this.success = new List<Operation>();
              for (int _i1183 = 0; _i1183 < _list1182.length; ++_i1183) {
                Operation _elem1184;
                _elem1184 = new Operation();
                _elem1184.read(iprot);
                this.success.add(_elem1184);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1185 in this.success) {
          elem1185.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getReadMessageOpsInBulk_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendEvent_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendEvent_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  int _seq = 0;
  static const int SEQ = 1;
  Message _message;
  static const int MESSAGE = 2;

  bool __isset_seq = false;

  sendEvent_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendEvent_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendEvent_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendEvent_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendEvent_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendEvent_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessage_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  int _seq = 0;
  static const int SEQ = 1;
  Message _message;
  static const int MESSAGE = 2;

  bool __isset_seq = false;

  sendMessage_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessage_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessage_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendMessage_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessage_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageIgnored_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageIgnored_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _CONSUMER_FIELD_DESC = new TField("consumer", TType.STRING, 2);
  static final TField _MESSAGE_IDS_FIELD_DESC = new TField("messageIds", TType.LIST, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _consumer;
  static const int CONSUMER = 2;
  List<String> _messageIds;
  static const int MESSAGEIDS = 3;

  bool __isset_seq = false;

  sendMessageIgnored_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // consumer
  String get consumer => this._consumer;

  set consumer(String consumer) {
    this._consumer = consumer;
  }

  bool isSetConsumer() => this.consumer != null;

  unsetConsumer() {
    this.consumer = null;
  }

  // messageIds
  List<String> get messageIds => this._messageIds;

  set messageIds(List<String> messageIds) {
    this._messageIds = messageIds;
  }

  bool isSetMessageIds() => this.messageIds != null;

  unsetMessageIds() {
    this.messageIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case CONSUMER:
        return this.consumer;
      case MESSAGEIDS:
        return this.messageIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case CONSUMER:
        if (value == null) {
          unsetConsumer();
        } else {
          this.consumer = value;
        }
        break;

      case MESSAGEIDS:
        if (value == null) {
          unsetMessageIds();
        } else {
          this.messageIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case CONSUMER:
        return isSetConsumer();
      case MESSAGEIDS:
        return isSetMessageIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMER:
          if (field.type == TType.STRING) {
            this.consumer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1186 = iprot.readListBegin();
              this.messageIds = new List<String>();
              for (int _i1187 = 0; _i1187 < _list1186.length; ++_i1187) {
                String _elem1188;
                _elem1188 = iprot.readString();
                this.messageIds.add(_elem1188);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.consumer != null) {
      oprot.writeFieldBegin(_CONSUMER_FIELD_DESC);
      oprot.writeString(this.consumer);
      oprot.writeFieldEnd();
    }
    if (this.messageIds != null) {
      oprot.writeFieldBegin(_MESSAGE_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.messageIds.length));
        for (var elem1189 in this.messageIds) {
          oprot.writeString(elem1189);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageIgnored_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("consumer:");
    if (this.consumer == null) {
      ret.write("null");
    } else {
      ret.write(this.consumer);
    }

    ret.write(", ");
    ret.write("messageIds:");
    if (this.messageIds == null) {
      ret.write("null");
    } else {
      ret.write(this.messageIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageIgnored_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageIgnored_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendMessageIgnored_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageIgnored_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageReceipt_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageReceipt_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _CONSUMER_FIELD_DESC = new TField("consumer", TType.STRING, 2);
  static final TField _MESSAGE_IDS_FIELD_DESC = new TField("messageIds", TType.LIST, 3);

  int _seq = 0;
  static const int SEQ = 1;
  String _consumer;
  static const int CONSUMER = 2;
  List<String> _messageIds;
  static const int MESSAGEIDS = 3;

  bool __isset_seq = false;

  sendMessageReceipt_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // consumer
  String get consumer => this._consumer;

  set consumer(String consumer) {
    this._consumer = consumer;
  }

  bool isSetConsumer() => this.consumer != null;

  unsetConsumer() {
    this.consumer = null;
  }

  // messageIds
  List<String> get messageIds => this._messageIds;

  set messageIds(List<String> messageIds) {
    this._messageIds = messageIds;
  }

  bool isSetMessageIds() => this.messageIds != null;

  unsetMessageIds() {
    this.messageIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case CONSUMER:
        return this.consumer;
      case MESSAGEIDS:
        return this.messageIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case CONSUMER:
        if (value == null) {
          unsetConsumer();
        } else {
          this.consumer = value;
        }
        break;

      case MESSAGEIDS:
        if (value == null) {
          unsetMessageIds();
        } else {
          this.messageIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case CONSUMER:
        return isSetConsumer();
      case MESSAGEIDS:
        return isSetMessageIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMER:
          if (field.type == TType.STRING) {
            this.consumer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGEIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1190 = iprot.readListBegin();
              this.messageIds = new List<String>();
              for (int _i1191 = 0; _i1191 < _list1190.length; ++_i1191) {
                String _elem1192;
                _elem1192 = iprot.readString();
                this.messageIds.add(_elem1192);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.consumer != null) {
      oprot.writeFieldBegin(_CONSUMER_FIELD_DESC);
      oprot.writeString(this.consumer);
      oprot.writeFieldEnd();
    }
    if (this.messageIds != null) {
      oprot.writeFieldBegin(_MESSAGE_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.messageIds.length));
        for (var elem1193 in this.messageIds) {
          oprot.writeString(elem1193);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageReceipt_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("consumer:");
    if (this.consumer == null) {
      ret.write("null");
    } else {
      ret.write(this.consumer);
    }

    ret.write(", ");
    ret.write("messageIds:");
    if (this.messageIds == null) {
      ret.write("null");
    } else {
      ret.write(this.messageIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageReceipt_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageReceipt_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendMessageReceipt_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageReceipt_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByMetaTag_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByMetaTag_args");
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);
  static final TField _REFERENCE_FIELD_DESC = new TField("reference", TType.STRING, 3);

  String _userid;
  static const int USERID = 2;
  String _reference;
  static const int REFERENCE = 3;


  findContactByMetaTag_args() {
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  // reference
  String get reference => this._reference;

  set reference(String reference) {
    this._reference = reference;
  }

  bool isSetReference() => this.reference != null;

  unsetReference() {
    this.reference = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERID:
        return this.userid;
      case REFERENCE:
        return this.reference;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      case REFERENCE:
        if (value == null) {
          unsetReference();
        } else {
          this.reference = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERID:
        return isSetUserid();
      case REFERENCE:
        return isSetReference();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REFERENCE:
          if (field.type == TType.STRING) {
            this.reference = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    if (this.reference != null) {
      oprot.writeFieldBegin(_REFERENCE_FIELD_DESC);
      oprot.writeString(this.reference);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByMetaTag_args(");

    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(", ");
    ret.write("reference:");
    if (this.reference == null) {
      ret.write("null");
    } else {
      ret.write(this.reference);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByMetaTag_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByMetaTag_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findContactByMetaTag_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByMetaTag_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageToMyHome_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageToMyHome_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  int _seq = 0;
  static const int SEQ = 1;
  Message _message;
  static const int MESSAGE = 2;

  bool __isset_seq = false;

  sendMessageToMyHome_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageToMyHome_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageToMyHome_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageToMyHome_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendMessageToMyHome_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageToMyHome_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setBuddyLocation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setBuddyLocation_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);
  static final TField _INDEX_FIELD_DESC = new TField("index", TType.I32, 3);
  static final TField _LOCATION_FIELD_DESC = new TField("location", TType.STRUCT, 4);

  String _mid;
  static const int MID = 2;
  int _index = 0;
  static const int INDEX = 3;
  Geolocation _location;
  static const int LOCATION = 4;

  bool __isset_index = false;

  setBuddyLocation_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // index
  int get index => this._index;

  set index(int index) {
    this._index = index;
    this.__isset_index = true;
  }

  bool isSetIndex() => this.__isset_index;

  unsetIndex() {
    this.__isset_index = false;
  }

  // location
  Geolocation get location => this._location;

  set location(Geolocation location) {
    this._location = location;
  }

  bool isSetLocation() => this.location != null;

  unsetLocation() {
    this.location = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      case INDEX:
        return this.index;
      case LOCATION:
        return this.location;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case INDEX:
        if (value == null) {
          unsetIndex();
        } else {
          this.index = value;
        }
        break;

      case LOCATION:
        if (value == null) {
          unsetLocation();
        } else {
          this.location = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      case INDEX:
        return isSetIndex();
      case LOCATION:
        return isSetLocation();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INDEX:
          if (field.type == TType.I32) {
            this.index = iprot.readI32();
            this.__isset_index = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCATION:
          if (field.type == TType.STRUCT) {
            this.location = new Geolocation();
            this.location.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_INDEX_FIELD_DESC);
    oprot.writeI32(this.index);
    oprot.writeFieldEnd();
    if (this.location != null) {
      oprot.writeFieldBegin(_LOCATION_FIELD_DESC);
      this.location.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setBuddyLocation_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("index:");
    ret.write(this.index);

    ret.write(", ");
    ret.write("location:");
    if (this.location == null) {
      ret.write("null");
    } else {
      ret.write(this.location);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setBuddyLocation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setBuddyLocation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  setBuddyLocation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setBuddyLocation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setIdentityCredential_args");
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 2);
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 3);
  static final TField _PROVIDER_FIELD_DESC = new TField("provider", TType.I32, 4);

  String _identifier;
  static const int IDENTIFIER = 2;
  String _verifier;
  static const int VERIFIER = 3;
  int _provider;
  static const int PROVIDER = 4;

  bool __isset_provider = false;

  setIdentityCredential_args() {
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  // provider
  int get provider => this._provider;

  set provider(int provider) {
    this._provider = provider;
    this.__isset_provider = true;
  }

  bool isSetProvider() => this.__isset_provider;

  unsetProvider() {
    this.__isset_provider = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDENTIFIER:
        return this.identifier;
      case VERIFIER:
        return this.verifier;
      case PROVIDER:
        return this.provider;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      case PROVIDER:
        if (value == null) {
          unsetProvider();
        } else {
          this.provider = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDENTIFIER:
        return isSetIdentifier();
      case VERIFIER:
        return isSetVerifier();
      case PROVIDER:
        return isSetProvider();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PROVIDER:
          if (field.type == TType.I32) {
            this.provider = iprot.readI32();
            this.__isset_provider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.provider);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setIdentityCredential_args(");

    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(", ");
    ret.write("provider:");
    String provider_name = IdentityProvider.VALUES_TO_NAMES[this.provider];
    if (provider_name != null) {
      ret.write(provider_name);
      ret.write(" (");
    }
    ret.write(this.provider);
    if (provider_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProvider() && !IdentityProvider.VALID_VALUES.contains(provider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'provider' has been assigned the invalid value $provider");
    }
  }

}

class setIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setIdentityCredential_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  setIdentityCredential_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setIdentityCredential_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setNotificationsEnabled_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setNotificationsEnabled_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _TYPE_FIELD_DESC = new TField("type", TType.I32, 2);
  static final TField _TARGET_FIELD_DESC = new TField("target", TType.STRING, 3);
  static final TField _ENABLEMENT_FIELD_DESC = new TField("enablement", TType.BOOL, 4);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  int _type;
  static const int TYPE = 2;
  String _target;
  static const int TARGET = 3;
  bool _enablement = false;
  static const int ENABLEMENT = 4;

  bool __isset_reqSeq = false;
  bool __isset_type = false;
  bool __isset_enablement = false;

  setNotificationsEnabled_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // type
  int get type => this._type;

  set type(int type) {
    this._type = type;
    this.__isset_type = true;
  }

  bool isSetType() => this.__isset_type;

  unsetType() {
    this.__isset_type = false;
  }

  // target
  String get target => this._target;

  set target(String target) {
    this._target = target;
  }

  bool isSetTarget() => this.target != null;

  unsetTarget() {
    this.target = null;
  }

  // enablement
  bool get enablement => this._enablement;

  set enablement(bool enablement) {
    this._enablement = enablement;
    this.__isset_enablement = true;
  }

  bool isSetEnablement() => this.__isset_enablement;

  unsetEnablement() {
    this.__isset_enablement = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case TYPE:
        return this.type;
      case TARGET:
        return this.target;
      case ENABLEMENT:
        return this.enablement;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          this.type = value;
        }
        break;

      case TARGET:
        if (value == null) {
          unsetTarget();
        } else {
          this.target = value;
        }
        break;

      case ENABLEMENT:
        if (value == null) {
          unsetEnablement();
        } else {
          this.enablement = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case TYPE:
        return isSetType();
      case TARGET:
        return isSetTarget();
      case ENABLEMENT:
        return isSetEnablement();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TYPE:
          if (field.type == TType.I32) {
            this.type = iprot.readI32();
            this.__isset_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TARGET:
          if (field.type == TType.STRING) {
            this.target = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ENABLEMENT:
          if (field.type == TType.BOOL) {
            this.enablement = iprot.readBool();
            this.__isset_enablement = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_TYPE_FIELD_DESC);
    oprot.writeI32(this.type);
    oprot.writeFieldEnd();
    if (this.target != null) {
      oprot.writeFieldBegin(_TARGET_FIELD_DESC);
      oprot.writeString(this.target);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_ENABLEMENT_FIELD_DESC);
    oprot.writeBool(this.enablement);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setNotificationsEnabled_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("type:");
    String type_name = MIDType.VALUES_TO_NAMES[this.type];
    if (type_name != null) {
      ret.write(type_name);
      ret.write(" (");
    }
    ret.write(this.type);
    if (type_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("target:");
    if (this.target == null) {
      ret.write("null");
    } else {
      ret.write(this.target);
    }

    ret.write(", ");
    ret.write("enablement:");
    ret.write(this.enablement);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetType() && !MIDType.VALID_VALUES.contains(type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'type' has been assigned the invalid value $type");
    }
  }

}

class setNotificationsEnabled_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setNotificationsEnabled_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  setNotificationsEnabled_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setNotificationsEnabled_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class startUpdateVerification_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("startUpdateVerification_args");
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 2);
  static final TField _CARRIER_FIELD_DESC = new TField("carrier", TType.I32, 3);
  static final TField _PHONE_FIELD_DESC = new TField("phone", TType.STRING, 4);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 5);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 6);
  static final TField _NETWORK_CODE_FIELD_DESC = new TField("networkCode", TType.STRING, 7);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 8);

  String _region;
  static const int REGION = 2;
  int _carrier;
  static const int CARRIER = 3;
  String _phone;
  static const int PHONE = 4;
  String _udidHash;
  static const int UDIDHASH = 5;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 6;
  String _networkCode;
  static const int NETWORKCODE = 7;
  String _locale;
  static const int LOCALE = 8;

  bool __isset_carrier = false;

  startUpdateVerification_args() {
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // carrier
  int get carrier => this._carrier;

  set carrier(int carrier) {
    this._carrier = carrier;
    this.__isset_carrier = true;
  }

  bool isSetCarrier() => this.__isset_carrier;

  unsetCarrier() {
    this.__isset_carrier = false;
  }

  // phone
  String get phone => this._phone;

  set phone(String phone) {
    this._phone = phone;
  }

  bool isSetPhone() => this.phone != null;

  unsetPhone() {
    this.phone = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  // networkCode
  String get networkCode => this._networkCode;

  set networkCode(String networkCode) {
    this._networkCode = networkCode;
  }

  bool isSetNetworkCode() => this.networkCode != null;

  unsetNetworkCode() {
    this.networkCode = null;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGION:
        return this.region;
      case CARRIER:
        return this.carrier;
      case PHONE:
        return this.phone;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      case NETWORKCODE:
        return this.networkCode;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case CARRIER:
        if (value == null) {
          unsetCarrier();
        } else {
          this.carrier = value;
        }
        break;

      case PHONE:
        if (value == null) {
          unsetPhone();
        } else {
          this.phone = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      case NETWORKCODE:
        if (value == null) {
          unsetNetworkCode();
        } else {
          this.networkCode = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGION:
        return isSetRegion();
      case CARRIER:
        return isSetCarrier();
      case PHONE:
        return isSetPhone();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      case NETWORKCODE:
        return isSetNetworkCode();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CARRIER:
          if (field.type == TType.I32) {
            this.carrier = iprot.readI32();
            this.__isset_carrier = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PHONE:
          if (field.type == TType.STRING) {
            this.phone = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NETWORKCODE:
          if (field.type == TType.STRING) {
            this.networkCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_CARRIER_FIELD_DESC);
    oprot.writeI32(this.carrier);
    oprot.writeFieldEnd();
    if (this.phone != null) {
      oprot.writeFieldBegin(_PHONE_FIELD_DESC);
      oprot.writeString(this.phone);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.networkCode != null) {
      oprot.writeFieldBegin(_NETWORK_CODE_FIELD_DESC);
      oprot.writeString(this.networkCode);
      oprot.writeFieldEnd();
    }
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("startUpdateVerification_args(");

    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("carrier:");
    String carrier_name = CarrierCode.VALUES_TO_NAMES[this.carrier];
    if (carrier_name != null) {
      ret.write(carrier_name);
      ret.write(" (");
    }
    ret.write(this.carrier);
    if (carrier_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("phone:");
    if (this.phone == null) {
      ret.write("null");
    } else {
      ret.write(this.phone);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(", ");
    ret.write("networkCode:");
    if (this.networkCode == null) {
      ret.write("null");
    } else {
      ret.write(this.networkCode);
    }

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCarrier() && !CarrierCode.VALID_VALUES.contains(carrier)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'carrier' has been assigned the invalid value $carrier");
    }
  }

}

class startUpdateVerification_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("startUpdateVerification_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  VerificationSessionData _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  startUpdateVerification_result() {
  }

  // success
  VerificationSessionData get success => this._success;

  set success(VerificationSessionData success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new VerificationSessionData();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("startUpdateVerification_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class startVerification_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("startVerification_args");
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 2);
  static final TField _CARRIER_FIELD_DESC = new TField("carrier", TType.I32, 3);
  static final TField _PHONE_FIELD_DESC = new TField("phone", TType.STRING, 4);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 5);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 6);
  static final TField _NETWORK_CODE_FIELD_DESC = new TField("networkCode", TType.STRING, 7);
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 8);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 9);
  static final TField _SIM_INFO_FIELD_DESC = new TField("simInfo", TType.STRUCT, 10);
  static final TField _OLD_UDID_HASH_FIELD_DESC = new TField("oldUdidHash", TType.STRING, 11);

  String _region;
  static const int REGION = 2;
  int _carrier;
  static const int CARRIER = 3;
  String _phone;
  static const int PHONE = 4;
  String _udidHash;
  static const int UDIDHASH = 5;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 6;
  String _networkCode;
  static const int NETWORKCODE = 7;
  String _mid;
  static const int MID = 8;
  String _locale;
  static const int LOCALE = 9;
  SIMInfo _simInfo;
  static const int SIMINFO = 10;
  String _oldUdidHash;
  static const int OLDUDIDHASH = 11;

  bool __isset_carrier = false;

  startVerification_args() {
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // carrier
  int get carrier => this._carrier;

  set carrier(int carrier) {
    this._carrier = carrier;
    this.__isset_carrier = true;
  }

  bool isSetCarrier() => this.__isset_carrier;

  unsetCarrier() {
    this.__isset_carrier = false;
  }

  // phone
  String get phone => this._phone;

  set phone(String phone) {
    this._phone = phone;
  }

  bool isSetPhone() => this.phone != null;

  unsetPhone() {
    this.phone = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  // networkCode
  String get networkCode => this._networkCode;

  set networkCode(String networkCode) {
    this._networkCode = networkCode;
  }

  bool isSetNetworkCode() => this.networkCode != null;

  unsetNetworkCode() {
    this.networkCode = null;
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  // simInfo
  SIMInfo get simInfo => this._simInfo;

  set simInfo(SIMInfo simInfo) {
    this._simInfo = simInfo;
  }

  bool isSetSimInfo() => this.simInfo != null;

  unsetSimInfo() {
    this.simInfo = null;
  }

  // oldUdidHash
  String get oldUdidHash => this._oldUdidHash;

  set oldUdidHash(String oldUdidHash) {
    this._oldUdidHash = oldUdidHash;
  }

  bool isSetOldUdidHash() => this.oldUdidHash != null;

  unsetOldUdidHash() {
    this.oldUdidHash = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGION:
        return this.region;
      case CARRIER:
        return this.carrier;
      case PHONE:
        return this.phone;
      case UDIDHASH:
        return this.udidHash;
      case DEVICEINFO:
        return this.deviceInfo;
      case NETWORKCODE:
        return this.networkCode;
      case MID:
        return this.mid;
      case LOCALE:
        return this.locale;
      case SIMINFO:
        return this.simInfo;
      case OLDUDIDHASH:
        return this.oldUdidHash;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case CARRIER:
        if (value == null) {
          unsetCarrier();
        } else {
          this.carrier = value;
        }
        break;

      case PHONE:
        if (value == null) {
          unsetPhone();
        } else {
          this.phone = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      case NETWORKCODE:
        if (value == null) {
          unsetNetworkCode();
        } else {
          this.networkCode = value;
        }
        break;

      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      case SIMINFO:
        if (value == null) {
          unsetSimInfo();
        } else {
          this.simInfo = value;
        }
        break;

      case OLDUDIDHASH:
        if (value == null) {
          unsetOldUdidHash();
        } else {
          this.oldUdidHash = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGION:
        return isSetRegion();
      case CARRIER:
        return isSetCarrier();
      case PHONE:
        return isSetPhone();
      case UDIDHASH:
        return isSetUdidHash();
      case DEVICEINFO:
        return isSetDeviceInfo();
      case NETWORKCODE:
        return isSetNetworkCode();
      case MID:
        return isSetMid();
      case LOCALE:
        return isSetLocale();
      case SIMINFO:
        return isSetSimInfo();
      case OLDUDIDHASH:
        return isSetOldUdidHash();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CARRIER:
          if (field.type == TType.I32) {
            this.carrier = iprot.readI32();
            this.__isset_carrier = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PHONE:
          if (field.type == TType.STRING) {
            this.phone = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NETWORKCODE:
          if (field.type == TType.STRING) {
            this.networkCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIMINFO:
          if (field.type == TType.STRUCT) {
            this.simInfo = new SIMInfo();
            this.simInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OLDUDIDHASH:
          if (field.type == TType.STRING) {
            this.oldUdidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_CARRIER_FIELD_DESC);
    oprot.writeI32(this.carrier);
    oprot.writeFieldEnd();
    if (this.phone != null) {
      oprot.writeFieldBegin(_PHONE_FIELD_DESC);
      oprot.writeString(this.phone);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.networkCode != null) {
      oprot.writeFieldBegin(_NETWORK_CODE_FIELD_DESC);
      oprot.writeString(this.networkCode);
      oprot.writeFieldEnd();
    }
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    if (this.simInfo != null) {
      oprot.writeFieldBegin(_SIM_INFO_FIELD_DESC);
      this.simInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.oldUdidHash != null) {
      oprot.writeFieldBegin(_OLD_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.oldUdidHash);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("startVerification_args(");

    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("carrier:");
    String carrier_name = CarrierCode.VALUES_TO_NAMES[this.carrier];
    if (carrier_name != null) {
      ret.write(carrier_name);
      ret.write(" (");
    }
    ret.write(this.carrier);
    if (carrier_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("phone:");
    if (this.phone == null) {
      ret.write("null");
    } else {
      ret.write(this.phone);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(", ");
    ret.write("networkCode:");
    if (this.networkCode == null) {
      ret.write("null");
    } else {
      ret.write(this.networkCode);
    }

    ret.write(", ");
    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(", ");
    ret.write("simInfo:");
    if (this.simInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.simInfo);
    }

    ret.write(", ");
    ret.write("oldUdidHash:");
    if (this.oldUdidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.oldUdidHash);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCarrier() && !CarrierCode.VALID_VALUES.contains(carrier)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'carrier' has been assigned the invalid value $carrier");
    }
  }

}

class startVerification_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("startVerification_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  VerificationSessionData _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  startVerification_result() {
  }

  // success
  VerificationSessionData get success => this._success;

  set success(VerificationSessionData success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new VerificationSessionData();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("startVerification_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateGroupPreferenceAttribute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateGroupPreferenceAttribute_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_MID_FIELD_DESC = new TField("groupMid", TType.STRING, 2);
  static final TField _UPDATED_ATTRS_FIELD_DESC = new TField("updatedAttrs", TType.MAP, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _groupMid;
  static const int GROUPMID = 2;
  Map<int, String> _updatedAttrs;
  static const int UPDATEDATTRS = 3;

  bool __isset_reqSeq = false;

  updateGroupPreferenceAttribute_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // groupMid
  String get groupMid => this._groupMid;

  set groupMid(String groupMid) {
    this._groupMid = groupMid;
  }

  bool isSetGroupMid() => this.groupMid != null;

  unsetGroupMid() {
    this.groupMid = null;
  }

  // updatedAttrs
  Map<int, String> get updatedAttrs => this._updatedAttrs;

  set updatedAttrs(Map<int, String> updatedAttrs) {
    this._updatedAttrs = updatedAttrs;
  }

  bool isSetUpdatedAttrs() => this.updatedAttrs != null;

  unsetUpdatedAttrs() {
    this.updatedAttrs = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUPMID:
        return this.groupMid;
      case UPDATEDATTRS:
        return this.updatedAttrs;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUPMID:
        if (value == null) {
          unsetGroupMid();
        } else {
          this.groupMid = value;
        }
        break;

      case UPDATEDATTRS:
        if (value == null) {
          unsetUpdatedAttrs();
        } else {
          this.updatedAttrs = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUPMID:
        return isSetGroupMid();
      case UPDATEDATTRS:
        return isSetUpdatedAttrs();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUPMID:
          if (field.type == TType.STRING) {
            this.groupMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UPDATEDATTRS:
          if (field.type == TType.MAP) {
            {
              TMap _map1194 = iprot.readMapBegin();
              this.updatedAttrs = new Map<int, String>();
              for (int _i1195 = 0; _i1195 < _map1194.length; ++_i1195) {
                int _key1196;
                String _val1197;
                _key1196 = iprot.readI32();
                _val1197 = iprot.readString();
                this.updatedAttrs[_key1196] = _val1197;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.groupMid != null) {
      oprot.writeFieldBegin(_GROUP_MID_FIELD_DESC);
      oprot.writeString(this.groupMid);
      oprot.writeFieldEnd();
    }
    if (this.updatedAttrs != null) {
      oprot.writeFieldBegin(_UPDATED_ATTRS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, this.updatedAttrs.length));
        for (var elem1199 in this.updatedAttrs.keys) {
          oprot.writeI32(elem1199);
          oprot.writeString(this.updatedAttrs[elem1199]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateGroupPreferenceAttribute_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("groupMid:");
    if (this.groupMid == null) {
      ret.write("null");
    } else {
      ret.write(this.groupMid);
    }

    ret.write(", ");
    ret.write("updatedAttrs:");
    if (this.updatedAttrs == null) {
      ret.write("null");
    } else {
      ret.write(this.updatedAttrs);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateGroupPreferenceAttribute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateGroupPreferenceAttribute_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateGroupPreferenceAttribute_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateGroupPreferenceAttribute_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createRoomV2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createRoomV2_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  List<String> _contactIds;
  static const int CONTACTIDS = 2;

  bool __isset_reqSeq = false;

  createRoomV2_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1200 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i1201 = 0; _i1201 < _list1200.length; ++_i1201) {
                String _elem1202;
                _elem1202 = iprot.readString();
                this.contactIds.add(_elem1202);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem1203 in this.contactIds) {
          oprot.writeString(elem1203);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createRoomV2_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createRoomV2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createRoomV2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Room _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createRoomV2_result() {
  }

  // success
  Room get success => this._success;

  set success(Room success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Room();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createRoomV2_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class storeUpdateProfileAttribute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("storeUpdateProfileAttribute_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _PROFILE_ATTRIBUTE_FIELD_DESC = new TField("profileAttribute", TType.I32, 2);
  static final TField _VALUE_FIELD_DESC = new TField("value", TType.STRING, 3);

  int _seq = 0;
  static const int SEQ = 1;
  int _profileAttribute;
  static const int PROFILEATTRIBUTE = 2;
  String _value;
  static const int VALUE = 3;

  bool __isset_seq = false;
  bool __isset_profileAttribute = false;

  storeUpdateProfileAttribute_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // profileAttribute
  int get profileAttribute => this._profileAttribute;

  set profileAttribute(int profileAttribute) {
    this._profileAttribute = profileAttribute;
    this.__isset_profileAttribute = true;
  }

  bool isSetProfileAttribute() => this.__isset_profileAttribute;

  unsetProfileAttribute() {
    this.__isset_profileAttribute = false;
  }

  // value
  String get value => this._value;

  set value(String value) {
    this._value = value;
  }

  bool isSetValue() => this.value != null;

  unsetValue() {
    this.value = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case PROFILEATTRIBUTE:
        return this.profileAttribute;
      case VALUE:
        return this.value;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case PROFILEATTRIBUTE:
        if (value == null) {
          unsetProfileAttribute();
        } else {
          this.profileAttribute = value;
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          this.value = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case PROFILEATTRIBUTE:
        return isSetProfileAttribute();
      case VALUE:
        return isSetValue();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PROFILEATTRIBUTE:
          if (field.type == TType.I32) {
            this.profileAttribute = iprot.readI32();
            this.__isset_profileAttribute = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_PROFILE_ATTRIBUTE_FIELD_DESC);
    oprot.writeI32(this.profileAttribute);
    oprot.writeFieldEnd();
    if (this.value != null) {
      oprot.writeFieldBegin(_VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("storeUpdateProfileAttribute_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("profileAttribute:");
    String profileAttribute_name = ProfileAttribute.VALUES_TO_NAMES[this.profileAttribute];
    if (profileAttribute_name != null) {
      ret.write(profileAttribute_name);
      ret.write(" (");
    }
    ret.write(this.profileAttribute);
    if (profileAttribute_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("value:");
    if (this.value == null) {
      ret.write("null");
    } else {
      ret.write(this.value);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProfileAttribute() && !ProfileAttribute.VALID_VALUES.contains(profileAttribute)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'profileAttribute' has been assigned the invalid value $profileAttribute");
    }
  }

}

class storeUpdateProfileAttribute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("storeUpdateProfileAttribute_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  storeUpdateProfileAttribute_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("storeUpdateProfileAttribute_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class syncContactBySnsIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("syncContactBySnsIds_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _MODIFICATIONS_FIELD_DESC = new TField("modifications", TType.LIST, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  List<SnsFriendModification> _modifications;
  static const int MODIFICATIONS = 2;

  bool __isset_reqSeq = false;

  syncContactBySnsIds_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // modifications
  List<SnsFriendModification> get modifications => this._modifications;

  set modifications(List<SnsFriendModification> modifications) {
    this._modifications = modifications;
  }

  bool isSetModifications() => this.modifications != null;

  unsetModifications() {
    this.modifications = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case MODIFICATIONS:
        return this.modifications;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case MODIFICATIONS:
        if (value == null) {
          unsetModifications();
        } else {
          this.modifications = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case MODIFICATIONS:
        return isSetModifications();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MODIFICATIONS:
          if (field.type == TType.LIST) {
            {
              TList _list1204 = iprot.readListBegin();
              this.modifications = new List<SnsFriendModification>();
              for (int _i1205 = 0; _i1205 < _list1204.length; ++_i1205) {
                SnsFriendModification _elem1206;
                _elem1206 = new SnsFriendModification();
                _elem1206.read(iprot);
                this.modifications.add(_elem1206);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.modifications != null) {
      oprot.writeFieldBegin(_MODIFICATIONS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.modifications.length));
        for (var elem1207 in this.modifications) {
          elem1207.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("syncContactBySnsIds_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("modifications:");
    if (this.modifications == null) {
      ret.write("null");
    } else {
      ret.write(this.modifications);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class syncContactBySnsIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("syncContactBySnsIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<SnsFriendContactRegistration> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  syncContactBySnsIds_result() {
  }

  // success
  List<SnsFriendContactRegistration> get success => this._success;

  set success(List<SnsFriendContactRegistration> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1208 = iprot.readListBegin();
              this.success = new List<SnsFriendContactRegistration>();
              for (int _i1209 = 0; _i1209 < _list1208.length; ++_i1209) {
                SnsFriendContactRegistration _elem1210;
                _elem1210 = new SnsFriendContactRegistration();
                _elem1210.read(iprot);
                this.success.add(_elem1210);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1211 in this.success) {
          elem1211.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("syncContactBySnsIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class syncContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("syncContacts_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _LOCAL_CONTACTS_FIELD_DESC = new TField("localContacts", TType.LIST, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  List<ContactModification> _localContacts;
  static const int LOCALCONTACTS = 2;

  bool __isset_reqSeq = false;

  syncContacts_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // localContacts
  List<ContactModification> get localContacts => this._localContacts;

  set localContacts(List<ContactModification> localContacts) {
    this._localContacts = localContacts;
  }

  bool isSetLocalContacts() => this.localContacts != null;

  unsetLocalContacts() {
    this.localContacts = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case LOCALCONTACTS:
        return this.localContacts;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case LOCALCONTACTS:
        if (value == null) {
          unsetLocalContacts();
        } else {
          this.localContacts = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case LOCALCONTACTS:
        return isSetLocalContacts();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALCONTACTS:
          if (field.type == TType.LIST) {
            {
              TList _list1212 = iprot.readListBegin();
              this.localContacts = new List<ContactModification>();
              for (int _i1213 = 0; _i1213 < _list1212.length; ++_i1213) {
                ContactModification _elem1214;
                _elem1214 = new ContactModification();
                _elem1214.read(iprot);
                this.localContacts.add(_elem1214);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.localContacts != null) {
      oprot.writeFieldBegin(_LOCAL_CONTACTS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.localContacts.length));
        for (var elem1215 in this.localContacts) {
          elem1215.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("syncContacts_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("localContacts:");
    if (this.localContacts == null) {
      ret.write("null");
    } else {
      ret.write(this.localContacts);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class syncContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("syncContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, ContactRegistration> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  syncContacts_result() {
  }

  // success
  Map<String, ContactRegistration> get success => this._success;

  set success(Map<String, ContactRegistration> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1216 = iprot.readMapBegin();
              this.success = new Map<String, ContactRegistration>();
              for (int _i1217 = 0; _i1217 < _map1216.length; ++_i1217) {
                String _key1218;
                ContactRegistration _val1219;
                _key1218 = iprot.readString();
                _val1219 = new ContactRegistration();
                _val1219.read(iprot);
                this.success[_key1218] = _val1219;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem1221 in this.success.keys) {
          oprot.writeString(elem1221);
          this.success[elem1221].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("syncContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class trySendMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("trySendMessage_args");
  static final TField _SEQ_FIELD_DESC = new TField("seq", TType.I32, 1);
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  int _seq = 0;
  static const int SEQ = 1;
  Message _message;
  static const int MESSAGE = 2;

  bool __isset_seq = false;

  trySendMessage_args() {
  }

  // seq
  int get seq => this._seq;

  set seq(int seq) {
    this._seq = seq;
    this.__isset_seq = true;
  }

  bool isSetSeq() => this.__isset_seq;

  unsetSeq() {
    this.__isset_seq = false;
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return this.seq;
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SEQ:
        if (value == null) {
          unsetSeq();
        } else {
          this.seq = value;
        }
        break;

      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SEQ:
        return isSetSeq();
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQ:
          if (field.type == TType.I32) {
            this.seq = iprot.readI32();
            this.__isset_seq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQ_FIELD_DESC);
    oprot.writeI32(this.seq);
    oprot.writeFieldEnd();
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("trySendMessage_args(");

    ret.write("seq:");
    ret.write(this.seq);

    ret.write(", ");
    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class trySendMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("trySendMessage_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  trySendMessage_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("trySendMessage_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNextMessagesV2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNextMessagesV2_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);
  static final TField _START_MESSAGE_ID_FIELD_DESC = new TField("startMessageId", TType.STRUCT, 3);
  static final TField _MESSAGES_COUNT_FIELD_DESC = new TField("messagesCount", TType.I32, 4);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;
  MessageBoxV2MessageId _startMessageId;
  static const int STARTMESSAGEID = 3;
  int _messagesCount = 0;
  static const int MESSAGESCOUNT = 4;

  bool __isset_messagesCount = false;

  getNextMessagesV2_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // startMessageId
  MessageBoxV2MessageId get startMessageId => this._startMessageId;

  set startMessageId(MessageBoxV2MessageId startMessageId) {
    this._startMessageId = startMessageId;
  }

  bool isSetStartMessageId() => this.startMessageId != null;

  unsetStartMessageId() {
    this.startMessageId = null;
  }

  // messagesCount
  int get messagesCount => this._messagesCount;

  set messagesCount(int messagesCount) {
    this._messagesCount = messagesCount;
    this.__isset_messagesCount = true;
  }

  bool isSetMessagesCount() => this.__isset_messagesCount;

  unsetMessagesCount() {
    this.__isset_messagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      case STARTMESSAGEID:
        return this.startMessageId;
      case MESSAGESCOUNT:
        return this.messagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case STARTMESSAGEID:
        if (value == null) {
          unsetStartMessageId();
        } else {
          this.startMessageId = value;
        }
        break;

      case MESSAGESCOUNT:
        if (value == null) {
          unsetMessagesCount();
        } else {
          this.messagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case STARTMESSAGEID:
        return isSetStartMessageId();
      case MESSAGESCOUNT:
        return isSetMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STARTMESSAGEID:
          if (field.type == TType.STRUCT) {
            this.startMessageId = new MessageBoxV2MessageId();
            this.startMessageId.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.messagesCount = iprot.readI32();
            this.__isset_messagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    if (this.startMessageId != null) {
      oprot.writeFieldBegin(_START_MESSAGE_ID_FIELD_DESC);
      this.startMessageId.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.messagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNextMessagesV2_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("startMessageId:");
    if (this.startMessageId == null) {
      ret.write("null");
    } else {
      ret.write(this.startMessageId);
    }

    ret.write(", ");
    ret.write("messagesCount:");
    ret.write(this.messagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNextMessagesV2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNextMessagesV2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getNextMessagesV2_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1222 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1223 = 0; _i1223 < _list1222.length; ++_i1223) {
                Message _elem1224;
                _elem1224 = new Message();
                _elem1224.read(iprot);
                this.success.add(_elem1224);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1225 in this.success) {
          elem1225.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNextMessagesV2_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxCompactWrapUpV2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxCompactWrapUpV2_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;


  getMessageBoxCompactWrapUpV2_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxCompactWrapUpV2_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMessageBoxCompactWrapUpV2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMessageBoxCompactWrapUpV2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMessageBoxWrapUp _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMessageBoxCompactWrapUpV2_result() {
  }

  // success
  TMessageBoxWrapUp get success => this._success;

  set success(TMessageBoxWrapUp success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMessageBoxWrapUp();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMessageBoxCompactWrapUpV2_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRecentMessagesV2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRecentMessagesV2_args");
  static final TField _MESSAGE_BOX_ID_FIELD_DESC = new TField("messageBoxId", TType.STRING, 2);
  static final TField _MESSAGES_COUNT_FIELD_DESC = new TField("messagesCount", TType.I32, 3);

  String _messageBoxId;
  static const int MESSAGEBOXID = 2;
  int _messagesCount = 0;
  static const int MESSAGESCOUNT = 3;

  bool __isset_messagesCount = false;

  getRecentMessagesV2_args() {
  }

  // messageBoxId
  String get messageBoxId => this._messageBoxId;

  set messageBoxId(String messageBoxId) {
    this._messageBoxId = messageBoxId;
  }

  bool isSetMessageBoxId() => this.messageBoxId != null;

  unsetMessageBoxId() {
    this.messageBoxId = null;
  }

  // messagesCount
  int get messagesCount => this._messagesCount;

  set messagesCount(int messagesCount) {
    this._messagesCount = messagesCount;
    this.__isset_messagesCount = true;
  }

  bool isSetMessagesCount() => this.__isset_messagesCount;

  unsetMessagesCount() {
    this.__isset_messagesCount = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return this.messageBoxId;
      case MESSAGESCOUNT:
        return this.messagesCount;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGEBOXID:
        if (value == null) {
          unsetMessageBoxId();
        } else {
          this.messageBoxId = value;
        }
        break;

      case MESSAGESCOUNT:
        if (value == null) {
          unsetMessagesCount();
        } else {
          this.messagesCount = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGEBOXID:
        return isSetMessageBoxId();
      case MESSAGESCOUNT:
        return isSetMessagesCount();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGEBOXID:
          if (field.type == TType.STRING) {
            this.messageBoxId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGESCOUNT:
          if (field.type == TType.I32) {
            this.messagesCount = iprot.readI32();
            this.__isset_messagesCount = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.messageBoxId != null) {
      oprot.writeFieldBegin(_MESSAGE_BOX_ID_FIELD_DESC);
      oprot.writeString(this.messageBoxId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MESSAGES_COUNT_FIELD_DESC);
    oprot.writeI32(this.messagesCount);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRecentMessagesV2_args(");

    ret.write("messageBoxId:");
    if (this.messageBoxId == null) {
      ret.write("null");
    } else {
      ret.write(this.messageBoxId);
    }

    ret.write(", ");
    ret.write("messagesCount:");
    ret.write(this.messagesCount);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRecentMessagesV2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRecentMessagesV2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Message> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRecentMessagesV2_result() {
  }

  // success
  List<Message> get success => this._success;

  set success(List<Message> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1226 = iprot.readListBegin();
              this.success = new List<Message>();
              for (int _i1227 = 0; _i1227 < _list1226.length; ++_i1227) {
                Message _elem1228;
                _elem1228 = new Message();
                _elem1228.read(iprot);
                this.success.add(_elem1228);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1229 in this.success) {
          elem1229.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRecentMessagesV2_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class validateContactsOnBot_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("validateContactsOnBot_args");
  static final TField _CONTACTS_FIELD_DESC = new TField("contacts", TType.LIST, 2);

  List<String> _contacts;
  static const int CONTACTS = 2;


  validateContactsOnBot_args() {
  }

  // contacts
  List<String> get contacts => this._contacts;

  set contacts(List<String> contacts) {
    this._contacts = contacts;
  }

  bool isSetContacts() => this.contacts != null;

  unsetContacts() {
    this.contacts = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CONTACTS:
        return this.contacts;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CONTACTS:
        if (value == null) {
          unsetContacts();
        } else {
          this.contacts = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CONTACTS:
        return isSetContacts();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CONTACTS:
          if (field.type == TType.LIST) {
            {
              TList _list1230 = iprot.readListBegin();
              this.contacts = new List<String>();
              for (int _i1231 = 0; _i1231 < _list1230.length; ++_i1231) {
                String _elem1232;
                _elem1232 = iprot.readString();
                this.contacts.add(_elem1232);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.contacts != null) {
      oprot.writeFieldBegin(_CONTACTS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contacts.length));
        for (var elem1233 in this.contacts) {
          oprot.writeString(elem1233);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("validateContactsOnBot_args(");

    ret.write("contacts:");
    if (this.contacts == null) {
      ret.write("null");
    } else {
      ret.write(this.contacts);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class validateContactsOnBot_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("validateContactsOnBot_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  validateContactsOnBot_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1234 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i1235 = 0; _i1235 < _map1234.length; ++_i1235) {
                String _key1236;
                String _val1237;
                _key1236 = iprot.readString();
                _val1237 = iprot.readString();
                this.success[_key1236] = _val1237;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem1239 in this.success.keys) {
          oprot.writeString(elem1239);
          oprot.writeString(this.success[elem1239]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("validateContactsOnBot_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class tryFriendRequest_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("tryFriendRequest_args");
  static final TField _MID_OR_EMID_FIELD_DESC = new TField("midOrEMid", TType.STRING, 1);
  static final TField _METHOD_FIELD_DESC = new TField("method", TType.I32, 2);
  static final TField _FRIEND_REQUEST_PARAMS_FIELD_DESC = new TField("friendRequestParams", TType.STRING, 3);

  String _midOrEMid;
  static const int MIDOREMID = 1;
  int _method;
  static const int METHOD = 2;
  String _friendRequestParams;
  static const int FRIENDREQUESTPARAMS = 3;

  bool __isset_method = false;

  tryFriendRequest_args() {
  }

  // midOrEMid
  String get midOrEMid => this._midOrEMid;

  set midOrEMid(String midOrEMid) {
    this._midOrEMid = midOrEMid;
  }

  bool isSetMidOrEMid() => this.midOrEMid != null;

  unsetMidOrEMid() {
    this.midOrEMid = null;
  }

  // method
  int get method => this._method;

  set method(int method) {
    this._method = method;
    this.__isset_method = true;
  }

  bool isSetMethod() => this.__isset_method;

  unsetMethod() {
    this.__isset_method = false;
  }

  // friendRequestParams
  String get friendRequestParams => this._friendRequestParams;

  set friendRequestParams(String friendRequestParams) {
    this._friendRequestParams = friendRequestParams;
  }

  bool isSetFriendRequestParams() => this.friendRequestParams != null;

  unsetFriendRequestParams() {
    this.friendRequestParams = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MIDOREMID:
        return this.midOrEMid;
      case METHOD:
        return this.method;
      case FRIENDREQUESTPARAMS:
        return this.friendRequestParams;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MIDOREMID:
        if (value == null) {
          unsetMidOrEMid();
        } else {
          this.midOrEMid = value;
        }
        break;

      case METHOD:
        if (value == null) {
          unsetMethod();
        } else {
          this.method = value;
        }
        break;

      case FRIENDREQUESTPARAMS:
        if (value == null) {
          unsetFriendRequestParams();
        } else {
          this.friendRequestParams = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MIDOREMID:
        return isSetMidOrEMid();
      case METHOD:
        return isSetMethod();
      case FRIENDREQUESTPARAMS:
        return isSetFriendRequestParams();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MIDOREMID:
          if (field.type == TType.STRING) {
            this.midOrEMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case METHOD:
          if (field.type == TType.I32) {
            this.method = iprot.readI32();
            this.__isset_method = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FRIENDREQUESTPARAMS:
          if (field.type == TType.STRING) {
            this.friendRequestParams = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.midOrEMid != null) {
      oprot.writeFieldBegin(_MID_OR_EMID_FIELD_DESC);
      oprot.writeString(this.midOrEMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_METHOD_FIELD_DESC);
    oprot.writeI32(this.method);
    oprot.writeFieldEnd();
    if (this.friendRequestParams != null) {
      oprot.writeFieldBegin(_FRIEND_REQUEST_PARAMS_FIELD_DESC);
      oprot.writeString(this.friendRequestParams);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("tryFriendRequest_args(");

    ret.write("midOrEMid:");
    if (this.midOrEMid == null) {
      ret.write("null");
    } else {
      ret.write(this.midOrEMid);
    }

    ret.write(", ");
    ret.write("method:");
    String method_name = FriendRequestMethod.VALUES_TO_NAMES[this.method];
    if (method_name != null) {
      ret.write(method_name);
      ret.write(" (");
    }
    ret.write(this.method);
    if (method_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("friendRequestParams:");
    if (this.friendRequestParams == null) {
      ret.write("null");
    } else {
      ret.write(this.friendRequestParams);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetMethod() && !FriendRequestMethod.VALID_VALUES.contains(method)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'method' has been assigned the invalid value $method");
    }
  }

}

class tryFriendRequest_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("tryFriendRequest_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  tryFriendRequest_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("tryFriendRequest_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unblockContact_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unblockContact_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ID_FIELD_DESC = new TField("id", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _id;
  static const int ID = 2;

  bool __isset_reqSeq = false;

  unblockContact_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // id
  String get id => this._id;

  set id(String id) {
    this._id = id;
  }

  bool isSetId() => this.id != null;

  unsetId() {
    this.id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ID:
        return this.id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ID:
        return isSetId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.STRING) {
            this.id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.id != null) {
      oprot.writeFieldBegin(_ID_FIELD_DESC);
      oprot.writeString(this.id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unblockContact_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("id:");
    if (this.id == null) {
      ret.write("null");
    } else {
      ret.write(this.id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unblockContact_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unblockContact_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  unblockContact_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unblockContact_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unblockRecommendation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unblockRecommendation_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ID_FIELD_DESC = new TField("id", TType.STRING, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _id;
  static const int ID = 2;

  bool __isset_reqSeq = false;

  unblockRecommendation_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // id
  String get id => this._id;

  set id(String id) {
    this._id = id;
  }

  bool isSetId() => this.id != null;

  unsetId() {
    this.id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ID:
        return this.id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ID:
        return isSetId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.STRING) {
            this.id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.id != null) {
      oprot.writeFieldBegin(_ID_FIELD_DESC);
      oprot.writeString(this.id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unblockRecommendation_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("id:");
    if (this.id == null) {
      ret.write("null");
    } else {
      ret.write(this.id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unblockRecommendation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unblockRecommendation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  unblockRecommendation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unblockRecommendation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unregisterUserAndDevice_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unregisterUserAndDevice_args");



  unregisterUserAndDevice_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unregisterUserAndDevice_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unregisterUserAndDevice_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("unregisterUserAndDevice_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  unregisterUserAndDevice_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("unregisterUserAndDevice_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateApnsDeviceToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateApnsDeviceToken_args");
  static final TField _APNS_DEVICE_TOKEN_FIELD_DESC = new TField("apnsDeviceToken", TType.STRING, 2);

  Uint8List _apnsDeviceToken;
  static const int APNSDEVICETOKEN = 2;


  updateApnsDeviceToken_args() {
  }

  // apnsDeviceToken
  Uint8List get apnsDeviceToken => this._apnsDeviceToken;

  set apnsDeviceToken(Uint8List apnsDeviceToken) {
    this._apnsDeviceToken = apnsDeviceToken;
  }

  bool isSetApnsDeviceToken() => this.apnsDeviceToken != null;

  unsetApnsDeviceToken() {
    this.apnsDeviceToken = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case APNSDEVICETOKEN:
        return this.apnsDeviceToken;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case APNSDEVICETOKEN:
        if (value == null) {
          unsetApnsDeviceToken();
        } else {
          this.apnsDeviceToken = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case APNSDEVICETOKEN:
        return isSetApnsDeviceToken();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case APNSDEVICETOKEN:
          if (field.type == TType.STRING) {
            this.apnsDeviceToken = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.apnsDeviceToken != null) {
      oprot.writeFieldBegin(_APNS_DEVICE_TOKEN_FIELD_DESC);
      oprot.writeBinary(this.apnsDeviceToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateApnsDeviceToken_args(");

    ret.write("apnsDeviceToken:");
    if (this.apnsDeviceToken == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateApnsDeviceToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateApnsDeviceToken_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateApnsDeviceToken_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateApnsDeviceToken_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateBuddySetting_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateBuddySetting_args");
  static final TField _KEY_FIELD_DESC = new TField("key", TType.STRING, 2);
  static final TField _VALUE_FIELD_DESC = new TField("value", TType.STRING, 3);

  String _key;
  static const int KEY = 2;
  String _value;
  static const int VALUE = 3;


  updateBuddySetting_args() {
  }

  // key
  String get key => this._key;

  set key(String key) {
    this._key = key;
  }

  bool isSetKey() => this.key != null;

  unsetKey() {
    this.key = null;
  }

  // value
  String get value => this._value;

  set value(String value) {
    this._value = value;
  }

  bool isSetValue() => this.value != null;

  unsetValue() {
    this.value = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case KEY:
        return this.key;
      case VALUE:
        return this.value;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          this.key = value;
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          this.value = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case KEY:
        return isSetKey();
      case VALUE:
        return isSetValue();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.key != null) {
      oprot.writeFieldBegin(_KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    if (this.value != null) {
      oprot.writeFieldBegin(_VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateBuddySetting_args(");

    ret.write("key:");
    if (this.key == null) {
      ret.write("null");
    } else {
      ret.write(this.key);
    }

    ret.write(", ");
    ret.write("value:");
    if (this.value == null) {
      ret.write("null");
    } else {
      ret.write(this.value);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateBuddySetting_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateBuddySetting_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateBuddySetting_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateBuddySetting_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateC2DMRegistrationId_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateC2DMRegistrationId_args");
  static final TField _REGISTRATION_ID_FIELD_DESC = new TField("registrationId", TType.STRING, 2);

  String _registrationId;
  static const int REGISTRATIONID = 2;


  updateC2DMRegistrationId_args() {
  }

  // registrationId
  String get registrationId => this._registrationId;

  set registrationId(String registrationId) {
    this._registrationId = registrationId;
  }

  bool isSetRegistrationId() => this.registrationId != null;

  unsetRegistrationId() {
    this.registrationId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGISTRATIONID:
        return this.registrationId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGISTRATIONID:
        if (value == null) {
          unsetRegistrationId();
        } else {
          this.registrationId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGISTRATIONID:
        return isSetRegistrationId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGISTRATIONID:
          if (field.type == TType.STRING) {
            this.registrationId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.registrationId != null) {
      oprot.writeFieldBegin(_REGISTRATION_ID_FIELD_DESC);
      oprot.writeString(this.registrationId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateC2DMRegistrationId_args(");

    ret.write("registrationId:");
    if (this.registrationId == null) {
      ret.write("null");
    } else {
      ret.write(this.registrationId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateC2DMRegistrationId_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateC2DMRegistrationId_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateC2DMRegistrationId_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateC2DMRegistrationId_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateContactSetting_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateContactSetting_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);
  static final TField _FLAG_FIELD_DESC = new TField("flag", TType.I32, 3);
  static final TField _VALUE_FIELD_DESC = new TField("value", TType.STRING, 4);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _mid;
  static const int MID = 2;
  int _flag;
  static const int FLAG = 3;
  String _value;
  static const int VALUE = 4;

  bool __isset_reqSeq = false;
  bool __isset_flag = false;

  updateContactSetting_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  // flag
  int get flag => this._flag;

  set flag(int flag) {
    this._flag = flag;
    this.__isset_flag = true;
  }

  bool isSetFlag() => this.__isset_flag;

  unsetFlag() {
    this.__isset_flag = false;
  }

  // value
  String get value => this._value;

  set value(String value) {
    this._value = value;
  }

  bool isSetValue() => this.value != null;

  unsetValue() {
    this.value = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case MID:
        return this.mid;
      case FLAG:
        return this.flag;
      case VALUE:
        return this.value;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      case FLAG:
        if (value == null) {
          unsetFlag();
        } else {
          this.flag = value;
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          this.value = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case MID:
        return isSetMid();
      case FLAG:
        return isSetFlag();
      case VALUE:
        return isSetValue();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FLAG:
          if (field.type == TType.I32) {
            this.flag = iprot.readI32();
            this.__isset_flag = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_FLAG_FIELD_DESC);
    oprot.writeI32(this.flag);
    oprot.writeFieldEnd();
    if (this.value != null) {
      oprot.writeFieldBegin(_VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateContactSetting_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(", ");
    ret.write("flag:");
    String flag_name = ContactSetting.VALUES_TO_NAMES[this.flag];
    if (flag_name != null) {
      ret.write(flag_name);
      ret.write(" (");
    }
    ret.write(this.flag);
    if (flag_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("value:");
    if (this.value == null) {
      ret.write("null");
    } else {
      ret.write(this.value);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetFlag() && !ContactSetting.VALID_VALUES.contains(flag)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'flag' has been assigned the invalid value $flag");
    }
  }

}

class updateContactSetting_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateContactSetting_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateContactSetting_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateContactSetting_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateCustomModeSettings_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateCustomModeSettings_args");
  static final TField _CUSTOM_MODE_FIELD_DESC = new TField("customMode", TType.I32, 2);
  static final TField _PARAM_MAP_FIELD_DESC = new TField("paramMap", TType.MAP, 3);

  int _customMode;
  static const int CUSTOMMODE = 2;
  Map<String, String> _paramMap;
  static const int PARAMMAP = 3;

  bool __isset_customMode = false;

  updateCustomModeSettings_args() {
  }

  // customMode
  int get customMode => this._customMode;

  set customMode(int customMode) {
    this._customMode = customMode;
    this.__isset_customMode = true;
  }

  bool isSetCustomMode() => this.__isset_customMode;

  unsetCustomMode() {
    this.__isset_customMode = false;
  }

  // paramMap
  Map<String, String> get paramMap => this._paramMap;

  set paramMap(Map<String, String> paramMap) {
    this._paramMap = paramMap;
  }

  bool isSetParamMap() => this.paramMap != null;

  unsetParamMap() {
    this.paramMap = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CUSTOMMODE:
        return this.customMode;
      case PARAMMAP:
        return this.paramMap;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CUSTOMMODE:
        if (value == null) {
          unsetCustomMode();
        } else {
          this.customMode = value;
        }
        break;

      case PARAMMAP:
        if (value == null) {
          unsetParamMap();
        } else {
          this.paramMap = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CUSTOMMODE:
        return isSetCustomMode();
      case PARAMMAP:
        return isSetParamMap();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CUSTOMMODE:
          if (field.type == TType.I32) {
            this.customMode = iprot.readI32();
            this.__isset_customMode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAMMAP:
          if (field.type == TType.MAP) {
            {
              TMap _map1240 = iprot.readMapBegin();
              this.paramMap = new Map<String, String>();
              for (int _i1241 = 0; _i1241 < _map1240.length; ++_i1241) {
                String _key1242;
                String _val1243;
                _key1242 = iprot.readString();
                _val1243 = iprot.readString();
                this.paramMap[_key1242] = _val1243;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_CUSTOM_MODE_FIELD_DESC);
    oprot.writeI32(this.customMode);
    oprot.writeFieldEnd();
    if (this.paramMap != null) {
      oprot.writeFieldBegin(_PARAM_MAP_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.paramMap.length));
        for (var elem1245 in this.paramMap.keys) {
          oprot.writeString(elem1245);
          oprot.writeString(this.paramMap[elem1245]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateCustomModeSettings_args(");

    ret.write("customMode:");
    String customMode_name = CustomMode.VALUES_TO_NAMES[this.customMode];
    if (customMode_name != null) {
      ret.write(customMode_name);
      ret.write(" (");
    }
    ret.write(this.customMode);
    if (customMode_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("paramMap:");
    if (this.paramMap == null) {
      ret.write("null");
    } else {
      ret.write(this.paramMap);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetCustomMode() && !CustomMode.VALID_VALUES.contains(customMode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'customMode' has been assigned the invalid value $customMode");
    }
  }

}

class updateCustomModeSettings_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateCustomModeSettings_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateCustomModeSettings_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateCustomModeSettings_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateDeviceInfo_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateDeviceInfo_args");
  static final TField _DEVICE_UID_FIELD_DESC = new TField("deviceUid", TType.STRING, 2);
  static final TField _DEVICE_INFO_FIELD_DESC = new TField("deviceInfo", TType.STRUCT, 3);

  String _deviceUid;
  static const int DEVICEUID = 2;
  DeviceInfo _deviceInfo;
  static const int DEVICEINFO = 3;


  updateDeviceInfo_args() {
  }

  // deviceUid
  String get deviceUid => this._deviceUid;

  set deviceUid(String deviceUid) {
    this._deviceUid = deviceUid;
  }

  bool isSetDeviceUid() => this.deviceUid != null;

  unsetDeviceUid() {
    this.deviceUid = null;
  }

  // deviceInfo
  DeviceInfo get deviceInfo => this._deviceInfo;

  set deviceInfo(DeviceInfo deviceInfo) {
    this._deviceInfo = deviceInfo;
  }

  bool isSetDeviceInfo() => this.deviceInfo != null;

  unsetDeviceInfo() {
    this.deviceInfo = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case DEVICEUID:
        return this.deviceUid;
      case DEVICEINFO:
        return this.deviceInfo;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case DEVICEUID:
        if (value == null) {
          unsetDeviceUid();
        } else {
          this.deviceUid = value;
        }
        break;

      case DEVICEINFO:
        if (value == null) {
          unsetDeviceInfo();
        } else {
          this.deviceInfo = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case DEVICEUID:
        return isSetDeviceUid();
      case DEVICEINFO:
        return isSetDeviceInfo();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DEVICEUID:
          if (field.type == TType.STRING) {
            this.deviceUid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICEINFO:
          if (field.type == TType.STRUCT) {
            this.deviceInfo = new DeviceInfo();
            this.deviceInfo.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.deviceUid != null) {
      oprot.writeFieldBegin(_DEVICE_UID_FIELD_DESC);
      oprot.writeString(this.deviceUid);
      oprot.writeFieldEnd();
    }
    if (this.deviceInfo != null) {
      oprot.writeFieldBegin(_DEVICE_INFO_FIELD_DESC);
      this.deviceInfo.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateDeviceInfo_args(");

    ret.write("deviceUid:");
    if (this.deviceUid == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceUid);
    }

    ret.write(", ");
    ret.write("deviceInfo:");
    if (this.deviceInfo == null) {
      ret.write("null");
    } else {
      ret.write(this.deviceInfo);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateDeviceInfo_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateDeviceInfo_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateDeviceInfo_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateDeviceInfo_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateGroup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateGroup_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _GROUP_FIELD_DESC = new TField("group", TType.STRUCT, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Group _group;
  static const int GROUP = 2;

  bool __isset_reqSeq = false;

  updateGroup_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // group
  Group get group => this._group;

  set group(Group group) {
    this._group = group;
  }

  bool isSetGroup() => this.group != null;

  unsetGroup() {
    this.group = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case GROUP:
        return this.group;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case GROUP:
        if (value == null) {
          unsetGroup();
        } else {
          this.group = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case GROUP:
        return isSetGroup();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GROUP:
          if (field.type == TType.STRUCT) {
            this.group = new Group();
            this.group.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.group != null) {
      oprot.writeFieldBegin(_GROUP_FIELD_DESC);
      this.group.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateGroup_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("group:");
    if (this.group == null) {
      ret.write("null");
    } else {
      ret.write(this.group);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateGroup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateGroup_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateGroup_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateGroup_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateNotificationToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateNotificationToken_args");
  static final TField _TYPE_FIELD_DESC = new TField("type", TType.I32, 3);
  static final TField _TOKEN_FIELD_DESC = new TField("token", TType.STRING, 2);

  int _type;
  static const int TYPE = 3;
  String _token;
  static const int TOKEN = 2;

  bool __isset_type = false;

  updateNotificationToken_args() {
  }

  // type
  int get type => this._type;

  set type(int type) {
    this._type = type;
    this.__isset_type = true;
  }

  bool isSetType() => this.__isset_type;

  unsetType() {
    this.__isset_type = false;
  }

  // token
  String get token => this._token;

  set token(String token) {
    this._token = token;
  }

  bool isSetToken() => this.token != null;

  unsetToken() {
    this.token = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TYPE:
        return this.type;
      case TOKEN:
        return this.token;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          this.type = value;
        }
        break;

      case TOKEN:
        if (value == null) {
          unsetToken();
        } else {
          this.token = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TYPE:
        return isSetType();
      case TOKEN:
        return isSetToken();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TYPE:
          if (field.type == TType.I32) {
            this.type = iprot.readI32();
            this.__isset_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.token != null) {
      oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
      oprot.writeString(this.token);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_TYPE_FIELD_DESC);
    oprot.writeI32(this.type);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateNotificationToken_args(");

    ret.write("type:");
    String type_name = NotificationType.VALUES_TO_NAMES[this.type];
    if (type_name != null) {
      ret.write(type_name);
      ret.write(" (");
    }
    ret.write(this.type);
    if (type_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("token:");
    if (this.token == null) {
      ret.write("null");
    } else {
      ret.write(this.token);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetType() && !NotificationType.VALID_VALUES.contains(type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'type' has been assigned the invalid value $type");
    }
  }

}

class updateNotificationToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateNotificationToken_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateNotificationToken_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateNotificationToken_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateNotificationTokenWithBytes_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateNotificationTokenWithBytes_args");
  static final TField _TYPE_FIELD_DESC = new TField("type", TType.I32, 3);
  static final TField _TOKEN_FIELD_DESC = new TField("token", TType.STRING, 2);

  int _type;
  static const int TYPE = 3;
  Uint8List _token;
  static const int TOKEN = 2;

  bool __isset_type = false;

  updateNotificationTokenWithBytes_args() {
  }

  // type
  int get type => this._type;

  set type(int type) {
    this._type = type;
    this.__isset_type = true;
  }

  bool isSetType() => this.__isset_type;

  unsetType() {
    this.__isset_type = false;
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  bool isSetToken() => this.token != null;

  unsetToken() {
    this.token = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case TYPE:
        return this.type;
      case TOKEN:
        return this.token;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          this.type = value;
        }
        break;

      case TOKEN:
        if (value == null) {
          unsetToken();
        } else {
          this.token = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case TYPE:
        return isSetType();
      case TOKEN:
        return isSetToken();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TYPE:
          if (field.type == TType.I32) {
            this.type = iprot.readI32();
            this.__isset_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.token != null) {
      oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
      oprot.writeBinary(this.token);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_TYPE_FIELD_DESC);
    oprot.writeI32(this.type);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateNotificationTokenWithBytes_args(");

    ret.write("type:");
    String type_name = NotificationType.VALUES_TO_NAMES[this.type];
    if (type_name != null) {
      ret.write(type_name);
      ret.write(" (");
    }
    ret.write(this.type);
    if (type_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("token:");
    if (this.token == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetType() && !NotificationType.VALID_VALUES.contains(type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'type' has been assigned the invalid value $type");
    }
  }

}

class updateNotificationTokenWithBytes_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateNotificationTokenWithBytes_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateNotificationTokenWithBytes_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateNotificationTokenWithBytes_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateProfile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateProfile_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _PROFILE_FIELD_DESC = new TField("profile", TType.STRUCT, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Profile _profile;
  static const int PROFILE = 2;

  bool __isset_reqSeq = false;

  updateProfile_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // profile
  Profile get profile => this._profile;

  set profile(Profile profile) {
    this._profile = profile;
  }

  bool isSetProfile() => this.profile != null;

  unsetProfile() {
    this.profile = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case PROFILE:
        return this.profile;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case PROFILE:
        if (value == null) {
          unsetProfile();
        } else {
          this.profile = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case PROFILE:
        return isSetProfile();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PROFILE:
          if (field.type == TType.STRUCT) {
            this.profile = new Profile();
            this.profile.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.profile != null) {
      oprot.writeFieldBegin(_PROFILE_FIELD_DESC);
      this.profile.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateProfile_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("profile:");
    if (this.profile == null) {
      ret.write("null");
    } else {
      ret.write(this.profile);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateProfile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateProfile_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateProfile_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateProfile_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateProfileAttribute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateProfileAttribute_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ATTR_FIELD_DESC = new TField("attr", TType.I32, 2);
  static final TField _VALUE_FIELD_DESC = new TField("value", TType.STRING, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  int _attr;
  static const int ATTR = 2;
  String _value;
  static const int VALUE = 3;

  bool __isset_reqSeq = false;
  bool __isset_attr = false;

  updateProfileAttribute_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // attr
  int get attr => this._attr;

  set attr(int attr) {
    this._attr = attr;
    this.__isset_attr = true;
  }

  bool isSetAttr() => this.__isset_attr;

  unsetAttr() {
    this.__isset_attr = false;
  }

  // value
  String get value => this._value;

  set value(String value) {
    this._value = value;
  }

  bool isSetValue() => this.value != null;

  unsetValue() {
    this.value = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ATTR:
        return this.attr;
      case VALUE:
        return this.value;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ATTR:
        if (value == null) {
          unsetAttr();
        } else {
          this.attr = value;
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          this.value = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ATTR:
        return isSetAttr();
      case VALUE:
        return isSetValue();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ATTR:
          if (field.type == TType.I32) {
            this.attr = iprot.readI32();
            this.__isset_attr = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ATTR_FIELD_DESC);
    oprot.writeI32(this.attr);
    oprot.writeFieldEnd();
    if (this.value != null) {
      oprot.writeFieldBegin(_VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateProfileAttribute_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("attr:");
    String attr_name = ProfileAttribute.VALUES_TO_NAMES[this.attr];
    if (attr_name != null) {
      ret.write(attr_name);
      ret.write(" (");
    }
    ret.write(this.attr);
    if (attr_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("value:");
    if (this.value == null) {
      ret.write("null");
    } else {
      ret.write(this.value);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAttr() && !ProfileAttribute.VALID_VALUES.contains(attr)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'attr' has been assigned the invalid value $attr");
    }
  }

}

class updateProfileAttribute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateProfileAttribute_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateProfileAttribute_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateProfileAttribute_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateRegion_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateRegion_args");
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 2);

  String _region;
  static const int REGION = 2;


  updateRegion_args() {
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGION:
        return this.region;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGION:
        return isSetRegion();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateRegion_args(");

    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateRegion_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateRegion_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateRegion_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateRegion_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettings_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettings_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _SETTINGS_FIELD_DESC = new TField("settings", TType.STRUCT, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Settings _settings;
  static const int SETTINGS = 2;

  bool __isset_reqSeq = false;

  updateSettings_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // settings
  Settings get settings => this._settings;

  set settings(Settings settings) {
    this._settings = settings;
  }

  bool isSetSettings() => this.settings != null;

  unsetSettings() {
    this.settings = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case SETTINGS:
        return this.settings;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case SETTINGS:
        if (value == null) {
          unsetSettings();
        } else {
          this.settings = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case SETTINGS:
        return isSetSettings();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SETTINGS:
          if (field.type == TType.STRUCT) {
            this.settings = new Settings();
            this.settings.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.settings != null) {
      oprot.writeFieldBegin(_SETTINGS_FIELD_DESC);
      this.settings.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettings_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("settings:");
    if (this.settings == null) {
      ret.write("null");
    } else {
      ret.write(this.settings);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettings_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettings_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateSettings_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettings_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettings2_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettings2_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _SETTINGS_FIELD_DESC = new TField("settings", TType.STRUCT, 2);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  Settings _settings;
  static const int SETTINGS = 2;

  bool __isset_reqSeq = false;

  updateSettings2_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // settings
  Settings get settings => this._settings;

  set settings(Settings settings) {
    this._settings = settings;
  }

  bool isSetSettings() => this.settings != null;

  unsetSettings() {
    this.settings = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case SETTINGS:
        return this.settings;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case SETTINGS:
        if (value == null) {
          unsetSettings();
        } else {
          this.settings = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case SETTINGS:
        return isSetSettings();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SETTINGS:
          if (field.type == TType.STRUCT) {
            this.settings = new Settings();
            this.settings.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.settings != null) {
      oprot.writeFieldBegin(_SETTINGS_FIELD_DESC);
      this.settings.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettings2_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("settings:");
    if (this.settings == null) {
      ret.write("null");
    } else {
      ret.write(this.settings);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettings2_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettings2_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I32, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  updateSettings2_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettings2_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettingsAttribute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettingsAttribute_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ATTR_FIELD_DESC = new TField("attr", TType.I32, 2);
  static final TField _VALUE_FIELD_DESC = new TField("value", TType.STRING, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  int _attr;
  static const int ATTR = 2;
  String _value;
  static const int VALUE = 3;

  bool __isset_reqSeq = false;
  bool __isset_attr = false;

  updateSettingsAttribute_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // attr
  int get attr => this._attr;

  set attr(int attr) {
    this._attr = attr;
    this.__isset_attr = true;
  }

  bool isSetAttr() => this.__isset_attr;

  unsetAttr() {
    this.__isset_attr = false;
  }

  // value
  String get value => this._value;

  set value(String value) {
    this._value = value;
  }

  bool isSetValue() => this.value != null;

  unsetValue() {
    this.value = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ATTR:
        return this.attr;
      case VALUE:
        return this.value;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ATTR:
        if (value == null) {
          unsetAttr();
        } else {
          this.attr = value;
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          this.value = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ATTR:
        return isSetAttr();
      case VALUE:
        return isSetValue();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ATTR:
          if (field.type == TType.I32) {
            this.attr = iprot.readI32();
            this.__isset_attr = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ATTR_FIELD_DESC);
    oprot.writeI32(this.attr);
    oprot.writeFieldEnd();
    if (this.value != null) {
      oprot.writeFieldBegin(_VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettingsAttribute_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("attr:");
    String attr_name = SettingsAttribute.VALUES_TO_NAMES[this.attr];
    if (attr_name != null) {
      ret.write(attr_name);
      ret.write(" (");
    }
    ret.write(this.attr);
    if (attr_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("value:");
    if (this.value == null) {
      ret.write("null");
    } else {
      ret.write(this.value);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAttr() && !SettingsAttribute.VALID_VALUES.contains(attr)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'attr' has been assigned the invalid value $attr");
    }
  }

}

class updateSettingsAttribute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettingsAttribute_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateSettingsAttribute_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettingsAttribute_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettingsAttributes_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettingsAttributes_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _ATTR_BITSET_FIELD_DESC = new TField("attrBitset", TType.I32, 2);
  static final TField _SETTINGS_FIELD_DESC = new TField("settings", TType.STRUCT, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  int _attrBitset = 0;
  static const int ATTRBITSET = 2;
  Settings _settings;
  static const int SETTINGS = 3;

  bool __isset_reqSeq = false;
  bool __isset_attrBitset = false;

  updateSettingsAttributes_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // attrBitset
  int get attrBitset => this._attrBitset;

  set attrBitset(int attrBitset) {
    this._attrBitset = attrBitset;
    this.__isset_attrBitset = true;
  }

  bool isSetAttrBitset() => this.__isset_attrBitset;

  unsetAttrBitset() {
    this.__isset_attrBitset = false;
  }

  // settings
  Settings get settings => this._settings;

  set settings(Settings settings) {
    this._settings = settings;
  }

  bool isSetSettings() => this.settings != null;

  unsetSettings() {
    this.settings = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case ATTRBITSET:
        return this.attrBitset;
      case SETTINGS:
        return this.settings;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case ATTRBITSET:
        if (value == null) {
          unsetAttrBitset();
        } else {
          this.attrBitset = value;
        }
        break;

      case SETTINGS:
        if (value == null) {
          unsetSettings();
        } else {
          this.settings = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case ATTRBITSET:
        return isSetAttrBitset();
      case SETTINGS:
        return isSetSettings();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ATTRBITSET:
          if (field.type == TType.I32) {
            this.attrBitset = iprot.readI32();
            this.__isset_attrBitset = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SETTINGS:
          if (field.type == TType.STRUCT) {
            this.settings = new Settings();
            this.settings.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ATTR_BITSET_FIELD_DESC);
    oprot.writeI32(this.attrBitset);
    oprot.writeFieldEnd();
    if (this.settings != null) {
      oprot.writeFieldBegin(_SETTINGS_FIELD_DESC);
      this.settings.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettingsAttributes_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("attrBitset:");
    ret.write(this.attrBitset);

    ret.write(", ");
    ret.write("settings:");
    if (this.settings == null) {
      ret.write("null");
    } else {
      ret.write(this.settings);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSettingsAttributes_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSettingsAttributes_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I32, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  updateSettingsAttributes_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSettingsAttributes_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyIdentityCredential_args");
  static final TField _IDENTITY_PROVIDER_FIELD_DESC = new TField("identityProvider", TType.I32, 8);
  static final TField _IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 3);
  static final TField _PASSWORD_FIELD_DESC = new TField("password", TType.STRING, 4);

  int _identityProvider;
  static const int IDENTITYPROVIDER = 8;
  String _identifier;
  static const int IDENTIFIER = 3;
  String _password;
  static const int PASSWORD = 4;

  bool __isset_identityProvider = false;

  verifyIdentityCredential_args() {
  }

  // identityProvider
  int get identityProvider => this._identityProvider;

  set identityProvider(int identityProvider) {
    this._identityProvider = identityProvider;
    this.__isset_identityProvider = true;
  }

  bool isSetIdentityProvider() => this.__isset_identityProvider;

  unsetIdentityProvider() {
    this.__isset_identityProvider = false;
  }

  // identifier
  String get identifier => this._identifier;

  set identifier(String identifier) {
    this._identifier = identifier;
  }

  bool isSetIdentifier() => this.identifier != null;

  unsetIdentifier() {
    this.identifier = null;
  }

  // password
  String get password => this._password;

  set password(String password) {
    this._password = password;
  }

  bool isSetPassword() => this.password != null;

  unsetPassword() {
    this.password = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        return this.identityProvider;
      case IDENTIFIER:
        return this.identifier;
      case PASSWORD:
        return this.password;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        if (value == null) {
          unsetIdentityProvider();
        } else {
          this.identityProvider = value;
        }
        break;

      case IDENTIFIER:
        if (value == null) {
          unsetIdentifier();
        } else {
          this.identifier = value;
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          this.password = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDENTITYPROVIDER:
        return isSetIdentityProvider();
      case IDENTIFIER:
        return isSetIdentifier();
      case PASSWORD:
        return isSetPassword();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDENTITYPROVIDER:
          if (field.type == TType.I32) {
            this.identityProvider = iprot.readI32();
            this.__isset_identityProvider = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTIFIER:
          if (field.type == TType.STRING) {
            this.identifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PASSWORD:
          if (field.type == TType.STRING) {
            this.password = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identifier != null) {
      oprot.writeFieldBegin(_IDENTIFIER_FIELD_DESC);
      oprot.writeString(this.identifier);
      oprot.writeFieldEnd();
    }
    if (this.password != null) {
      oprot.writeFieldBegin(_PASSWORD_FIELD_DESC);
      oprot.writeString(this.password);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_IDENTITY_PROVIDER_FIELD_DESC);
    oprot.writeI32(this.identityProvider);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyIdentityCredential_args(");

    ret.write("identityProvider:");
    String identityProvider_name = IdentityProvider.VALUES_TO_NAMES[this.identityProvider];
    if (identityProvider_name != null) {
      ret.write(identityProvider_name);
      ret.write(" (");
    }
    ret.write(this.identityProvider);
    if (identityProvider_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("identifier:");
    if (this.identifier == null) {
      ret.write("null");
    } else {
      ret.write(this.identifier);
    }

    ret.write(", ");
    ret.write("password:");
    if (this.password == null) {
      ret.write("null");
    } else {
      ret.write(this.password);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetIdentityProvider() && !IdentityProvider.VALID_VALUES.contains(identityProvider)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'identityProvider' has been assigned the invalid value $identityProvider");
    }
  }

}

class verifyIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyIdentityCredential_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  verifyIdentityCredential_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyIdentityCredential_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyIdentityCredentialWithResult_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyIdentityCredentialWithResult_args");
  static final TField _IDENTITY_CREDENTIAL_FIELD_DESC = new TField("identityCredential", TType.STRUCT, 2);

  IdentityCredential _identityCredential;
  static const int IDENTITYCREDENTIAL = 2;


  verifyIdentityCredentialWithResult_args() {
  }

  // identityCredential
  IdentityCredential get identityCredential => this._identityCredential;

  set identityCredential(IdentityCredential identityCredential) {
    this._identityCredential = identityCredential;
  }

  bool isSetIdentityCredential() => this.identityCredential != null;

  unsetIdentityCredential() {
    this.identityCredential = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDENTITYCREDENTIAL:
        return this.identityCredential;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDENTITYCREDENTIAL:
        if (value == null) {
          unsetIdentityCredential();
        } else {
          this.identityCredential = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDENTITYCREDENTIAL:
        return isSetIdentityCredential();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDENTITYCREDENTIAL:
          if (field.type == TType.STRUCT) {
            this.identityCredential = new IdentityCredential();
            this.identityCredential.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.identityCredential != null) {
      oprot.writeFieldBegin(_IDENTITY_CREDENTIAL_FIELD_DESC);
      this.identityCredential.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyIdentityCredentialWithResult_args(");

    ret.write("identityCredential:");
    if (this.identityCredential == null) {
      ret.write("null");
    } else {
      ret.write(this.identityCredential);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyIdentityCredentialWithResult_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyIdentityCredentialWithResult_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  UserAuthStatus _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  verifyIdentityCredentialWithResult_result() {
  }

  // success
  UserAuthStatus get success => this._success;

  set success(UserAuthStatus success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new UserAuthStatus();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyIdentityCredentialWithResult_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyPhone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyPhone_args");
  static final TField _SESSION_ID_FIELD_DESC = new TField("sessionId", TType.STRING, 2);
  static final TField _PIN_CODE_FIELD_DESC = new TField("pinCode", TType.STRING, 3);
  static final TField _UDID_HASH_FIELD_DESC = new TField("udidHash", TType.STRING, 4);

  String _sessionId;
  static const int SESSIONID = 2;
  String _pinCode;
  static const int PINCODE = 3;
  String _udidHash;
  static const int UDIDHASH = 4;


  verifyPhone_args() {
  }

  // sessionId
  String get sessionId => this._sessionId;

  set sessionId(String sessionId) {
    this._sessionId = sessionId;
  }

  bool isSetSessionId() => this.sessionId != null;

  unsetSessionId() {
    this.sessionId = null;
  }

  // pinCode
  String get pinCode => this._pinCode;

  set pinCode(String pinCode) {
    this._pinCode = pinCode;
  }

  bool isSetPinCode() => this.pinCode != null;

  unsetPinCode() {
    this.pinCode = null;
  }

  // udidHash
  String get udidHash => this._udidHash;

  set udidHash(String udidHash) {
    this._udidHash = udidHash;
  }

  bool isSetUdidHash() => this.udidHash != null;

  unsetUdidHash() {
    this.udidHash = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case PINCODE:
        return this.pinCode;
      case UDIDHASH:
        return this.udidHash;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value;
        }
        break;

      case PINCODE:
        if (value == null) {
          unsetPinCode();
        } else {
          this.pinCode = value;
        }
        break;

      case UDIDHASH:
        if (value == null) {
          unsetUdidHash();
        } else {
          this.udidHash = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case PINCODE:
        return isSetPinCode();
      case UDIDHASH:
        return isSetUdidHash();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PINCODE:
          if (field.type == TType.STRING) {
            this.pinCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UDIDHASH:
          if (field.type == TType.STRING) {
            this.udidHash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.sessionId != null) {
      oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionId);
      oprot.writeFieldEnd();
    }
    if (this.pinCode != null) {
      oprot.writeFieldBegin(_PIN_CODE_FIELD_DESC);
      oprot.writeString(this.pinCode);
      oprot.writeFieldEnd();
    }
    if (this.udidHash != null) {
      oprot.writeFieldBegin(_UDID_HASH_FIELD_DESC);
      oprot.writeString(this.udidHash);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyPhone_args(");

    ret.write("sessionId:");
    if (this.sessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.sessionId);
    }

    ret.write(", ");
    ret.write("pinCode:");
    if (this.pinCode == null) {
      ret.write("null");
    } else {
      ret.write(this.pinCode);
    }

    ret.write(", ");
    ret.write("udidHash:");
    if (this.udidHash == null) {
      ret.write("null");
    } else {
      ret.write(this.udidHash);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyPhone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyPhone_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I32, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  verifyPhone_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyPhone_result(");

    ret.write("success:");
    String success_name = VerificationResult.VALUES_TO_NAMES[this.success];
    if (success_name != null) {
      ret.write(success_name);
      ret.write(" (");
    }
    ret.write(this.success);
    if (success_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSuccess() && !VerificationResult.VALID_VALUES.contains(success)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'success' has been assigned the invalid value $success");
    }
  }

}

class verifyQrcode_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyQrcode_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 2);
  static final TField _PIN_CODE_FIELD_DESC = new TField("pinCode", TType.STRING, 3);

  String _verifier;
  static const int VERIFIER = 2;
  String _pinCode;
  static const int PINCODE = 3;


  verifyQrcode_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  // pinCode
  String get pinCode => this._pinCode;

  set pinCode(String pinCode) {
    this._pinCode = pinCode;
  }

  bool isSetPinCode() => this.pinCode != null;

  unsetPinCode() {
    this.pinCode = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      case PINCODE:
        return this.pinCode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      case PINCODE:
        if (value == null) {
          unsetPinCode();
        } else {
          this.pinCode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      case PINCODE:
        return isSetPinCode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PINCODE:
          if (field.type == TType.STRING) {
            this.pinCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    if (this.pinCode != null) {
      oprot.writeFieldBegin(_PIN_CODE_FIELD_DESC);
      oprot.writeString(this.pinCode);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyQrcode_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(", ");
    ret.write("pinCode:");
    if (this.pinCode == null) {
      ret.write("null");
    } else {
      ret.write(this.pinCode);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class verifyQrcode_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyQrcode_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  verifyQrcode_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyQrcode_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

