/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library line.src.shop_service;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:thrift/thrift.dart';
import 'package:line/line.dart';


abstract class ShopService {

  Future buyCoinProduct(PaymentReservation paymentReservation);

  Future buyFreeProduct(String receiverMid, String productId, int messageTemplate, String language, String country, int packageId);

  Future buyMustbuyProduct(String receiverMid, String productId, int messageTemplate, String language, String country, int packageId, String serialNumber);

  Future checkCanReceivePresent(String recipientMid, int packageId, String language, String country);

  Future<ProductList> getActivePurchases(int start, int size, String language, String country);

  Future<ProductSimpleList> getActivePurchaseVersions(int start, int size, String language, String country);

  Future<List<CoinProductItem>> getCoinProducts(int appStoreCode, String country, String language);

  Future<List<CoinProductItem>> getCoinProductsByPgCode(int appStoreCode, int pgCode, String country, String language);

  Future<CoinHistoryResult> getCoinPurchaseHistory(CoinHistoryCondition request);

  Future<CoinHistoryResult> getCoinUseAndRefundHistory(CoinHistoryCondition request);

  Future<ProductList> getDownloads(int start, int size, String language, String country);

  Future<ProductList> getEventPackages(int start, int size, String language, String country);

  Future<ProductList> getNewlyReleasedPackages(int start, int size, String language, String country);

  Future<ProductList> getPopularPackages(int start, int size, String language, String country);

  Future<ProductList> getPresentsReceived(int start, int size, String language, String country);

  Future<ProductList> getPresentsSent(int start, int size, String language, String country);

  Future<Product> getProduct(int packageID, String language, String country);

  Future<ProductList> getProductList(List<String> productIdList, String language, String country);

  Future<ProductList> getProductListWithCarrier(List<String> productIdList, String language, String country, String carrierCode);

  Future<Product> getProductWithCarrier(int packageID, String language, String country, String carrierCode);

  Future<ProductList> getPurchaseHistory(int start, int size, String language, String country);

  Future<Coin> getTotalBalance(int appStoreCode);

  Future<int> notifyDownloaded(int packageId, String language);

  Future<PaymentReservationResult> reserveCoinPurchase(CoinPurchaseReservation request);

  Future<PaymentReservationResult> reservePayment(PaymentReservation paymentReservation);
}

class ShopServiceClient implements ShopService {

  ShopServiceClient(TProtocol iprot, [TProtocol oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  TProtocol _iprot;

  TProtocol get iprot => _iprot;

  TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future buyCoinProduct(PaymentReservation paymentReservation) async {
    oprot.writeMessageBegin(new TMessage("buyCoinProduct", TMessageType.CALL, nextSeqid()));
    buyCoinProduct_args args = new buyCoinProduct_args();
    args.paymentReservation = paymentReservation;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    buyCoinProduct_result result = new buyCoinProduct_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future buyFreeProduct(String receiverMid, String productId, int messageTemplate, String language, String country, int packageId) async {
    oprot.writeMessageBegin(new TMessage("buyFreeProduct", TMessageType.CALL, nextSeqid()));
    buyFreeProduct_args args = new buyFreeProduct_args();
    args.receiverMid = receiverMid;
    args.productId = productId;
    args.messageTemplate = messageTemplate;
    args.language = language;
    args.country = country;
    args.packageId = packageId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    buyFreeProduct_result result = new buyFreeProduct_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future buyMustbuyProduct(String receiverMid, String productId, int messageTemplate, String language, String country, int packageId, String serialNumber) async {
    oprot.writeMessageBegin(new TMessage("buyMustbuyProduct", TMessageType.CALL, nextSeqid()));
    buyMustbuyProduct_args args = new buyMustbuyProduct_args();
    args.receiverMid = receiverMid;
    args.productId = productId;
    args.messageTemplate = messageTemplate;
    args.language = language;
    args.country = country;
    args.packageId = packageId;
    args.serialNumber = serialNumber;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    buyMustbuyProduct_result result = new buyMustbuyProduct_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future checkCanReceivePresent(String recipientMid, int packageId, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("checkCanReceivePresent", TMessageType.CALL, nextSeqid()));
    checkCanReceivePresent_args args = new checkCanReceivePresent_args();
    args.recipientMid = recipientMid;
    args.packageId = packageId;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    checkCanReceivePresent_result result = new checkCanReceivePresent_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<ProductList> getActivePurchases(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getActivePurchases", TMessageType.CALL, nextSeqid()));
    getActivePurchases_args args = new getActivePurchases_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getActivePurchases_result result = new getActivePurchases_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getActivePurchases failed: unknown result");
  }

  Future<ProductSimpleList> getActivePurchaseVersions(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getActivePurchaseVersions", TMessageType.CALL, nextSeqid()));
    getActivePurchaseVersions_args args = new getActivePurchaseVersions_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getActivePurchaseVersions_result result = new getActivePurchaseVersions_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getActivePurchaseVersions failed: unknown result");
  }

  Future<List<CoinProductItem>> getCoinProducts(int appStoreCode, String country, String language) async {
    oprot.writeMessageBegin(new TMessage("getCoinProducts", TMessageType.CALL, nextSeqid()));
    getCoinProducts_args args = new getCoinProducts_args();
    args.appStoreCode = appStoreCode;
    args.country = country;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCoinProducts_result result = new getCoinProducts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCoinProducts failed: unknown result");
  }

  Future<List<CoinProductItem>> getCoinProductsByPgCode(int appStoreCode, int pgCode, String country, String language) async {
    oprot.writeMessageBegin(new TMessage("getCoinProductsByPgCode", TMessageType.CALL, nextSeqid()));
    getCoinProductsByPgCode_args args = new getCoinProductsByPgCode_args();
    args.appStoreCode = appStoreCode;
    args.pgCode = pgCode;
    args.country = country;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCoinProductsByPgCode_result result = new getCoinProductsByPgCode_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCoinProductsByPgCode failed: unknown result");
  }

  Future<CoinHistoryResult> getCoinPurchaseHistory(CoinHistoryCondition request) async {
    oprot.writeMessageBegin(new TMessage("getCoinPurchaseHistory", TMessageType.CALL, nextSeqid()));
    getCoinPurchaseHistory_args args = new getCoinPurchaseHistory_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCoinPurchaseHistory_result result = new getCoinPurchaseHistory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCoinPurchaseHistory failed: unknown result");
  }

  Future<CoinHistoryResult> getCoinUseAndRefundHistory(CoinHistoryCondition request) async {
    oprot.writeMessageBegin(new TMessage("getCoinUseAndRefundHistory", TMessageType.CALL, nextSeqid()));
    getCoinUseAndRefundHistory_args args = new getCoinUseAndRefundHistory_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCoinUseAndRefundHistory_result result = new getCoinUseAndRefundHistory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCoinUseAndRefundHistory failed: unknown result");
  }

  Future<ProductList> getDownloads(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getDownloads", TMessageType.CALL, nextSeqid()));
    getDownloads_args args = new getDownloads_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getDownloads_result result = new getDownloads_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getDownloads failed: unknown result");
  }

  Future<ProductList> getEventPackages(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getEventPackages", TMessageType.CALL, nextSeqid()));
    getEventPackages_args args = new getEventPackages_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getEventPackages_result result = new getEventPackages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getEventPackages failed: unknown result");
  }

  Future<ProductList> getNewlyReleasedPackages(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getNewlyReleasedPackages", TMessageType.CALL, nextSeqid()));
    getNewlyReleasedPackages_args args = new getNewlyReleasedPackages_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getNewlyReleasedPackages_result result = new getNewlyReleasedPackages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getNewlyReleasedPackages failed: unknown result");
  }

  Future<ProductList> getPopularPackages(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getPopularPackages", TMessageType.CALL, nextSeqid()));
    getPopularPackages_args args = new getPopularPackages_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPopularPackages_result result = new getPopularPackages_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPopularPackages failed: unknown result");
  }

  Future<ProductList> getPresentsReceived(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getPresentsReceived", TMessageType.CALL, nextSeqid()));
    getPresentsReceived_args args = new getPresentsReceived_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPresentsReceived_result result = new getPresentsReceived_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPresentsReceived failed: unknown result");
  }

  Future<ProductList> getPresentsSent(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getPresentsSent", TMessageType.CALL, nextSeqid()));
    getPresentsSent_args args = new getPresentsSent_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPresentsSent_result result = new getPresentsSent_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPresentsSent failed: unknown result");
  }

  Future<Product> getProduct(int packageID, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getProduct", TMessageType.CALL, nextSeqid()));
    getProduct_args args = new getProduct_args();
    args.packageID = packageID;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProduct_result result = new getProduct_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProduct failed: unknown result");
  }

  Future<ProductList> getProductList(List<String> productIdList, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getProductList", TMessageType.CALL, nextSeqid()));
    getProductList_args args = new getProductList_args();
    args.productIdList = productIdList;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProductList_result result = new getProductList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProductList failed: unknown result");
  }

  Future<ProductList> getProductListWithCarrier(List<String> productIdList, String language, String country, String carrierCode) async {
    oprot.writeMessageBegin(new TMessage("getProductListWithCarrier", TMessageType.CALL, nextSeqid()));
    getProductListWithCarrier_args args = new getProductListWithCarrier_args();
    args.productIdList = productIdList;
    args.language = language;
    args.country = country;
    args.carrierCode = carrierCode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProductListWithCarrier_result result = new getProductListWithCarrier_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProductListWithCarrier failed: unknown result");
  }

  Future<Product> getProductWithCarrier(int packageID, String language, String country, String carrierCode) async {
    oprot.writeMessageBegin(new TMessage("getProductWithCarrier", TMessageType.CALL, nextSeqid()));
    getProductWithCarrier_args args = new getProductWithCarrier_args();
    args.packageID = packageID;
    args.language = language;
    args.country = country;
    args.carrierCode = carrierCode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProductWithCarrier_result result = new getProductWithCarrier_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProductWithCarrier failed: unknown result");
  }

  Future<ProductList> getPurchaseHistory(int start, int size, String language, String country) async {
    oprot.writeMessageBegin(new TMessage("getPurchaseHistory", TMessageType.CALL, nextSeqid()));
    getPurchaseHistory_args args = new getPurchaseHistory_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.country = country;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPurchaseHistory_result result = new getPurchaseHistory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPurchaseHistory failed: unknown result");
  }

  Future<Coin> getTotalBalance(int appStoreCode) async {
    oprot.writeMessageBegin(new TMessage("getTotalBalance", TMessageType.CALL, nextSeqid()));
    getTotalBalance_args args = new getTotalBalance_args();
    args.appStoreCode = appStoreCode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getTotalBalance_result result = new getTotalBalance_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getTotalBalance failed: unknown result");
  }

  Future<int> notifyDownloaded(int packageId, String language) async {
    oprot.writeMessageBegin(new TMessage("notifyDownloaded", TMessageType.CALL, nextSeqid()));
    notifyDownloaded_args args = new notifyDownloaded_args();
    args.packageId = packageId;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyDownloaded_result result = new notifyDownloaded_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "notifyDownloaded failed: unknown result");
  }

  Future<PaymentReservationResult> reserveCoinPurchase(CoinPurchaseReservation request) async {
    oprot.writeMessageBegin(new TMessage("reserveCoinPurchase", TMessageType.CALL, nextSeqid()));
    reserveCoinPurchase_args args = new reserveCoinPurchase_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reserveCoinPurchase_result result = new reserveCoinPurchase_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reserveCoinPurchase failed: unknown result");
  }

  Future<PaymentReservationResult> reservePayment(PaymentReservation paymentReservation) async {
    oprot.writeMessageBegin(new TMessage("reservePayment", TMessageType.CALL, nextSeqid()));
    reservePayment_args args = new reservePayment_args();
    args.paymentReservation = paymentReservation;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reservePayment_result result = new reservePayment_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reservePayment failed: unknown result");
  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class ShopServiceProcessor implements TProcessor {
  ShopServiceProcessor(ShopService iface) {
    iface_ = iface;
    PROCESS_MAP["buyCoinProduct"] = buyCoinProduct;
    PROCESS_MAP["buyFreeProduct"] = buyFreeProduct;
    PROCESS_MAP["buyMustbuyProduct"] = buyMustbuyProduct;
    PROCESS_MAP["checkCanReceivePresent"] = checkCanReceivePresent;
    PROCESS_MAP["getActivePurchases"] = getActivePurchases;
    PROCESS_MAP["getActivePurchaseVersions"] = getActivePurchaseVersions;
    PROCESS_MAP["getCoinProducts"] = getCoinProducts;
    PROCESS_MAP["getCoinProductsByPgCode"] = getCoinProductsByPgCode;
    PROCESS_MAP["getCoinPurchaseHistory"] = getCoinPurchaseHistory;
    PROCESS_MAP["getCoinUseAndRefundHistory"] = getCoinUseAndRefundHistory;
    PROCESS_MAP["getDownloads"] = getDownloads;
    PROCESS_MAP["getEventPackages"] = getEventPackages;
    PROCESS_MAP["getNewlyReleasedPackages"] = getNewlyReleasedPackages;
    PROCESS_MAP["getPopularPackages"] = getPopularPackages;
    PROCESS_MAP["getPresentsReceived"] = getPresentsReceived;
    PROCESS_MAP["getPresentsSent"] = getPresentsSent;
    PROCESS_MAP["getProduct"] = getProduct;
    PROCESS_MAP["getProductList"] = getProductList;
    PROCESS_MAP["getProductListWithCarrier"] = getProductListWithCarrier;
    PROCESS_MAP["getProductWithCarrier"] = getProductWithCarrier;
    PROCESS_MAP["getPurchaseHistory"] = getPurchaseHistory;
    PROCESS_MAP["getTotalBalance"] = getTotalBalance;
    PROCESS_MAP["notifyDownloaded"] = notifyDownloaded;
    PROCESS_MAP["reserveCoinPurchase"] = reserveCoinPurchase;
    PROCESS_MAP["reservePayment"] = reservePayment;
  }

  ShopService iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  buyCoinProduct(int seqid, TProtocol iprot, TProtocol oprot) {
    buyCoinProduct_args args = new buyCoinProduct_args();
    args.read(iprot);
    iprot.readMessageEnd();
    buyCoinProduct_result result = new buyCoinProduct_result();
    try {
      iface_.buyCoinProduct(args.paymentReservation);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing buyCoinProduct");
      oprot.writeMessageBegin(new TMessage("buyCoinProduct", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("buyCoinProduct", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  buyFreeProduct(int seqid, TProtocol iprot, TProtocol oprot) {
    buyFreeProduct_args args = new buyFreeProduct_args();
    args.read(iprot);
    iprot.readMessageEnd();
    buyFreeProduct_result result = new buyFreeProduct_result();
    try {
      iface_.buyFreeProduct(args.receiverMid, args.productId, args.messageTemplate, args.language, args.country, args.packageId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing buyFreeProduct");
      oprot.writeMessageBegin(new TMessage("buyFreeProduct", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("buyFreeProduct", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  buyMustbuyProduct(int seqid, TProtocol iprot, TProtocol oprot) {
    buyMustbuyProduct_args args = new buyMustbuyProduct_args();
    args.read(iprot);
    iprot.readMessageEnd();
    buyMustbuyProduct_result result = new buyMustbuyProduct_result();
    try {
      iface_.buyMustbuyProduct(args.receiverMid, args.productId, args.messageTemplate, args.language, args.country, args.packageId, args.serialNumber);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing buyMustbuyProduct");
      oprot.writeMessageBegin(new TMessage("buyMustbuyProduct", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("buyMustbuyProduct", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  checkCanReceivePresent(int seqid, TProtocol iprot, TProtocol oprot) {
    checkCanReceivePresent_args args = new checkCanReceivePresent_args();
    args.read(iprot);
    iprot.readMessageEnd();
    checkCanReceivePresent_result result = new checkCanReceivePresent_result();
    try {
      iface_.checkCanReceivePresent(args.recipientMid, args.packageId, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing checkCanReceivePresent");
      oprot.writeMessageBegin(new TMessage("checkCanReceivePresent", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("checkCanReceivePresent", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getActivePurchases(int seqid, TProtocol iprot, TProtocol oprot) async {
    getActivePurchases_args args = new getActivePurchases_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getActivePurchases_result result = new getActivePurchases_result();
    try {
      result.success = await iface_.getActivePurchases(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getActivePurchases");
      oprot.writeMessageBegin(new TMessage("getActivePurchases", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getActivePurchases", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getActivePurchaseVersions(int seqid, TProtocol iprot, TProtocol oprot) async {
    getActivePurchaseVersions_args args = new getActivePurchaseVersions_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getActivePurchaseVersions_result result = new getActivePurchaseVersions_result();
    try {
      result.success = await iface_.getActivePurchaseVersions(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getActivePurchaseVersions");
      oprot.writeMessageBegin(new TMessage("getActivePurchaseVersions", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getActivePurchaseVersions", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCoinProducts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCoinProducts_args args = new getCoinProducts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCoinProducts_result result = new getCoinProducts_result();
    try {
      result.success = await iface_.getCoinProducts(args.appStoreCode, args.country, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCoinProducts");
      oprot.writeMessageBegin(new TMessage("getCoinProducts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCoinProducts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCoinProductsByPgCode(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCoinProductsByPgCode_args args = new getCoinProductsByPgCode_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCoinProductsByPgCode_result result = new getCoinProductsByPgCode_result();
    try {
      result.success = await iface_.getCoinProductsByPgCode(args.appStoreCode, args.pgCode, args.country, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCoinProductsByPgCode");
      oprot.writeMessageBegin(new TMessage("getCoinProductsByPgCode", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCoinProductsByPgCode", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCoinPurchaseHistory(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCoinPurchaseHistory_args args = new getCoinPurchaseHistory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCoinPurchaseHistory_result result = new getCoinPurchaseHistory_result();
    try {
      result.success = await iface_.getCoinPurchaseHistory(args.request);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCoinPurchaseHistory");
      oprot.writeMessageBegin(new TMessage("getCoinPurchaseHistory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCoinPurchaseHistory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCoinUseAndRefundHistory(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCoinUseAndRefundHistory_args args = new getCoinUseAndRefundHistory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCoinUseAndRefundHistory_result result = new getCoinUseAndRefundHistory_result();
    try {
      result.success = await iface_.getCoinUseAndRefundHistory(args.request);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCoinUseAndRefundHistory");
      oprot.writeMessageBegin(new TMessage("getCoinUseAndRefundHistory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCoinUseAndRefundHistory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getDownloads(int seqid, TProtocol iprot, TProtocol oprot) async {
    getDownloads_args args = new getDownloads_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getDownloads_result result = new getDownloads_result();
    try {
      result.success = await iface_.getDownloads(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getDownloads");
      oprot.writeMessageBegin(new TMessage("getDownloads", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getDownloads", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getEventPackages(int seqid, TProtocol iprot, TProtocol oprot) async {
    getEventPackages_args args = new getEventPackages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getEventPackages_result result = new getEventPackages_result();
    try {
      result.success = await iface_.getEventPackages(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getEventPackages");
      oprot.writeMessageBegin(new TMessage("getEventPackages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getEventPackages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getNewlyReleasedPackages(int seqid, TProtocol iprot, TProtocol oprot) async {
    getNewlyReleasedPackages_args args = new getNewlyReleasedPackages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getNewlyReleasedPackages_result result = new getNewlyReleasedPackages_result();
    try {
      result.success = await iface_.getNewlyReleasedPackages(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getNewlyReleasedPackages");
      oprot.writeMessageBegin(new TMessage("getNewlyReleasedPackages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getNewlyReleasedPackages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPopularPackages(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPopularPackages_args args = new getPopularPackages_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPopularPackages_result result = new getPopularPackages_result();
    try {
      result.success = await iface_.getPopularPackages(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPopularPackages");
      oprot.writeMessageBegin(new TMessage("getPopularPackages", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPopularPackages", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPresentsReceived(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPresentsReceived_args args = new getPresentsReceived_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPresentsReceived_result result = new getPresentsReceived_result();
    try {
      result.success = await iface_.getPresentsReceived(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPresentsReceived");
      oprot.writeMessageBegin(new TMessage("getPresentsReceived", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPresentsReceived", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPresentsSent(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPresentsSent_args args = new getPresentsSent_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPresentsSent_result result = new getPresentsSent_result();
    try {
      result.success = await iface_.getPresentsSent(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPresentsSent");
      oprot.writeMessageBegin(new TMessage("getPresentsSent", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPresentsSent", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProduct(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProduct_args args = new getProduct_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProduct_result result = new getProduct_result();
    try {
      result.success = await iface_.getProduct(args.packageID, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProduct");
      oprot.writeMessageBegin(new TMessage("getProduct", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProduct", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProductList(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProductList_args args = new getProductList_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProductList_result result = new getProductList_result();
    try {
      result.success = await iface_.getProductList(args.productIdList, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProductList");
      oprot.writeMessageBegin(new TMessage("getProductList", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProductList", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProductListWithCarrier(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProductListWithCarrier_args args = new getProductListWithCarrier_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProductListWithCarrier_result result = new getProductListWithCarrier_result();
    try {
      result.success = await iface_.getProductListWithCarrier(args.productIdList, args.language, args.country, args.carrierCode);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProductListWithCarrier");
      oprot.writeMessageBegin(new TMessage("getProductListWithCarrier", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProductListWithCarrier", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProductWithCarrier(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProductWithCarrier_args args = new getProductWithCarrier_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProductWithCarrier_result result = new getProductWithCarrier_result();
    try {
      result.success = await iface_.getProductWithCarrier(args.packageID, args.language, args.country, args.carrierCode);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProductWithCarrier");
      oprot.writeMessageBegin(new TMessage("getProductWithCarrier", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProductWithCarrier", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPurchaseHistory(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPurchaseHistory_args args = new getPurchaseHistory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPurchaseHistory_result result = new getPurchaseHistory_result();
    try {
      result.success = await iface_.getPurchaseHistory(args.start, args.size, args.language, args.country);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPurchaseHistory");
      oprot.writeMessageBegin(new TMessage("getPurchaseHistory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPurchaseHistory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getTotalBalance(int seqid, TProtocol iprot, TProtocol oprot) async {
    getTotalBalance_args args = new getTotalBalance_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getTotalBalance_result result = new getTotalBalance_result();
    try {
      result.success = await iface_.getTotalBalance(args.appStoreCode);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getTotalBalance");
      oprot.writeMessageBegin(new TMessage("getTotalBalance", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getTotalBalance", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyDownloaded(int seqid, TProtocol iprot, TProtocol oprot) async {
    notifyDownloaded_args args = new notifyDownloaded_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyDownloaded_result result = new notifyDownloaded_result();
    try {
      result.success = await iface_.notifyDownloaded(args.packageId, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyDownloaded");
      oprot.writeMessageBegin(new TMessage("notifyDownloaded", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyDownloaded", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reserveCoinPurchase(int seqid, TProtocol iprot, TProtocol oprot) async {
    reserveCoinPurchase_args args = new reserveCoinPurchase_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reserveCoinPurchase_result result = new reserveCoinPurchase_result();
    try {
      result.success = await iface_.reserveCoinPurchase(args.request);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reserveCoinPurchase");
      oprot.writeMessageBegin(new TMessage("reserveCoinPurchase", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reserveCoinPurchase", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reservePayment(int seqid, TProtocol iprot, TProtocol oprot) async {
    reservePayment_args args = new reservePayment_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reservePayment_result result = new reservePayment_result();
    try {
      result.success = await iface_.reservePayment(args.paymentReservation);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reservePayment");
      oprot.writeMessageBegin(new TMessage("reservePayment", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reservePayment", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

}

class buyCoinProduct_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("buyCoinProduct_args");
  static final TField _PAYMENT_RESERVATION_FIELD_DESC = new TField("paymentReservation", TType.STRUCT, 2);

  PaymentReservation _paymentReservation;
  static const int PAYMENTRESERVATION = 2;


  buyCoinProduct_args() {
  }

  // paymentReservation
  PaymentReservation get paymentReservation => this._paymentReservation;

  set paymentReservation(PaymentReservation paymentReservation) {
    this._paymentReservation = paymentReservation;
  }

  bool isSetPaymentReservation() => this.paymentReservation != null;

  unsetPaymentReservation() {
    this.paymentReservation = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PAYMENTRESERVATION:
        return this.paymentReservation;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PAYMENTRESERVATION:
        if (value == null) {
          unsetPaymentReservation();
        } else {
          this.paymentReservation = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PAYMENTRESERVATION:
        return isSetPaymentReservation();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PAYMENTRESERVATION:
          if (field.type == TType.STRUCT) {
            this.paymentReservation = new PaymentReservation();
            this.paymentReservation.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.paymentReservation != null) {
      oprot.writeFieldBegin(_PAYMENT_RESERVATION_FIELD_DESC);
      this.paymentReservation.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("buyCoinProduct_args(");

    ret.write("paymentReservation:");
    if (this.paymentReservation == null) {
      ret.write("null");
    } else {
      ret.write(this.paymentReservation);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class buyCoinProduct_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("buyCoinProduct_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  buyCoinProduct_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("buyCoinProduct_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class buyFreeProduct_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("buyFreeProduct_args");
  static final TField _RECEIVER_MID_FIELD_DESC = new TField("receiverMid", TType.STRING, 2);
  static final TField _PRODUCT_ID_FIELD_DESC = new TField("productId", TType.STRING, 3);
  static final TField _MESSAGE_TEMPLATE_FIELD_DESC = new TField("messageTemplate", TType.I32, 4);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 5);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 6);
  static final TField _PACKAGE_ID_FIELD_DESC = new TField("packageId", TType.I64, 7);

  String _receiverMid;
  static const int RECEIVERMID = 2;
  String _productId;
  static const int PRODUCTID = 3;
  int _messageTemplate = 0;
  static const int MESSAGETEMPLATE = 4;
  String _language;
  static const int LANGUAGE = 5;
  String _country;
  static const int COUNTRY = 6;
  int _packageId = 0;
  static const int PACKAGEID = 7;

  bool __isset_messageTemplate = false;
  bool __isset_packageId = false;

  buyFreeProduct_args() {
  }

  // receiverMid
  String get receiverMid => this._receiverMid;

  set receiverMid(String receiverMid) {
    this._receiverMid = receiverMid;
  }

  bool isSetReceiverMid() => this.receiverMid != null;

  unsetReceiverMid() {
    this.receiverMid = null;
  }

  // productId
  String get productId => this._productId;

  set productId(String productId) {
    this._productId = productId;
  }

  bool isSetProductId() => this.productId != null;

  unsetProductId() {
    this.productId = null;
  }

  // messageTemplate
  int get messageTemplate => this._messageTemplate;

  set messageTemplate(int messageTemplate) {
    this._messageTemplate = messageTemplate;
    this.__isset_messageTemplate = true;
  }

  bool isSetMessageTemplate() => this.__isset_messageTemplate;

  unsetMessageTemplate() {
    this.__isset_messageTemplate = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // packageId
  int get packageId => this._packageId;

  set packageId(int packageId) {
    this._packageId = packageId;
    this.__isset_packageId = true;
  }

  bool isSetPackageId() => this.__isset_packageId;

  unsetPackageId() {
    this.__isset_packageId = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case RECEIVERMID:
        return this.receiverMid;
      case PRODUCTID:
        return this.productId;
      case MESSAGETEMPLATE:
        return this.messageTemplate;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      case PACKAGEID:
        return this.packageId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case RECEIVERMID:
        if (value == null) {
          unsetReceiverMid();
        } else {
          this.receiverMid = value;
        }
        break;

      case PRODUCTID:
        if (value == null) {
          unsetProductId();
        } else {
          this.productId = value;
        }
        break;

      case MESSAGETEMPLATE:
        if (value == null) {
          unsetMessageTemplate();
        } else {
          this.messageTemplate = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case PACKAGEID:
        if (value == null) {
          unsetPackageId();
        } else {
          this.packageId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case RECEIVERMID:
        return isSetReceiverMid();
      case PRODUCTID:
        return isSetProductId();
      case MESSAGETEMPLATE:
        return isSetMessageTemplate();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      case PACKAGEID:
        return isSetPackageId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case RECEIVERMID:
          if (field.type == TType.STRING) {
            this.receiverMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PRODUCTID:
          if (field.type == TType.STRING) {
            this.productId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGETEMPLATE:
          if (field.type == TType.I32) {
            this.messageTemplate = iprot.readI32();
            this.__isset_messageTemplate = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PACKAGEID:
          if (field.type == TType.I64) {
            this.packageId = iprot.readI64();
            this.__isset_packageId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.receiverMid != null) {
      oprot.writeFieldBegin(_RECEIVER_MID_FIELD_DESC);
      oprot.writeString(this.receiverMid);
      oprot.writeFieldEnd();
    }
    if (this.productId != null) {
      oprot.writeFieldBegin(_PRODUCT_ID_FIELD_DESC);
      oprot.writeString(this.productId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MESSAGE_TEMPLATE_FIELD_DESC);
    oprot.writeI32(this.messageTemplate);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PACKAGE_ID_FIELD_DESC);
    oprot.writeI64(this.packageId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("buyFreeProduct_args(");

    ret.write("receiverMid:");
    if (this.receiverMid == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMid);
    }

    ret.write(", ");
    ret.write("productId:");
    if (this.productId == null) {
      ret.write("null");
    } else {
      ret.write(this.productId);
    }

    ret.write(", ");
    ret.write("messageTemplate:");
    ret.write(this.messageTemplate);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("packageId:");
    ret.write(this.packageId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class buyFreeProduct_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("buyFreeProduct_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  buyFreeProduct_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("buyFreeProduct_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class buyMustbuyProduct_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("buyMustbuyProduct_args");
  static final TField _RECEIVER_MID_FIELD_DESC = new TField("receiverMid", TType.STRING, 2);
  static final TField _PRODUCT_ID_FIELD_DESC = new TField("productId", TType.STRING, 3);
  static final TField _MESSAGE_TEMPLATE_FIELD_DESC = new TField("messageTemplate", TType.I32, 4);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 5);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 6);
  static final TField _PACKAGE_ID_FIELD_DESC = new TField("packageId", TType.I64, 7);
  static final TField _SERIAL_NUMBER_FIELD_DESC = new TField("serialNumber", TType.STRING, 8);

  String _receiverMid;
  static const int RECEIVERMID = 2;
  String _productId;
  static const int PRODUCTID = 3;
  int _messageTemplate = 0;
  static const int MESSAGETEMPLATE = 4;
  String _language;
  static const int LANGUAGE = 5;
  String _country;
  static const int COUNTRY = 6;
  int _packageId = 0;
  static const int PACKAGEID = 7;
  String _serialNumber;
  static const int SERIALNUMBER = 8;

  bool __isset_messageTemplate = false;
  bool __isset_packageId = false;

  buyMustbuyProduct_args() {
  }

  // receiverMid
  String get receiverMid => this._receiverMid;

  set receiverMid(String receiverMid) {
    this._receiverMid = receiverMid;
  }

  bool isSetReceiverMid() => this.receiverMid != null;

  unsetReceiverMid() {
    this.receiverMid = null;
  }

  // productId
  String get productId => this._productId;

  set productId(String productId) {
    this._productId = productId;
  }

  bool isSetProductId() => this.productId != null;

  unsetProductId() {
    this.productId = null;
  }

  // messageTemplate
  int get messageTemplate => this._messageTemplate;

  set messageTemplate(int messageTemplate) {
    this._messageTemplate = messageTemplate;
    this.__isset_messageTemplate = true;
  }

  bool isSetMessageTemplate() => this.__isset_messageTemplate;

  unsetMessageTemplate() {
    this.__isset_messageTemplate = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // packageId
  int get packageId => this._packageId;

  set packageId(int packageId) {
    this._packageId = packageId;
    this.__isset_packageId = true;
  }

  bool isSetPackageId() => this.__isset_packageId;

  unsetPackageId() {
    this.__isset_packageId = false;
  }

  // serialNumber
  String get serialNumber => this._serialNumber;

  set serialNumber(String serialNumber) {
    this._serialNumber = serialNumber;
  }

  bool isSetSerialNumber() => this.serialNumber != null;

  unsetSerialNumber() {
    this.serialNumber = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case RECEIVERMID:
        return this.receiverMid;
      case PRODUCTID:
        return this.productId;
      case MESSAGETEMPLATE:
        return this.messageTemplate;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      case PACKAGEID:
        return this.packageId;
      case SERIALNUMBER:
        return this.serialNumber;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case RECEIVERMID:
        if (value == null) {
          unsetReceiverMid();
        } else {
          this.receiverMid = value;
        }
        break;

      case PRODUCTID:
        if (value == null) {
          unsetProductId();
        } else {
          this.productId = value;
        }
        break;

      case MESSAGETEMPLATE:
        if (value == null) {
          unsetMessageTemplate();
        } else {
          this.messageTemplate = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case PACKAGEID:
        if (value == null) {
          unsetPackageId();
        } else {
          this.packageId = value;
        }
        break;

      case SERIALNUMBER:
        if (value == null) {
          unsetSerialNumber();
        } else {
          this.serialNumber = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case RECEIVERMID:
        return isSetReceiverMid();
      case PRODUCTID:
        return isSetProductId();
      case MESSAGETEMPLATE:
        return isSetMessageTemplate();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      case PACKAGEID:
        return isSetPackageId();
      case SERIALNUMBER:
        return isSetSerialNumber();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case RECEIVERMID:
          if (field.type == TType.STRING) {
            this.receiverMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PRODUCTID:
          if (field.type == TType.STRING) {
            this.productId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGETEMPLATE:
          if (field.type == TType.I32) {
            this.messageTemplate = iprot.readI32();
            this.__isset_messageTemplate = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PACKAGEID:
          if (field.type == TType.I64) {
            this.packageId = iprot.readI64();
            this.__isset_packageId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SERIALNUMBER:
          if (field.type == TType.STRING) {
            this.serialNumber = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.receiverMid != null) {
      oprot.writeFieldBegin(_RECEIVER_MID_FIELD_DESC);
      oprot.writeString(this.receiverMid);
      oprot.writeFieldEnd();
    }
    if (this.productId != null) {
      oprot.writeFieldBegin(_PRODUCT_ID_FIELD_DESC);
      oprot.writeString(this.productId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MESSAGE_TEMPLATE_FIELD_DESC);
    oprot.writeI32(this.messageTemplate);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PACKAGE_ID_FIELD_DESC);
    oprot.writeI64(this.packageId);
    oprot.writeFieldEnd();
    if (this.serialNumber != null) {
      oprot.writeFieldBegin(_SERIAL_NUMBER_FIELD_DESC);
      oprot.writeString(this.serialNumber);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("buyMustbuyProduct_args(");

    ret.write("receiverMid:");
    if (this.receiverMid == null) {
      ret.write("null");
    } else {
      ret.write(this.receiverMid);
    }

    ret.write(", ");
    ret.write("productId:");
    if (this.productId == null) {
      ret.write("null");
    } else {
      ret.write(this.productId);
    }

    ret.write(", ");
    ret.write("messageTemplate:");
    ret.write(this.messageTemplate);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("packageId:");
    ret.write(this.packageId);

    ret.write(", ");
    ret.write("serialNumber:");
    if (this.serialNumber == null) {
      ret.write("null");
    } else {
      ret.write(this.serialNumber);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class buyMustbuyProduct_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("buyMustbuyProduct_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  buyMustbuyProduct_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("buyMustbuyProduct_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class checkCanReceivePresent_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("checkCanReceivePresent_args");
  static final TField _RECIPIENT_MID_FIELD_DESC = new TField("recipientMid", TType.STRING, 2);
  static final TField _PACKAGE_ID_FIELD_DESC = new TField("packageId", TType.I64, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  String _recipientMid;
  static const int RECIPIENTMID = 2;
  int _packageId = 0;
  static const int PACKAGEID = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_packageId = false;

  checkCanReceivePresent_args() {
  }

  // recipientMid
  String get recipientMid => this._recipientMid;

  set recipientMid(String recipientMid) {
    this._recipientMid = recipientMid;
  }

  bool isSetRecipientMid() => this.recipientMid != null;

  unsetRecipientMid() {
    this.recipientMid = null;
  }

  // packageId
  int get packageId => this._packageId;

  set packageId(int packageId) {
    this._packageId = packageId;
    this.__isset_packageId = true;
  }

  bool isSetPackageId() => this.__isset_packageId;

  unsetPackageId() {
    this.__isset_packageId = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case RECIPIENTMID:
        return this.recipientMid;
      case PACKAGEID:
        return this.packageId;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case RECIPIENTMID:
        if (value == null) {
          unsetRecipientMid();
        } else {
          this.recipientMid = value;
        }
        break;

      case PACKAGEID:
        if (value == null) {
          unsetPackageId();
        } else {
          this.packageId = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case RECIPIENTMID:
        return isSetRecipientMid();
      case PACKAGEID:
        return isSetPackageId();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case RECIPIENTMID:
          if (field.type == TType.STRING) {
            this.recipientMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PACKAGEID:
          if (field.type == TType.I64) {
            this.packageId = iprot.readI64();
            this.__isset_packageId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.recipientMid != null) {
      oprot.writeFieldBegin(_RECIPIENT_MID_FIELD_DESC);
      oprot.writeString(this.recipientMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_PACKAGE_ID_FIELD_DESC);
    oprot.writeI64(this.packageId);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("checkCanReceivePresent_args(");

    ret.write("recipientMid:");
    if (this.recipientMid == null) {
      ret.write("null");
    } else {
      ret.write(this.recipientMid);
    }

    ret.write(", ");
    ret.write("packageId:");
    ret.write(this.packageId);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class checkCanReceivePresent_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("checkCanReceivePresent_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  checkCanReceivePresent_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("checkCanReceivePresent_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getActivePurchases_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getActivePurchases_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getActivePurchases_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getActivePurchases_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getActivePurchases_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getActivePurchases_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getActivePurchases_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getActivePurchases_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getActivePurchaseVersions_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getActivePurchaseVersions_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getActivePurchaseVersions_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getActivePurchaseVersions_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getActivePurchaseVersions_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getActivePurchaseVersions_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductSimpleList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getActivePurchaseVersions_result() {
  }

  // success
  ProductSimpleList get success => this._success;

  set success(ProductSimpleList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductSimpleList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getActivePurchaseVersions_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCoinProducts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinProducts_args");
  static final TField _APP_STORE_CODE_FIELD_DESC = new TField("appStoreCode", TType.I32, 2);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);

  int _appStoreCode;
  static const int APPSTORECODE = 2;
  String _country;
  static const int COUNTRY = 3;
  String _language;
  static const int LANGUAGE = 4;

  bool __isset_appStoreCode = false;

  getCoinProducts_args() {
  }

  // appStoreCode
  int get appStoreCode => this._appStoreCode;

  set appStoreCode(int appStoreCode) {
    this._appStoreCode = appStoreCode;
    this.__isset_appStoreCode = true;
  }

  bool isSetAppStoreCode() => this.__isset_appStoreCode;

  unsetAppStoreCode() {
    this.__isset_appStoreCode = false;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return this.appStoreCode;
      case COUNTRY:
        return this.country;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case APPSTORECODE:
        if (value == null) {
          unsetAppStoreCode();
        } else {
          this.appStoreCode = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return isSetAppStoreCode();
      case COUNTRY:
        return isSetCountry();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case APPSTORECODE:
          if (field.type == TType.I32) {
            this.appStoreCode = iprot.readI32();
            this.__isset_appStoreCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_APP_STORE_CODE_FIELD_DESC);
    oprot.writeI32(this.appStoreCode);
    oprot.writeFieldEnd();
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinProducts_args(");

    ret.write("appStoreCode:");
    String appStoreCode_name = PaymentType.VALUES_TO_NAMES[this.appStoreCode];
    if (appStoreCode_name != null) {
      ret.write(appStoreCode_name);
      ret.write(" (");
    }
    ret.write(this.appStoreCode);
    if (appStoreCode_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAppStoreCode() && !PaymentType.VALID_VALUES.contains(appStoreCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'appStoreCode' has been assigned the invalid value $appStoreCode");
    }
  }

}

class getCoinProducts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinProducts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<CoinProductItem> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCoinProducts_result() {
  }

  // success
  List<CoinProductItem> get success => this._success;

  set success(List<CoinProductItem> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list786 = iprot.readListBegin();
              this.success = new List<CoinProductItem>();
              for (int _i787 = 0; _i787 < _list786.length; ++_i787) {
                CoinProductItem _elem788;
                _elem788 = new CoinProductItem();
                _elem788.read(iprot);
                this.success.add(_elem788);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem789 in this.success) {
          elem789.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinProducts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCoinProductsByPgCode_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinProductsByPgCode_args");
  static final TField _APP_STORE_CODE_FIELD_DESC = new TField("appStoreCode", TType.I32, 2);
  static final TField _PG_CODE_FIELD_DESC = new TField("pgCode", TType.I32, 3);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 4);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 5);

  int _appStoreCode;
  static const int APPSTORECODE = 2;
  int _pgCode;
  static const int PGCODE = 3;
  String _country;
  static const int COUNTRY = 4;
  String _language;
  static const int LANGUAGE = 5;

  bool __isset_appStoreCode = false;
  bool __isset_pgCode = false;

  getCoinProductsByPgCode_args() {
  }

  // appStoreCode
  int get appStoreCode => this._appStoreCode;

  set appStoreCode(int appStoreCode) {
    this._appStoreCode = appStoreCode;
    this.__isset_appStoreCode = true;
  }

  bool isSetAppStoreCode() => this.__isset_appStoreCode;

  unsetAppStoreCode() {
    this.__isset_appStoreCode = false;
  }

  // pgCode
  int get pgCode => this._pgCode;

  set pgCode(int pgCode) {
    this._pgCode = pgCode;
    this.__isset_pgCode = true;
  }

  bool isSetPgCode() => this.__isset_pgCode;

  unsetPgCode() {
    this.__isset_pgCode = false;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return this.appStoreCode;
      case PGCODE:
        return this.pgCode;
      case COUNTRY:
        return this.country;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case APPSTORECODE:
        if (value == null) {
          unsetAppStoreCode();
        } else {
          this.appStoreCode = value;
        }
        break;

      case PGCODE:
        if (value == null) {
          unsetPgCode();
        } else {
          this.pgCode = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return isSetAppStoreCode();
      case PGCODE:
        return isSetPgCode();
      case COUNTRY:
        return isSetCountry();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case APPSTORECODE:
          if (field.type == TType.I32) {
            this.appStoreCode = iprot.readI32();
            this.__isset_appStoreCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PGCODE:
          if (field.type == TType.I32) {
            this.pgCode = iprot.readI32();
            this.__isset_pgCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_APP_STORE_CODE_FIELD_DESC);
    oprot.writeI32(this.appStoreCode);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_PG_CODE_FIELD_DESC);
    oprot.writeI32(this.pgCode);
    oprot.writeFieldEnd();
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinProductsByPgCode_args(");

    ret.write("appStoreCode:");
    String appStoreCode_name = PaymentType.VALUES_TO_NAMES[this.appStoreCode];
    if (appStoreCode_name != null) {
      ret.write(appStoreCode_name);
      ret.write(" (");
    }
    ret.write(this.appStoreCode);
    if (appStoreCode_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("pgCode:");
    String pgCode_name = PaymentPgType.VALUES_TO_NAMES[this.pgCode];
    if (pgCode_name != null) {
      ret.write(pgCode_name);
      ret.write(" (");
    }
    ret.write(this.pgCode);
    if (pgCode_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAppStoreCode() && !PaymentType.VALID_VALUES.contains(appStoreCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'appStoreCode' has been assigned the invalid value $appStoreCode");
    }
    if (isSetPgCode() && !PaymentPgType.VALID_VALUES.contains(pgCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'pgCode' has been assigned the invalid value $pgCode");
    }
  }

}

class getCoinProductsByPgCode_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinProductsByPgCode_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<CoinProductItem> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCoinProductsByPgCode_result() {
  }

  // success
  List<CoinProductItem> get success => this._success;

  set success(List<CoinProductItem> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list790 = iprot.readListBegin();
              this.success = new List<CoinProductItem>();
              for (int _i791 = 0; _i791 < _list790.length; ++_i791) {
                CoinProductItem _elem792;
                _elem792 = new CoinProductItem();
                _elem792.read(iprot);
                this.success.add(_elem792);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem793 in this.success) {
          elem793.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinProductsByPgCode_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCoinPurchaseHistory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinPurchaseHistory_args");
  static final TField _REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, 2);

  CoinHistoryCondition _request;
  static const int REQUEST = 2;


  getCoinPurchaseHistory_args() {
  }

  // request
  CoinHistoryCondition get request => this._request;

  set request(CoinHistoryCondition request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUEST:
          if (field.type == TType.STRUCT) {
            this.request = new CoinHistoryCondition();
            this.request.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      this.request.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinPurchaseHistory_args(");

    ret.write("request:");
    if (this.request == null) {
      ret.write("null");
    } else {
      ret.write(this.request);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCoinPurchaseHistory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinPurchaseHistory_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  CoinHistoryResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCoinPurchaseHistory_result() {
  }

  // success
  CoinHistoryResult get success => this._success;

  set success(CoinHistoryResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new CoinHistoryResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinPurchaseHistory_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCoinUseAndRefundHistory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinUseAndRefundHistory_args");
  static final TField _REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, 2);

  CoinHistoryCondition _request;
  static const int REQUEST = 2;


  getCoinUseAndRefundHistory_args() {
  }

  // request
  CoinHistoryCondition get request => this._request;

  set request(CoinHistoryCondition request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUEST:
          if (field.type == TType.STRUCT) {
            this.request = new CoinHistoryCondition();
            this.request.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      this.request.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinUseAndRefundHistory_args(");

    ret.write("request:");
    if (this.request == null) {
      ret.write("null");
    } else {
      ret.write(this.request);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCoinUseAndRefundHistory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCoinUseAndRefundHistory_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  CoinHistoryResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCoinUseAndRefundHistory_result() {
  }

  // success
  CoinHistoryResult get success => this._success;

  set success(CoinHistoryResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new CoinHistoryResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCoinUseAndRefundHistory_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDownloads_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getDownloads_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getDownloads_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getDownloads_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDownloads_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getDownloads_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getDownloads_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getDownloads_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getEventPackages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getEventPackages_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getEventPackages_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getEventPackages_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getEventPackages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getEventPackages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getEventPackages_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getEventPackages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNewlyReleasedPackages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNewlyReleasedPackages_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getNewlyReleasedPackages_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNewlyReleasedPackages_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNewlyReleasedPackages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNewlyReleasedPackages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getNewlyReleasedPackages_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNewlyReleasedPackages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPopularPackages_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPopularPackages_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getPopularPackages_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPopularPackages_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPopularPackages_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPopularPackages_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPopularPackages_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPopularPackages_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPresentsReceived_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPresentsReceived_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getPresentsReceived_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPresentsReceived_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPresentsReceived_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPresentsReceived_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPresentsReceived_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPresentsReceived_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPresentsSent_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPresentsSent_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getPresentsSent_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPresentsSent_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPresentsSent_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPresentsSent_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPresentsSent_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPresentsSent_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProduct_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProduct_args");
  static final TField _PACKAGE_ID_FIELD_DESC = new TField("packageID", TType.I64, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 4);

  int _packageID = 0;
  static const int PACKAGEID = 2;
  String _language;
  static const int LANGUAGE = 3;
  String _country;
  static const int COUNTRY = 4;

  bool __isset_packageID = false;

  getProduct_args() {
  }

  // packageID
  int get packageID => this._packageID;

  set packageID(int packageID) {
    this._packageID = packageID;
    this.__isset_packageID = true;
  }

  bool isSetPackageID() => this.__isset_packageID;

  unsetPackageID() {
    this.__isset_packageID = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PACKAGEID:
        return this.packageID;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PACKAGEID:
        if (value == null) {
          unsetPackageID();
        } else {
          this.packageID = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PACKAGEID:
        return isSetPackageID();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PACKAGEID:
          if (field.type == TType.I64) {
            this.packageID = iprot.readI64();
            this.__isset_packageID = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PACKAGE_ID_FIELD_DESC);
    oprot.writeI64(this.packageID);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProduct_args(");

    ret.write("packageID:");
    ret.write(this.packageID);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProduct_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProduct_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Product _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProduct_result() {
  }

  // success
  Product get success => this._success;

  set success(Product success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Product();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProduct_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProductList_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProductList_args");
  static final TField _PRODUCT_ID_LIST_FIELD_DESC = new TField("productIdList", TType.LIST, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 4);

  List<String> _productIdList;
  static const int PRODUCTIDLIST = 2;
  String _language;
  static const int LANGUAGE = 3;
  String _country;
  static const int COUNTRY = 4;


  getProductList_args() {
  }

  // productIdList
  List<String> get productIdList => this._productIdList;

  set productIdList(List<String> productIdList) {
    this._productIdList = productIdList;
  }

  bool isSetProductIdList() => this.productIdList != null;

  unsetProductIdList() {
    this.productIdList = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PRODUCTIDLIST:
        return this.productIdList;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PRODUCTIDLIST:
        if (value == null) {
          unsetProductIdList();
        } else {
          this.productIdList = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PRODUCTIDLIST:
        return isSetProductIdList();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PRODUCTIDLIST:
          if (field.type == TType.LIST) {
            {
              TList _list794 = iprot.readListBegin();
              this.productIdList = new List<String>();
              for (int _i795 = 0; _i795 < _list794.length; ++_i795) {
                String _elem796;
                _elem796 = iprot.readString();
                this.productIdList.add(_elem796);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.productIdList != null) {
      oprot.writeFieldBegin(_PRODUCT_ID_LIST_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.productIdList.length));
        for (var elem797 in this.productIdList) {
          oprot.writeString(elem797);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProductList_args(");

    ret.write("productIdList:");
    if (this.productIdList == null) {
      ret.write("null");
    } else {
      ret.write(this.productIdList);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProductList_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProductList_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProductList_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProductList_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProductListWithCarrier_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProductListWithCarrier_args");
  static final TField _PRODUCT_ID_LIST_FIELD_DESC = new TField("productIdList", TType.LIST, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 4);
  static final TField _CARRIER_CODE_FIELD_DESC = new TField("carrierCode", TType.STRING, 5);

  List<String> _productIdList;
  static const int PRODUCTIDLIST = 2;
  String _language;
  static const int LANGUAGE = 3;
  String _country;
  static const int COUNTRY = 4;
  String _carrierCode;
  static const int CARRIERCODE = 5;


  getProductListWithCarrier_args() {
  }

  // productIdList
  List<String> get productIdList => this._productIdList;

  set productIdList(List<String> productIdList) {
    this._productIdList = productIdList;
  }

  bool isSetProductIdList() => this.productIdList != null;

  unsetProductIdList() {
    this.productIdList = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // carrierCode
  String get carrierCode => this._carrierCode;

  set carrierCode(String carrierCode) {
    this._carrierCode = carrierCode;
  }

  bool isSetCarrierCode() => this.carrierCode != null;

  unsetCarrierCode() {
    this.carrierCode = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PRODUCTIDLIST:
        return this.productIdList;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      case CARRIERCODE:
        return this.carrierCode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PRODUCTIDLIST:
        if (value == null) {
          unsetProductIdList();
        } else {
          this.productIdList = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case CARRIERCODE:
        if (value == null) {
          unsetCarrierCode();
        } else {
          this.carrierCode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PRODUCTIDLIST:
        return isSetProductIdList();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      case CARRIERCODE:
        return isSetCarrierCode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PRODUCTIDLIST:
          if (field.type == TType.LIST) {
            {
              TList _list798 = iprot.readListBegin();
              this.productIdList = new List<String>();
              for (int _i799 = 0; _i799 < _list798.length; ++_i799) {
                String _elem800;
                _elem800 = iprot.readString();
                this.productIdList.add(_elem800);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CARRIERCODE:
          if (field.type == TType.STRING) {
            this.carrierCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.productIdList != null) {
      oprot.writeFieldBegin(_PRODUCT_ID_LIST_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.productIdList.length));
        for (var elem801 in this.productIdList) {
          oprot.writeString(elem801);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    if (this.carrierCode != null) {
      oprot.writeFieldBegin(_CARRIER_CODE_FIELD_DESC);
      oprot.writeString(this.carrierCode);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProductListWithCarrier_args(");

    ret.write("productIdList:");
    if (this.productIdList == null) {
      ret.write("null");
    } else {
      ret.write(this.productIdList);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("carrierCode:");
    if (this.carrierCode == null) {
      ret.write("null");
    } else {
      ret.write(this.carrierCode);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProductListWithCarrier_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProductListWithCarrier_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProductListWithCarrier_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProductListWithCarrier_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProductWithCarrier_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProductWithCarrier_args");
  static final TField _PACKAGE_ID_FIELD_DESC = new TField("packageID", TType.I64, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 4);
  static final TField _CARRIER_CODE_FIELD_DESC = new TField("carrierCode", TType.STRING, 5);

  int _packageID = 0;
  static const int PACKAGEID = 2;
  String _language;
  static const int LANGUAGE = 3;
  String _country;
  static const int COUNTRY = 4;
  String _carrierCode;
  static const int CARRIERCODE = 5;

  bool __isset_packageID = false;

  getProductWithCarrier_args() {
  }

  // packageID
  int get packageID => this._packageID;

  set packageID(int packageID) {
    this._packageID = packageID;
    this.__isset_packageID = true;
  }

  bool isSetPackageID() => this.__isset_packageID;

  unsetPackageID() {
    this.__isset_packageID = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // carrierCode
  String get carrierCode => this._carrierCode;

  set carrierCode(String carrierCode) {
    this._carrierCode = carrierCode;
  }

  bool isSetCarrierCode() => this.carrierCode != null;

  unsetCarrierCode() {
    this.carrierCode = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PACKAGEID:
        return this.packageID;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      case CARRIERCODE:
        return this.carrierCode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PACKAGEID:
        if (value == null) {
          unsetPackageID();
        } else {
          this.packageID = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case CARRIERCODE:
        if (value == null) {
          unsetCarrierCode();
        } else {
          this.carrierCode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PACKAGEID:
        return isSetPackageID();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      case CARRIERCODE:
        return isSetCarrierCode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PACKAGEID:
          if (field.type == TType.I64) {
            this.packageID = iprot.readI64();
            this.__isset_packageID = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CARRIERCODE:
          if (field.type == TType.STRING) {
            this.carrierCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PACKAGE_ID_FIELD_DESC);
    oprot.writeI64(this.packageID);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    if (this.carrierCode != null) {
      oprot.writeFieldBegin(_CARRIER_CODE_FIELD_DESC);
      oprot.writeString(this.carrierCode);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProductWithCarrier_args(");

    ret.write("packageID:");
    ret.write(this.packageID);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("carrierCode:");
    if (this.carrierCode == null) {
      ret.write("null");
    } else {
      ret.write(this.carrierCode);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProductWithCarrier_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProductWithCarrier_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Product _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProductWithCarrier_result() {
  }

  // success
  Product get success => this._success;

  set success(Product success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Product();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProductWithCarrier_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPurchaseHistory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPurchaseHistory_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 5);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _country;
  static const int COUNTRY = 5;

  bool __isset_start = false;
  bool __isset_size = false;

  getPurchaseHistory_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      case COUNTRY:
        return this.country;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      case COUNTRY:
        return isSetCountry();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPurchaseHistory_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPurchaseHistory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPurchaseHistory_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ProductList _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPurchaseHistory_result() {
  }

  // success
  ProductList get success => this._success;

  set success(ProductList success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ProductList();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPurchaseHistory_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getTotalBalance_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getTotalBalance_args");
  static final TField _APP_STORE_CODE_FIELD_DESC = new TField("appStoreCode", TType.I32, 2);

  int _appStoreCode;
  static const int APPSTORECODE = 2;

  bool __isset_appStoreCode = false;

  getTotalBalance_args() {
  }

  // appStoreCode
  int get appStoreCode => this._appStoreCode;

  set appStoreCode(int appStoreCode) {
    this._appStoreCode = appStoreCode;
    this.__isset_appStoreCode = true;
  }

  bool isSetAppStoreCode() => this.__isset_appStoreCode;

  unsetAppStoreCode() {
    this.__isset_appStoreCode = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return this.appStoreCode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case APPSTORECODE:
        if (value == null) {
          unsetAppStoreCode();
        } else {
          this.appStoreCode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return isSetAppStoreCode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case APPSTORECODE:
          if (field.type == TType.I32) {
            this.appStoreCode = iprot.readI32();
            this.__isset_appStoreCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_APP_STORE_CODE_FIELD_DESC);
    oprot.writeI32(this.appStoreCode);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getTotalBalance_args(");

    ret.write("appStoreCode:");
    String appStoreCode_name = PaymentType.VALUES_TO_NAMES[this.appStoreCode];
    if (appStoreCode_name != null) {
      ret.write(appStoreCode_name);
      ret.write(" (");
    }
    ret.write(this.appStoreCode);
    if (appStoreCode_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAppStoreCode() && !PaymentType.VALID_VALUES.contains(appStoreCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'appStoreCode' has been assigned the invalid value $appStoreCode");
    }
  }

}

class getTotalBalance_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getTotalBalance_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Coin _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getTotalBalance_result() {
  }

  // success
  Coin get success => this._success;

  set success(Coin success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Coin();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getTotalBalance_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyDownloaded_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyDownloaded_args");
  static final TField _PACKAGE_ID_FIELD_DESC = new TField("packageId", TType.I64, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);

  int _packageId = 0;
  static const int PACKAGEID = 2;
  String _language;
  static const int LANGUAGE = 3;

  bool __isset_packageId = false;

  notifyDownloaded_args() {
  }

  // packageId
  int get packageId => this._packageId;

  set packageId(int packageId) {
    this._packageId = packageId;
    this.__isset_packageId = true;
  }

  bool isSetPackageId() => this.__isset_packageId;

  unsetPackageId() {
    this.__isset_packageId = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PACKAGEID:
        return this.packageId;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PACKAGEID:
        if (value == null) {
          unsetPackageId();
        } else {
          this.packageId = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PACKAGEID:
        return isSetPackageId();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PACKAGEID:
          if (field.type == TType.I64) {
            this.packageId = iprot.readI64();
            this.__isset_packageId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PACKAGE_ID_FIELD_DESC);
    oprot.writeI64(this.packageId);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyDownloaded_args(");

    ret.write("packageId:");
    ret.write(this.packageId);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyDownloaded_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyDownloaded_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  notifyDownloaded_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyDownloaded_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reserveCoinPurchase_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reserveCoinPurchase_args");
  static final TField _REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, 2);

  CoinPurchaseReservation _request;
  static const int REQUEST = 2;


  reserveCoinPurchase_args() {
  }

  // request
  CoinPurchaseReservation get request => this._request;

  set request(CoinPurchaseReservation request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUEST:
          if (field.type == TType.STRUCT) {
            this.request = new CoinPurchaseReservation();
            this.request.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      this.request.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reserveCoinPurchase_args(");

    ret.write("request:");
    if (this.request == null) {
      ret.write("null");
    } else {
      ret.write(this.request);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reserveCoinPurchase_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reserveCoinPurchase_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaymentReservationResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reserveCoinPurchase_result() {
  }

  // success
  PaymentReservationResult get success => this._success;

  set success(PaymentReservationResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaymentReservationResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reserveCoinPurchase_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reservePayment_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reservePayment_args");
  static final TField _PAYMENT_RESERVATION_FIELD_DESC = new TField("paymentReservation", TType.STRUCT, 2);

  PaymentReservation _paymentReservation;
  static const int PAYMENTRESERVATION = 2;


  reservePayment_args() {
  }

  // paymentReservation
  PaymentReservation get paymentReservation => this._paymentReservation;

  set paymentReservation(PaymentReservation paymentReservation) {
    this._paymentReservation = paymentReservation;
  }

  bool isSetPaymentReservation() => this.paymentReservation != null;

  unsetPaymentReservation() {
    this.paymentReservation = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PAYMENTRESERVATION:
        return this.paymentReservation;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PAYMENTRESERVATION:
        if (value == null) {
          unsetPaymentReservation();
        } else {
          this.paymentReservation = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PAYMENTRESERVATION:
        return isSetPaymentReservation();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PAYMENTRESERVATION:
          if (field.type == TType.STRUCT) {
            this.paymentReservation = new PaymentReservation();
            this.paymentReservation.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.paymentReservation != null) {
      oprot.writeFieldBegin(_PAYMENT_RESERVATION_FIELD_DESC);
      this.paymentReservation.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reservePayment_args(");

    ret.write("paymentReservation:");
    if (this.paymentReservation == null) {
      ret.write("null");
    } else {
      ret.write(this.paymentReservation);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reservePayment_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reservePayment_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaymentReservationResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reservePayment_result() {
  }

  // success
  PaymentReservationResult get success => this._success;

  set success(PaymentReservationResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaymentReservationResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reservePayment_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

