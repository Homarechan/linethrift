#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Types;


# HELPER FUNCTIONS AND STRUCTURES

package ChannelService_issueOTP_args;
use base qw(Class::Accessor);
ChannelService_issueOTP_args->mk_accessors( qw( channelId ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueOTP_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueOTP_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueOTP_result;
use base qw(Class::Accessor);
ChannelService_issueOTP_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueOTP_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = OTPResult->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueOTP_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_approveChannelAndIssueChannelToken_args;
use base qw(Class::Accessor);
ChannelService_approveChannelAndIssueChannelToken_args->mk_accessors( qw( channelId ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_approveChannelAndIssueChannelToken_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_approveChannelAndIssueChannelToken_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_approveChannelAndIssueChannelToken_result;
use base qw(Class::Accessor);
ChannelService_approveChannelAndIssueChannelToken_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_approveChannelAndIssueChannelToken_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelToken->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_approveChannelAndIssueChannelToken_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_approveChannelAndIssueRequestToken_args;
use base qw(Class::Accessor);
ChannelService_approveChannelAndIssueRequestToken_args->mk_accessors( qw( channelId otpId ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                $self->{otpId} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                  if (defined $vals->{otpId}) {
                    $self->{otpId} = $vals->{otpId};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_approveChannelAndIssueRequestToken_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{otpId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_approveChannelAndIssueRequestToken_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{otpId}) {
                  $xfer += $output->writeFieldBegin('otpId', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{otpId});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_approveChannelAndIssueRequestToken_result;
use base qw(Class::Accessor);
ChannelService_approveChannelAndIssueRequestToken_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_approveChannelAndIssueRequestToken_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_approveChannelAndIssueRequestToken_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                  $xfer += $output->writeString($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_fetchNotificationItems_args;
use base qw(Class::Accessor);
ChannelService_fetchNotificationItems_args->mk_accessors( qw( localRev ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{localRev} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{localRev}) {
                    $self->{localRev} = $vals->{localRev};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_fetchNotificationItems_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{localRev});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_fetchNotificationItems_args');
                if (defined $self->{localRev}) {
                  $xfer += $output->writeFieldBegin('localRev', Thrift::TType::I64, 2);
                  $xfer += $output->writeI64($self->{localRev});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_fetchNotificationItems_result;
use base qw(Class::Accessor);
ChannelService_fetchNotificationItems_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_fetchNotificationItems_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = NotificationFetchResult->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_fetchNotificationItems_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getApprovedChannels_args;
use base qw(Class::Accessor);
ChannelService_getApprovedChannels_args->mk_accessors( qw( lastSynced locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{lastSynced} = undef;
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{lastSynced}) {
                    $self->{lastSynced} = $vals->{lastSynced};
                  }
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getApprovedChannels_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{lastSynced});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getApprovedChannels_args');
                if (defined $self->{lastSynced}) {
                  $xfer += $output->writeFieldBegin('lastSynced', Thrift::TType::I64, 2);
                  $xfer += $output->writeI64($self->{lastSynced});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 3);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getApprovedChannels_result;
use base qw(Class::Accessor);
ChannelService_getApprovedChannels_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getApprovedChannels_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ApprovedChannelInfos->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getApprovedChannels_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannelInfo_args;
use base qw(Class::Accessor);
ChannelService_getChannelInfo_args->mk_accessors( qw( channelId locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannelInfo_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannelInfo_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 3);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannelInfo_result;
use base qw(Class::Accessor);
ChannelService_getChannelInfo_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannelInfo_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelInfo->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannelInfo_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannelNotificationSetting_args;
use base qw(Class::Accessor);
ChannelService_getChannelNotificationSetting_args->mk_accessors( qw( channelId locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannelNotificationSetting_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannelNotificationSetting_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannelNotificationSetting_result;
use base qw(Class::Accessor);
ChannelService_getChannelNotificationSetting_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannelNotificationSetting_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelNotificationSetting->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannelNotificationSetting_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannelNotificationSettings_args;
use base qw(Class::Accessor);
ChannelService_getChannelNotificationSettings_args->mk_accessors( qw( locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannelNotificationSettings_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannelNotificationSettings_args');
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannelNotificationSettings_result;
use base qw(Class::Accessor);
ChannelService_getChannelNotificationSettings_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannelNotificationSettings_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::LIST) {
                      {
                        my $_size1264 = 0;
                        $self->{success} = [];
                        my $_etype1267 = 0;
                        $xfer += $input->readListBegin(\$_etype1267, \$_size1264);
                        for (my $_i1268 = 0; $_i1268 < $_size1264; ++$_i1268)
                        {
                          my $elem1269 = undef;
                          $elem1269 = ChannelNotificationSetting->new();
                          $xfer += $elem1269->read($input);
                          push(@{$self->{success}},$elem1269);
                        }
                        $xfer += $input->readListEnd();
                      }
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannelNotificationSettings_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                  {
                    $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                    {
                      foreach my $iter1270 (@{$self->{success}}) 
                      {
                        $xfer += ${iter1270}->write($output);
                      }
                    }
                    $xfer += $output->writeListEnd();
                  }
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannels_args;
use base qw(Class::Accessor);
ChannelService_getChannels_args->mk_accessors( qw( lastSynced locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{lastSynced} = undef;
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{lastSynced}) {
                    $self->{lastSynced} = $vals->{lastSynced};
                  }
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannels_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{lastSynced});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannels_args');
                if (defined $self->{lastSynced}) {
                  $xfer += $output->writeFieldBegin('lastSynced', Thrift::TType::I64, 2);
                  $xfer += $output->writeI64($self->{lastSynced});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 3);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getChannels_result;
use base qw(Class::Accessor);
ChannelService_getChannels_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getChannels_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelInfos->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getChannels_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getDomains_args;
use base qw(Class::Accessor);
ChannelService_getDomains_args->mk_accessors( qw( lastSynced ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{lastSynced} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{lastSynced}) {
                    $self->{lastSynced} = $vals->{lastSynced};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getDomains_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{lastSynced});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getDomains_args');
                if (defined $self->{lastSynced}) {
                  $xfer += $output->writeFieldBegin('lastSynced', Thrift::TType::I64, 2);
                  $xfer += $output->writeI64($self->{lastSynced});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getDomains_result;
use base qw(Class::Accessor);
ChannelService_getDomains_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getDomains_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelDomains->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getDomains_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getFriendChannelMatrices_args;
use base qw(Class::Accessor);
ChannelService_getFriendChannelMatrices_args->mk_accessors( qw( channelIds ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelIds} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelIds}) {
                    $self->{channelIds} = $vals->{channelIds};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getFriendChannelMatrices_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::LIST) {
                      {
                        my $_size1271 = 0;
                        $self->{channelIds} = [];
                        my $_etype1274 = 0;
                        $xfer += $input->readListBegin(\$_etype1274, \$_size1271);
                        for (my $_i1275 = 0; $_i1275 < $_size1271; ++$_i1275)
                        {
                          my $elem1276 = undef;
                          $xfer += $input->readString(\$elem1276);
                          push(@{$self->{channelIds}},$elem1276);
                        }
                        $xfer += $input->readListEnd();
                      }
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getFriendChannelMatrices_args');
                if (defined $self->{channelIds}) {
                  $xfer += $output->writeFieldBegin('channelIds', Thrift::TType::LIST, 1);
                  {
                    $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{channelIds}}));
                    {
                      foreach my $iter1277 (@{$self->{channelIds}}) 
                      {
                        $xfer += $output->writeString($iter1277);
                      }
                    }
                    $xfer += $output->writeListEnd();
                  }
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getFriendChannelMatrices_result;
use base qw(Class::Accessor);
ChannelService_getFriendChannelMatrices_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getFriendChannelMatrices_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = FriendChannelMatricesResponse->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getFriendChannelMatrices_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_updateChannelSettings_args;
use base qw(Class::Accessor);
ChannelService_updateChannelSettings_args->mk_accessors( qw( channelSettings ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelSettings} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelSettings}) {
                    $self->{channelSettings} = $vals->{channelSettings};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_updateChannelSettings_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{channelSettings} = ChannelSettings->new();
                      $xfer += $self->{channelSettings}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_updateChannelSettings_args');
                if (defined $self->{channelSettings}) {
                  $xfer += $output->writeFieldBegin('channelSettings', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{channelSettings}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_updateChannelSettings_result;
use base qw(Class::Accessor);
ChannelService_updateChannelSettings_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_updateChannelSettings_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::BOOL) {
                      $xfer += $input->readBool(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_updateChannelSettings_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                  $xfer += $output->writeBool($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getCommonDomains_args;
use base qw(Class::Accessor);
ChannelService_getCommonDomains_args->mk_accessors( qw( lastSynced ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{lastSynced} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{lastSynced}) {
                    $self->{lastSynced} = $vals->{lastSynced};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getCommonDomains_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{lastSynced});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getCommonDomains_args');
                if (defined $self->{lastSynced}) {
                  $xfer += $output->writeFieldBegin('lastSynced', Thrift::TType::I64, 1);
                  $xfer += $output->writeI64($self->{lastSynced});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getCommonDomains_result;
use base qw(Class::Accessor);
ChannelService_getCommonDomains_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getCommonDomains_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelDomains->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getCommonDomains_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getNotificationBadgeCount_args;
use base qw(Class::Accessor);
ChannelService_getNotificationBadgeCount_args->mk_accessors( qw( localRev ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{localRev} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{localRev}) {
                    $self->{localRev} = $vals->{localRev};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getNotificationBadgeCount_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{localRev});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getNotificationBadgeCount_args');
                if (defined $self->{localRev}) {
                  $xfer += $output->writeFieldBegin('localRev', Thrift::TType::I64, 2);
                  $xfer += $output->writeI64($self->{localRev});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getNotificationBadgeCount_result;
use base qw(Class::Accessor);
ChannelService_getNotificationBadgeCount_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getNotificationBadgeCount_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getNotificationBadgeCount_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueChannelToken_args;
use base qw(Class::Accessor);
ChannelService_issueChannelToken_args->mk_accessors( qw( channelId ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueChannelToken_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueChannelToken_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueChannelToken_result;
use base qw(Class::Accessor);
ChannelService_issueChannelToken_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueChannelToken_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelToken->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueChannelToken_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueRequestToken_args;
use base qw(Class::Accessor);
ChannelService_issueRequestToken_args->mk_accessors( qw( channelId otpId ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                $self->{otpId} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                  if (defined $vals->{otpId}) {
                    $self->{otpId} = $vals->{otpId};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueRequestToken_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{otpId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueRequestToken_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{otpId}) {
                  $xfer += $output->writeFieldBegin('otpId', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{otpId});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueRequestToken_result;
use base qw(Class::Accessor);
ChannelService_issueRequestToken_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueRequestToken_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueRequestToken_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                  $xfer += $output->writeString($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueRequestTokenWithAuthScheme_args;
use base qw(Class::Accessor);
ChannelService_issueRequestTokenWithAuthScheme_args->mk_accessors( qw( channelId otpId authScheme returnUrl ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                $self->{otpId} = undef;
                $self->{authScheme} = undef;
                $self->{returnUrl} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                  if (defined $vals->{otpId}) {
                    $self->{otpId} = $vals->{otpId};
                  }
                  if (defined $vals->{authScheme}) {
                    $self->{authScheme} = $vals->{authScheme};
                  }
                  if (defined $vals->{returnUrl}) {
                    $self->{returnUrl} = $vals->{returnUrl};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueRequestTokenWithAuthScheme_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{otpId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::LIST) {
                      {
                        my $_size1278 = 0;
                        $self->{authScheme} = [];
                        my $_etype1281 = 0;
                        $xfer += $input->readListBegin(\$_etype1281, \$_size1278);
                        for (my $_i1282 = 0; $_i1282 < $_size1278; ++$_i1282)
                        {
                          my $elem1283 = undef;
                          $xfer += $input->readString(\$elem1283);
                          push(@{$self->{authScheme}},$elem1283);
                        }
                        $xfer += $input->readListEnd();
                      }
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^4$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{returnUrl});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueRequestTokenWithAuthScheme_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{otpId}) {
                  $xfer += $output->writeFieldBegin('otpId', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{otpId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{authScheme}) {
                  $xfer += $output->writeFieldBegin('authScheme', Thrift::TType::LIST, 3);
                  {
                    $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{authScheme}}));
                    {
                      foreach my $iter1284 (@{$self->{authScheme}}) 
                      {
                        $xfer += $output->writeString($iter1284);
                      }
                    }
                    $xfer += $output->writeListEnd();
                  }
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{returnUrl}) {
                  $xfer += $output->writeFieldBegin('returnUrl', Thrift::TType::STRING, 4);
                  $xfer += $output->writeString($self->{returnUrl});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueRequestTokenWithAuthScheme_result;
use base qw(Class::Accessor);
ChannelService_issueRequestTokenWithAuthScheme_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueRequestTokenWithAuthScheme_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = RequestTokenResponse->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueRequestTokenWithAuthScheme_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueRequestTokenForAutoLogin_args;
use base qw(Class::Accessor);
ChannelService_issueRequestTokenForAutoLogin_args->mk_accessors( qw( channelId otpId redirectUrl ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                $self->{otpId} = undef;
                $self->{redirectUrl} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                  if (defined $vals->{otpId}) {
                    $self->{otpId} = $vals->{otpId};
                  }
                  if (defined $vals->{redirectUrl}) {
                    $self->{redirectUrl} = $vals->{redirectUrl};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueRequestTokenForAutoLogin_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{otpId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^4$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{redirectUrl});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueRequestTokenForAutoLogin_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{otpId}) {
                  $xfer += $output->writeFieldBegin('otpId', Thrift::TType::STRING, 3);
                  $xfer += $output->writeString($self->{otpId});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{redirectUrl}) {
                  $xfer += $output->writeFieldBegin('redirectUrl', Thrift::TType::STRING, 4);
                  $xfer += $output->writeString($self->{redirectUrl});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_issueRequestTokenForAutoLogin_result;
use base qw(Class::Accessor);
ChannelService_issueRequestTokenForAutoLogin_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_issueRequestTokenForAutoLogin_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_issueRequestTokenForAutoLogin_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                  $xfer += $output->writeString($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getUpdatedChannelIds_args;
use base qw(Class::Accessor);
ChannelService_getUpdatedChannelIds_args->mk_accessors( qw( channelIds ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelIds} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelIds}) {
                    $self->{channelIds} = $vals->{channelIds};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getUpdatedChannelIds_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::LIST) {
                      {
                        my $_size1285 = 0;
                        $self->{channelIds} = [];
                        my $_etype1288 = 0;
                        $xfer += $input->readListBegin(\$_etype1288, \$_size1285);
                        for (my $_i1289 = 0; $_i1289 < $_size1285; ++$_i1289)
                        {
                          my $elem1290 = undef;
                          $elem1290 = ChannelIdWithLastUpdated->new();
                          $xfer += $elem1290->read($input);
                          push(@{$self->{channelIds}},$elem1290);
                        }
                        $xfer += $input->readListEnd();
                      }
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getUpdatedChannelIds_args');
                if (defined $self->{channelIds}) {
                  $xfer += $output->writeFieldBegin('channelIds', Thrift::TType::LIST, 1);
                  {
                    $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{channelIds}}));
                    {
                      foreach my $iter1291 (@{$self->{channelIds}}) 
                      {
                        $xfer += ${iter1291}->write($output);
                      }
                    }
                    $xfer += $output->writeListEnd();
                  }
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_getUpdatedChannelIds_result;
use base qw(Class::Accessor);
ChannelService_getUpdatedChannelIds_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_getUpdatedChannelIds_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::LIST) {
                      {
                        my $_size1292 = 0;
                        $self->{success} = [];
                        my $_etype1295 = 0;
                        $xfer += $input->readListBegin(\$_etype1295, \$_size1292);
                        for (my $_i1296 = 0; $_i1296 < $_size1292; ++$_i1296)
                        {
                          my $elem1297 = undef;
                          $xfer += $input->readString(\$elem1297);
                          push(@{$self->{success}},$elem1297);
                        }
                        $xfer += $input->readListEnd();
                      }
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_getUpdatedChannelIds_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                  {
                    $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                    {
                      foreach my $iter1298 (@{$self->{success}}) 
                      {
                        $xfer += $output->writeString($iter1298);
                      }
                    }
                    $xfer += $output->writeListEnd();
                  }
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_reserveCoinUse_args;
use base qw(Class::Accessor);
ChannelService_reserveCoinUse_args->mk_accessors( qw( request locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{request} = undef;
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{request}) {
                    $self->{request} = $vals->{request};
                  }
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_reserveCoinUse_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{request} = CoinUseReservation->new();
                      $xfer += $self->{request}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_reserveCoinUse_args');
                if (defined $self->{request}) {
                  $xfer += $output->writeFieldBegin('request', Thrift::TType::STRUCT, 2);
                  $xfer += $self->{request}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 3);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_reserveCoinUse_result;
use base qw(Class::Accessor);
ChannelService_reserveCoinUse_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_reserveCoinUse_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_reserveCoinUse_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                  $xfer += $output->writeString($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_revokeChannel_args;
use base qw(Class::Accessor);
ChannelService_revokeChannel_args->mk_accessors( qw( channelId ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{channelId} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{channelId}) {
                    $self->{channelId} = $vals->{channelId};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_revokeChannel_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{channelId});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_revokeChannel_args');
                if (defined $self->{channelId}) {
                  $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 1);
                  $xfer += $output->writeString($self->{channelId});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_revokeChannel_result;
use base qw(Class::Accessor);
ChannelService_revokeChannel_result->mk_accessors( qw( ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_revokeChannel_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_revokeChannel_result');
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_syncChannelData_args;
use base qw(Class::Accessor);
ChannelService_syncChannelData_args->mk_accessors( qw( lastSynced locale ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{lastSynced} = undef;
                $self->{locale} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{lastSynced}) {
                    $self->{lastSynced} = $vals->{lastSynced};
                  }
                  if (defined $vals->{locale}) {
                    $self->{locale} = $vals->{locale};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_syncChannelData_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^2$/ && do{                    if ($ftype == Thrift::TType::I64) {
                      $xfer += $input->readI64(\$self->{lastSynced});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^3$/ && do{                    if ($ftype == Thrift::TType::STRING) {
                      $xfer += $input->readString(\$self->{locale});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_syncChannelData_args');
                if (defined $self->{lastSynced}) {
                  $xfer += $output->writeFieldBegin('lastSynced', Thrift::TType::I64, 2);
                  $xfer += $output->writeI64($self->{lastSynced});
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{locale}) {
                  $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 3);
                  $xfer += $output->writeString($self->{locale});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_syncChannelData_result;
use base qw(Class::Accessor);
ChannelService_syncChannelData_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_syncChannelData_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{success} = ChannelSyncDatas->new();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_syncChannelData_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_updateChannelNotificationSetting_args;
use base qw(Class::Accessor);
ChannelService_updateChannelNotificationSetting_args->mk_accessors( qw( setting ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{setting} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{setting}) {
                    $self->{setting} = $vals->{setting};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_updateChannelNotificationSetting_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::LIST) {
                      {
                        my $_size1299 = 0;
                        $self->{setting} = [];
                        my $_etype1302 = 0;
                        $xfer += $input->readListBegin(\$_etype1302, \$_size1299);
                        for (my $_i1303 = 0; $_i1303 < $_size1299; ++$_i1303)
                        {
                          my $elem1304 = undef;
                          $elem1304 = ChannelNotificationSetting->new();
                          $xfer += $elem1304->read($input);
                          push(@{$self->{setting}},$elem1304);
                        }
                        $xfer += $input->readListEnd();
                      }
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_updateChannelNotificationSetting_args');
                if (defined $self->{setting}) {
                  $xfer += $output->writeFieldBegin('setting', Thrift::TType::LIST, 1);
                  {
                    $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{setting}}));
                    {
                      foreach my $iter1305 (@{$self->{setting}}) 
                      {
                        $xfer += ${iter1305}->write($output);
                      }
                    }
                    $xfer += $output->writeListEnd();
                  }
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelService_updateChannelNotificationSetting_result;
use base qw(Class::Accessor);
ChannelService_updateChannelNotificationSetting_result->mk_accessors( qw( ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{e} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{e}) {
                    $self->{e} = $vals->{e};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'ChannelService_updateChannelNotificationSetting_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1)
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == Thrift::TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == Thrift::TType::STRUCT) {
                      $self->{e} = ChannelException->new();
                      $xfer += $self->{e}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('ChannelService_updateChannelNotificationSetting_result');
                if (defined $self->{e}) {
                  $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                  $xfer += $self->{e}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package ChannelServiceIf;

use strict;


sub issueOTP{
  my $self = shift;
  my $channelId = shift;

  die 'implement interface';
}

sub approveChannelAndIssueChannelToken{
  my $self = shift;
  my $channelId = shift;

  die 'implement interface';
}

sub approveChannelAndIssueRequestToken{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;

  die 'implement interface';
}

sub fetchNotificationItems{
  my $self = shift;
  my $localRev = shift;

  die 'implement interface';
}

sub getApprovedChannels{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

  die 'implement interface';
}

sub getChannelInfo{
  my $self = shift;
  my $channelId = shift;
  my $locale = shift;

  die 'implement interface';
}

sub getChannelNotificationSetting{
  my $self = shift;
  my $channelId = shift;
  my $locale = shift;

  die 'implement interface';
}

sub getChannelNotificationSettings{
  my $self = shift;
  my $locale = shift;

  die 'implement interface';
}

sub getChannels{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

  die 'implement interface';
}

sub getDomains{
  my $self = shift;
  my $lastSynced = shift;

  die 'implement interface';
}

sub getFriendChannelMatrices{
  my $self = shift;
  my $channelIds = shift;

  die 'implement interface';
}

sub updateChannelSettings{
  my $self = shift;
  my $channelSettings = shift;

  die 'implement interface';
}

sub getCommonDomains{
  my $self = shift;
  my $lastSynced = shift;

  die 'implement interface';
}

sub getNotificationBadgeCount{
  my $self = shift;
  my $localRev = shift;

  die 'implement interface';
}

sub issueChannelToken{
  my $self = shift;
  my $channelId = shift;

  die 'implement interface';
}

sub issueRequestToken{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;

  die 'implement interface';
}

sub issueRequestTokenWithAuthScheme{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;
  my $authScheme = shift;
  my $returnUrl = shift;

  die 'implement interface';
}

sub issueRequestTokenForAutoLogin{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;
  my $redirectUrl = shift;

  die 'implement interface';
}

sub getUpdatedChannelIds{
  my $self = shift;
  my $channelIds = shift;

  die 'implement interface';
}

sub reserveCoinUse{
  my $self = shift;
  my $request = shift;
  my $locale = shift;

  die 'implement interface';
}

sub revokeChannel{
  my $self = shift;
  my $channelId = shift;

  die 'implement interface';
}

sub syncChannelData{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

  die 'implement interface';
}

sub updateChannelNotificationSetting{
  my $self = shift;
  my $setting = shift;

  die 'implement interface';
}

package ChannelServiceRest;

use strict;


sub new {
                my ($classname, $impl) = @_;
                my $self     ={ impl => $impl };

                return bless($self,$classname);
}

sub issueOTP{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                return $self->{impl}->issueOTP($channelId);
              }

sub approveChannelAndIssueChannelToken{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                return $self->{impl}->approveChannelAndIssueChannelToken($channelId);
              }

sub approveChannelAndIssueRequestToken{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                my $otpId = ($request->{'otpId'}) ? $request->{'otpId'} : undef;
                return $self->{impl}->approveChannelAndIssueRequestToken($channelId, $otpId);
              }

sub fetchNotificationItems{
                my ($self, $request) = @_;

                my $localRev = ($request->{'localRev'}) ? $request->{'localRev'} : undef;
                return $self->{impl}->fetchNotificationItems($localRev);
              }

sub getApprovedChannels{
                my ($self, $request) = @_;

                my $lastSynced = ($request->{'lastSynced'}) ? $request->{'lastSynced'} : undef;
                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->getApprovedChannels($lastSynced, $locale);
              }

sub getChannelInfo{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->getChannelInfo($channelId, $locale);
              }

sub getChannelNotificationSetting{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->getChannelNotificationSetting($channelId, $locale);
              }

sub getChannelNotificationSettings{
                my ($self, $request) = @_;

                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->getChannelNotificationSettings($locale);
              }

sub getChannels{
                my ($self, $request) = @_;

                my $lastSynced = ($request->{'lastSynced'}) ? $request->{'lastSynced'} : undef;
                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->getChannels($lastSynced, $locale);
              }

sub getDomains{
                my ($self, $request) = @_;

                my $lastSynced = ($request->{'lastSynced'}) ? $request->{'lastSynced'} : undef;
                return $self->{impl}->getDomains($lastSynced);
              }

sub getFriendChannelMatrices{
                my ($self, $request) = @_;

                my $channelIds = ($request->{'channelIds'}) ? $request->{'channelIds'} : undef;
                return $self->{impl}->getFriendChannelMatrices($channelIds);
              }

sub updateChannelSettings{
                my ($self, $request) = @_;

                my $channelSettings = ($request->{'channelSettings'}) ? $request->{'channelSettings'} : undef;
                return $self->{impl}->updateChannelSettings($channelSettings);
              }

sub getCommonDomains{
                my ($self, $request) = @_;

                my $lastSynced = ($request->{'lastSynced'}) ? $request->{'lastSynced'} : undef;
                return $self->{impl}->getCommonDomains($lastSynced);
              }

sub getNotificationBadgeCount{
                my ($self, $request) = @_;

                my $localRev = ($request->{'localRev'}) ? $request->{'localRev'} : undef;
                return $self->{impl}->getNotificationBadgeCount($localRev);
              }

sub issueChannelToken{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                return $self->{impl}->issueChannelToken($channelId);
              }

sub issueRequestToken{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                my $otpId = ($request->{'otpId'}) ? $request->{'otpId'} : undef;
                return $self->{impl}->issueRequestToken($channelId, $otpId);
              }

sub issueRequestTokenWithAuthScheme{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                my $otpId = ($request->{'otpId'}) ? $request->{'otpId'} : undef;
                my $authScheme = ($request->{'authScheme'}) ? $request->{'authScheme'} : undef;
                my $returnUrl = ($request->{'returnUrl'}) ? $request->{'returnUrl'} : undef;
                return $self->{impl}->issueRequestTokenWithAuthScheme($channelId, $otpId, $authScheme, $returnUrl);
              }

sub issueRequestTokenForAutoLogin{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                my $otpId = ($request->{'otpId'}) ? $request->{'otpId'} : undef;
                my $redirectUrl = ($request->{'redirectUrl'}) ? $request->{'redirectUrl'} : undef;
                return $self->{impl}->issueRequestTokenForAutoLogin($channelId, $otpId, $redirectUrl);
              }

sub getUpdatedChannelIds{
                my ($self, $request) = @_;

                my $channelIds = ($request->{'channelIds'}) ? $request->{'channelIds'} : undef;
                return $self->{impl}->getUpdatedChannelIds($channelIds);
              }

sub reserveCoinUse{
                my ($self, $request) = @_;

                my $request = ($request->{'request'}) ? $request->{'request'} : undef;
                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->reserveCoinUse($request, $locale);
              }

sub revokeChannel{
                my ($self, $request) = @_;

                my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                return $self->{impl}->revokeChannel($channelId);
              }

sub syncChannelData{
                my ($self, $request) = @_;

                my $lastSynced = ($request->{'lastSynced'}) ? $request->{'lastSynced'} : undef;
                my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                return $self->{impl}->syncChannelData($lastSynced, $locale);
              }

sub updateChannelNotificationSetting{
                my ($self, $request) = @_;

                my $setting = ($request->{'setting'}) ? $request->{'setting'} : undef;
                return $self->{impl}->updateChannelNotificationSetting($setting);
              }

package ChannelServiceClient;


use base qw(ChannelServiceIf);
sub new {
                my ($classname, $input, $output) = @_;
                my $self      = {};
                $self->{input}  = $input;
                $self->{output} = defined $output ? $output : $input;
                $self->{seqid}  = 0;
                return bless($self,$classname);
}

sub issueOTP{
  my $self = shift;
  my $channelId = shift;

                                $self->send_issueOTP($channelId);
                return $self->recv_issueOTP();
}

sub send_issueOTP{
  my $self = shift;
  my $channelId = shift;

                $self->{output}->writeMessageBegin('issueOTP', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_issueOTP_args->new();
                $args->{channelId} = $channelId;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_issueOTP{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_issueOTP_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "issueOTP failed: unknown result";
}
sub approveChannelAndIssueChannelToken{
  my $self = shift;
  my $channelId = shift;

                                $self->send_approveChannelAndIssueChannelToken($channelId);
                return $self->recv_approveChannelAndIssueChannelToken();
}

sub send_approveChannelAndIssueChannelToken{
  my $self = shift;
  my $channelId = shift;

                $self->{output}->writeMessageBegin('approveChannelAndIssueChannelToken', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_approveChannelAndIssueChannelToken_args->new();
                $args->{channelId} = $channelId;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_approveChannelAndIssueChannelToken{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_approveChannelAndIssueChannelToken_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "approveChannelAndIssueChannelToken failed: unknown result";
}
sub approveChannelAndIssueRequestToken{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;

                                $self->send_approveChannelAndIssueRequestToken($channelId, $otpId);
                return $self->recv_approveChannelAndIssueRequestToken();
}

sub send_approveChannelAndIssueRequestToken{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;

                $self->{output}->writeMessageBegin('approveChannelAndIssueRequestToken', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_approveChannelAndIssueRequestToken_args->new();
                $args->{channelId} = $channelId;
                $args->{otpId} = $otpId;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_approveChannelAndIssueRequestToken{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_approveChannelAndIssueRequestToken_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "approveChannelAndIssueRequestToken failed: unknown result";
}
sub fetchNotificationItems{
  my $self = shift;
  my $localRev = shift;

                                $self->send_fetchNotificationItems($localRev);
                return $self->recv_fetchNotificationItems();
}

sub send_fetchNotificationItems{
  my $self = shift;
  my $localRev = shift;

                $self->{output}->writeMessageBegin('fetchNotificationItems', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_fetchNotificationItems_args->new();
                $args->{localRev} = $localRev;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_fetchNotificationItems{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_fetchNotificationItems_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "fetchNotificationItems failed: unknown result";
}
sub getApprovedChannels{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

                                $self->send_getApprovedChannels($lastSynced, $locale);
                return $self->recv_getApprovedChannels();
}

sub send_getApprovedChannels{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('getApprovedChannels', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getApprovedChannels_args->new();
                $args->{lastSynced} = $lastSynced;
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getApprovedChannels{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getApprovedChannels_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getApprovedChannels failed: unknown result";
}
sub getChannelInfo{
  my $self = shift;
  my $channelId = shift;
  my $locale = shift;

                                $self->send_getChannelInfo($channelId, $locale);
                return $self->recv_getChannelInfo();
}

sub send_getChannelInfo{
  my $self = shift;
  my $channelId = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('getChannelInfo', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getChannelInfo_args->new();
                $args->{channelId} = $channelId;
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getChannelInfo{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getChannelInfo_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getChannelInfo failed: unknown result";
}
sub getChannelNotificationSetting{
  my $self = shift;
  my $channelId = shift;
  my $locale = shift;

                                $self->send_getChannelNotificationSetting($channelId, $locale);
                return $self->recv_getChannelNotificationSetting();
}

sub send_getChannelNotificationSetting{
  my $self = shift;
  my $channelId = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('getChannelNotificationSetting', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getChannelNotificationSetting_args->new();
                $args->{channelId} = $channelId;
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getChannelNotificationSetting{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getChannelNotificationSetting_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getChannelNotificationSetting failed: unknown result";
}
sub getChannelNotificationSettings{
  my $self = shift;
  my $locale = shift;

                                $self->send_getChannelNotificationSettings($locale);
                return $self->recv_getChannelNotificationSettings();
}

sub send_getChannelNotificationSettings{
  my $self = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('getChannelNotificationSettings', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getChannelNotificationSettings_args->new();
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getChannelNotificationSettings{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getChannelNotificationSettings_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getChannelNotificationSettings failed: unknown result";
}
sub getChannels{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

                                $self->send_getChannels($lastSynced, $locale);
                return $self->recv_getChannels();
}

sub send_getChannels{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('getChannels', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getChannels_args->new();
                $args->{lastSynced} = $lastSynced;
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getChannels{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getChannels_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getChannels failed: unknown result";
}
sub getDomains{
  my $self = shift;
  my $lastSynced = shift;

                                $self->send_getDomains($lastSynced);
                return $self->recv_getDomains();
}

sub send_getDomains{
  my $self = shift;
  my $lastSynced = shift;

                $self->{output}->writeMessageBegin('getDomains', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getDomains_args->new();
                $args->{lastSynced} = $lastSynced;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getDomains{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getDomains_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getDomains failed: unknown result";
}
sub getFriendChannelMatrices{
  my $self = shift;
  my $channelIds = shift;

                                $self->send_getFriendChannelMatrices($channelIds);
                return $self->recv_getFriendChannelMatrices();
}

sub send_getFriendChannelMatrices{
  my $self = shift;
  my $channelIds = shift;

                $self->{output}->writeMessageBegin('getFriendChannelMatrices', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getFriendChannelMatrices_args->new();
                $args->{channelIds} = $channelIds;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getFriendChannelMatrices{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getFriendChannelMatrices_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getFriendChannelMatrices failed: unknown result";
}
sub updateChannelSettings{
  my $self = shift;
  my $channelSettings = shift;

                                $self->send_updateChannelSettings($channelSettings);
                return $self->recv_updateChannelSettings();
}

sub send_updateChannelSettings{
  my $self = shift;
  my $channelSettings = shift;

                $self->{output}->writeMessageBegin('updateChannelSettings', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_updateChannelSettings_args->new();
                $args->{channelSettings} = $channelSettings;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_updateChannelSettings{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_updateChannelSettings_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "updateChannelSettings failed: unknown result";
}
sub getCommonDomains{
  my $self = shift;
  my $lastSynced = shift;

                                $self->send_getCommonDomains($lastSynced);
                return $self->recv_getCommonDomains();
}

sub send_getCommonDomains{
  my $self = shift;
  my $lastSynced = shift;

                $self->{output}->writeMessageBegin('getCommonDomains', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getCommonDomains_args->new();
                $args->{lastSynced} = $lastSynced;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getCommonDomains{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getCommonDomains_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getCommonDomains failed: unknown result";
}
sub getNotificationBadgeCount{
  my $self = shift;
  my $localRev = shift;

                                $self->send_getNotificationBadgeCount($localRev);
                return $self->recv_getNotificationBadgeCount();
}

sub send_getNotificationBadgeCount{
  my $self = shift;
  my $localRev = shift;

                $self->{output}->writeMessageBegin('getNotificationBadgeCount', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getNotificationBadgeCount_args->new();
                $args->{localRev} = $localRev;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getNotificationBadgeCount{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getNotificationBadgeCount_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getNotificationBadgeCount failed: unknown result";
}
sub issueChannelToken{
  my $self = shift;
  my $channelId = shift;

                                $self->send_issueChannelToken($channelId);
                return $self->recv_issueChannelToken();
}

sub send_issueChannelToken{
  my $self = shift;
  my $channelId = shift;

                $self->{output}->writeMessageBegin('issueChannelToken', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_issueChannelToken_args->new();
                $args->{channelId} = $channelId;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_issueChannelToken{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_issueChannelToken_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "issueChannelToken failed: unknown result";
}
sub issueRequestToken{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;

                                $self->send_issueRequestToken($channelId, $otpId);
                return $self->recv_issueRequestToken();
}

sub send_issueRequestToken{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;

                $self->{output}->writeMessageBegin('issueRequestToken', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_issueRequestToken_args->new();
                $args->{channelId} = $channelId;
                $args->{otpId} = $otpId;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_issueRequestToken{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_issueRequestToken_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "issueRequestToken failed: unknown result";
}
sub issueRequestTokenWithAuthScheme{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;
  my $authScheme = shift;
  my $returnUrl = shift;

                                $self->send_issueRequestTokenWithAuthScheme($channelId, $otpId, $authScheme, $returnUrl);
                return $self->recv_issueRequestTokenWithAuthScheme();
}

sub send_issueRequestTokenWithAuthScheme{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;
  my $authScheme = shift;
  my $returnUrl = shift;

                $self->{output}->writeMessageBegin('issueRequestTokenWithAuthScheme', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_issueRequestTokenWithAuthScheme_args->new();
                $args->{channelId} = $channelId;
                $args->{otpId} = $otpId;
                $args->{authScheme} = $authScheme;
                $args->{returnUrl} = $returnUrl;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_issueRequestTokenWithAuthScheme{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_issueRequestTokenWithAuthScheme_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "issueRequestTokenWithAuthScheme failed: unknown result";
}
sub issueRequestTokenForAutoLogin{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;
  my $redirectUrl = shift;

                                $self->send_issueRequestTokenForAutoLogin($channelId, $otpId, $redirectUrl);
                return $self->recv_issueRequestTokenForAutoLogin();
}

sub send_issueRequestTokenForAutoLogin{
  my $self = shift;
  my $channelId = shift;
  my $otpId = shift;
  my $redirectUrl = shift;

                $self->{output}->writeMessageBegin('issueRequestTokenForAutoLogin', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_issueRequestTokenForAutoLogin_args->new();
                $args->{channelId} = $channelId;
                $args->{otpId} = $otpId;
                $args->{redirectUrl} = $redirectUrl;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_issueRequestTokenForAutoLogin{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_issueRequestTokenForAutoLogin_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "issueRequestTokenForAutoLogin failed: unknown result";
}
sub getUpdatedChannelIds{
  my $self = shift;
  my $channelIds = shift;

                                $self->send_getUpdatedChannelIds($channelIds);
                return $self->recv_getUpdatedChannelIds();
}

sub send_getUpdatedChannelIds{
  my $self = shift;
  my $channelIds = shift;

                $self->{output}->writeMessageBegin('getUpdatedChannelIds', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_getUpdatedChannelIds_args->new();
                $args->{channelIds} = $channelIds;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getUpdatedChannelIds{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_getUpdatedChannelIds_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "getUpdatedChannelIds failed: unknown result";
}
sub reserveCoinUse{
  my $self = shift;
  my $request = shift;
  my $locale = shift;

                                $self->send_reserveCoinUse($request, $locale);
                return $self->recv_reserveCoinUse();
}

sub send_reserveCoinUse{
  my $self = shift;
  my $request = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('reserveCoinUse', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_reserveCoinUse_args->new();
                $args->{request} = $request;
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_reserveCoinUse{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_reserveCoinUse_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "reserveCoinUse failed: unknown result";
}
sub revokeChannel{
  my $self = shift;
  my $channelId = shift;

                                $self->send_revokeChannel($channelId);
                $self->recv_revokeChannel();
}

sub send_revokeChannel{
  my $self = shift;
  my $channelId = shift;

                $self->{output}->writeMessageBegin('revokeChannel', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_revokeChannel_args->new();
                $args->{channelId} = $channelId;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_revokeChannel{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_revokeChannel_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{e}) {
                  die $result->{e};
                }
                return;
}
sub syncChannelData{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

                                $self->send_syncChannelData($lastSynced, $locale);
                return $self->recv_syncChannelData();
}

sub send_syncChannelData{
  my $self = shift;
  my $lastSynced = shift;
  my $locale = shift;

                $self->{output}->writeMessageBegin('syncChannelData', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_syncChannelData_args->new();
                $args->{lastSynced} = $lastSynced;
                $args->{locale} = $locale;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_syncChannelData{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_syncChannelData_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                if (defined $result->{e}) {
                  die $result->{e};
                }
                die "syncChannelData failed: unknown result";
}
sub updateChannelNotificationSetting{
  my $self = shift;
  my $setting = shift;

                                $self->send_updateChannelNotificationSetting($setting);
                $self->recv_updateChannelNotificationSetting();
}

sub send_updateChannelNotificationSetting{
  my $self = shift;
  my $setting = shift;

                $self->{output}->writeMessageBegin('updateChannelNotificationSetting', Thrift::TMessageType::CALL, $self->{seqid});
                my $args = ChannelService_updateChannelNotificationSetting_args->new();
                $args->{setting} = $setting;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_updateChannelNotificationSetting{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == Thrift::TMessageType::EXCEPTION) {
                  my $x = Thrift::TApplicationException->new();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = ChannelService_updateChannelNotificationSetting_result->new();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{e}) {
                  die $result->{e};
                }
                return;
}
package ChannelServiceProcessor;

use strict;


sub new {
                  my ($classname, $handler) = @_;
                  my $self      = {};
                  $self->{handler} = $handler;
                  return bless ($self, $classname);
}

sub process {
                  my ($self, $input, $output) = @_;
                  my $rseqid = 0;
                  my $fname  = undef;
                  my $mtype  = 0;

                  $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                  my $methodname = 'process_'.$fname;
                  if (!$self->can($methodname)) {
                    $input->skip(Thrift::TType::STRUCT);
                    $input->readMessageEnd();
                    my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
                    $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
                    $x->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    return;
                  }
                  $self->$methodname($rseqid, $input, $output);
                  return 1;
}

sub process_issueOTP {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_issueOTP_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_issueOTP_result->new();
                  eval {
                    $result->{success} = $self->{handler}->issueOTP($args->channelId);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('issueOTP', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('issueOTP', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_approveChannelAndIssueChannelToken {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_approveChannelAndIssueChannelToken_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_approveChannelAndIssueChannelToken_result->new();
                  eval {
                    $result->{success} = $self->{handler}->approveChannelAndIssueChannelToken($args->channelId);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('approveChannelAndIssueChannelToken', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('approveChannelAndIssueChannelToken', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_approveChannelAndIssueRequestToken {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_approveChannelAndIssueRequestToken_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_approveChannelAndIssueRequestToken_result->new();
                  eval {
                    $result->{success} = $self->{handler}->approveChannelAndIssueRequestToken($args->channelId, $args->otpId);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('approveChannelAndIssueRequestToken', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('approveChannelAndIssueRequestToken', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_fetchNotificationItems {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_fetchNotificationItems_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_fetchNotificationItems_result->new();
                  eval {
                    $result->{success} = $self->{handler}->fetchNotificationItems($args->localRev);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('fetchNotificationItems', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('fetchNotificationItems', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getApprovedChannels {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getApprovedChannels_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getApprovedChannels_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getApprovedChannels($args->lastSynced, $args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getApprovedChannels', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getApprovedChannels', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getChannelInfo {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getChannelInfo_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getChannelInfo_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getChannelInfo($args->channelId, $args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getChannelInfo', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getChannelInfo', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getChannelNotificationSetting {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getChannelNotificationSetting_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getChannelNotificationSetting_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getChannelNotificationSetting($args->channelId, $args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getChannelNotificationSetting', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getChannelNotificationSetting', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getChannelNotificationSettings {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getChannelNotificationSettings_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getChannelNotificationSettings_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getChannelNotificationSettings($args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getChannelNotificationSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getChannelNotificationSettings', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getChannels {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getChannels_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getChannels_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getChannels($args->lastSynced, $args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getChannels', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getChannels', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getDomains {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getDomains_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getDomains_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getDomains($args->lastSynced);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getDomains', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getDomains', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getFriendChannelMatrices {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getFriendChannelMatrices_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getFriendChannelMatrices_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getFriendChannelMatrices($args->channelIds);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getFriendChannelMatrices', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getFriendChannelMatrices', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_updateChannelSettings {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_updateChannelSettings_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_updateChannelSettings_result->new();
                  eval {
                    $result->{success} = $self->{handler}->updateChannelSettings($args->channelSettings);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('updateChannelSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('updateChannelSettings', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getCommonDomains {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getCommonDomains_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getCommonDomains_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getCommonDomains($args->lastSynced);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getCommonDomains', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getCommonDomains', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getNotificationBadgeCount {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getNotificationBadgeCount_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getNotificationBadgeCount_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getNotificationBadgeCount($args->localRev);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getNotificationBadgeCount', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getNotificationBadgeCount', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_issueChannelToken {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_issueChannelToken_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_issueChannelToken_result->new();
                  eval {
                    $result->{success} = $self->{handler}->issueChannelToken($args->channelId);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('issueChannelToken', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('issueChannelToken', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_issueRequestToken {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_issueRequestToken_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_issueRequestToken_result->new();
                  eval {
                    $result->{success} = $self->{handler}->issueRequestToken($args->channelId, $args->otpId);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('issueRequestToken', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('issueRequestToken', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_issueRequestTokenWithAuthScheme {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_issueRequestTokenWithAuthScheme_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_issueRequestTokenWithAuthScheme_result->new();
                  eval {
                    $result->{success} = $self->{handler}->issueRequestTokenWithAuthScheme($args->channelId, $args->otpId, $args->authScheme, $args->returnUrl);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('issueRequestTokenWithAuthScheme', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('issueRequestTokenWithAuthScheme', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_issueRequestTokenForAutoLogin {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_issueRequestTokenForAutoLogin_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_issueRequestTokenForAutoLogin_result->new();
                  eval {
                    $result->{success} = $self->{handler}->issueRequestTokenForAutoLogin($args->channelId, $args->otpId, $args->redirectUrl);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('issueRequestTokenForAutoLogin', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('issueRequestTokenForAutoLogin', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getUpdatedChannelIds {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_getUpdatedChannelIds_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_getUpdatedChannelIds_result->new();
                  eval {
                    $result->{success} = $self->{handler}->getUpdatedChannelIds($args->channelIds);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('getUpdatedChannelIds', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('getUpdatedChannelIds', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_reserveCoinUse {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_reserveCoinUse_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_reserveCoinUse_result->new();
                  eval {
                    $result->{success} = $self->{handler}->reserveCoinUse($args->request, $args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('reserveCoinUse', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('reserveCoinUse', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_revokeChannel {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_revokeChannel_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_revokeChannel_result->new();
                  eval {
                    $self->{handler}->revokeChannel($args->channelId);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('revokeChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('revokeChannel', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_syncChannelData {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_syncChannelData_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_syncChannelData_result->new();
                  eval {
                    $result->{success} = $self->{handler}->syncChannelData($args->lastSynced, $args->locale);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('syncChannelData', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('syncChannelData', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_updateChannelNotificationSetting {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = ChannelService_updateChannelNotificationSetting_args->new();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = ChannelService_updateChannelNotificationSetting_result->new();
                  eval {
                    $self->{handler}->updateChannelNotificationSetting($args->setting);
                  }; if( UNIVERSAL::isa($@,'ChannelException') ){ 
                    $result->{e} = $@;
                    $@ = undef;
                  }
                  if ($@) {
                    $@ =~ s/^\s+|\s+$//g;
                    my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                    $output->writeMessageBegin('updateChannelNotificationSetting', Thrift::TMessageType::EXCEPTION, $seqid);
                    $err->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    $@ = undef;
                    return;
                  }
                  $output->writeMessageBegin('updateChannelNotificationSetting', Thrift::TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

1;
