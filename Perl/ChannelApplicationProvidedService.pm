#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Types;


# HELPER FUNCTIONS AND STRUCTURES

package ChannelApplicationProvidedService_activeBuddySubscriberCount_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_activeBuddySubscriberCount_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_activeBuddySubscriberCount_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_activeBuddySubscriberCount_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_activeBuddySubscriberCount_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_activeBuddySubscriberCount_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::I64) {
                    $xfer += $input->readI64(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_activeBuddySubscriberCount_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
                $xfer += $output->writeI64($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_addOperationForChannel_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_addOperationForChannel_args->mk_accessors( qw( opType param1 param2 param3 ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{opType} = undef;
              $self->{param1} = undef;
              $self->{param2} = undef;
              $self->{param3} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{opType}) {
                  $self->{opType} = $vals->{opType};
                }
                if (defined $vals->{param1}) {
                  $self->{param1} = $vals->{param1};
                }
                if (defined $vals->{param2}) {
                  $self->{param2} = $vals->{param2};
                }
                if (defined $vals->{param3}) {
                  $self->{param3} = $vals->{param3};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_addOperationForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::I32) {
                    $xfer += $input->readI32(\$self->{opType});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{param1});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^3$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{param2});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^4$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{param3});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_addOperationForChannel_args');
              if (defined $self->{opType}) {
                $xfer += $output->writeFieldBegin('opType', Thrift::TType::I32, 1);
                $xfer += $output->writeI32($self->{opType});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{param1}) {
                $xfer += $output->writeFieldBegin('param1', Thrift::TType::STRING, 2);
                $xfer += $output->writeString($self->{param1});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{param2}) {
                $xfer += $output->writeFieldBegin('param2', Thrift::TType::STRING, 3);
                $xfer += $output->writeString($self->{param2});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{param3}) {
                $xfer += $output->writeFieldBegin('param3', Thrift::TType::STRING, 4);
                $xfer += $output->writeString($self->{param3});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_addOperationForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_addOperationForChannel_result->mk_accessors( qw( ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_addOperationForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_addOperationForChannel_result');
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_displayBuddySubscriberCount_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_displayBuddySubscriberCount_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_displayBuddySubscriberCount_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_displayBuddySubscriberCount_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_displayBuddySubscriberCount_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_displayBuddySubscriberCount_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::I64) {
                    $xfer += $input->readI64(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_displayBuddySubscriberCount_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
                $xfer += $output->writeI64($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args->mk_accessors( qw( userid ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{userid} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{userid}) {
                  $self->{userid} = $vals->{userid};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{userid});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args');
              if (defined $self->{userid}) {
                $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                $xfer += $output->writeString($self->{userid});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{success} = Contact->new();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getAllContactIdsForChannel_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getAllContactIdsForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getAllContactIdsForChannel_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getAllContactIdsForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getAllContactIdsForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getAllContactIdsForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1164 = 0;
                      $self->{success} = [];
                      my $_etype1167 = 0;
                      $xfer += $input->readListBegin(\$_etype1167, \$_size1164);
                      for (my $_i1168 = 0; $_i1168 < $_size1164; ++$_i1168)
                      {
                        my $elem1169 = undef;
                        $xfer += $input->readString(\$elem1169);
                        push(@{$self->{success}},$elem1169);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getAllContactIdsForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1170 (@{$self->{success}}) 
                    {
                      $xfer += $output->writeString($iter1170);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getCompactContacts_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getCompactContacts_args->mk_accessors( qw( lastModifiedTimestamp ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{lastModifiedTimestamp} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{lastModifiedTimestamp}) {
                  $self->{lastModifiedTimestamp} = $vals->{lastModifiedTimestamp};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getCompactContacts_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::I64) {
                    $xfer += $input->readI64(\$self->{lastModifiedTimestamp});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getCompactContacts_args');
              if (defined $self->{lastModifiedTimestamp}) {
                $xfer += $output->writeFieldBegin('lastModifiedTimestamp', Thrift::TType::I64, 2);
                $xfer += $output->writeI64($self->{lastModifiedTimestamp});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getCompactContacts_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getCompactContacts_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getCompactContacts_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1171 = 0;
                      $self->{success} = [];
                      my $_etype1174 = 0;
                      $xfer += $input->readListBegin(\$_etype1174, \$_size1171);
                      for (my $_i1175 = 0; $_i1175 < $_size1171; ++$_i1175)
                      {
                        my $elem1176 = undef;
                        $elem1176 = CompactContact->new();
                        $xfer += $elem1176->read($input);
                        push(@{$self->{success}},$elem1176);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getCompactContacts_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1177 (@{$self->{success}}) 
                    {
                      $xfer += ${iter1177}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getContactsForChannel_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getContactsForChannel_args->mk_accessors( qw( ids ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{ids} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{ids}) {
                  $self->{ids} = $vals->{ids};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getContactsForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1178 = 0;
                      $self->{ids} = [];
                      my $_etype1181 = 0;
                      $xfer += $input->readListBegin(\$_etype1181, \$_size1178);
                      for (my $_i1182 = 0; $_i1182 < $_size1178; ++$_i1182)
                      {
                        my $elem1183 = undef;
                        $xfer += $input->readString(\$elem1183);
                        push(@{$self->{ids}},$elem1183);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getContactsForChannel_args');
              if (defined $self->{ids}) {
                $xfer += $output->writeFieldBegin('ids', Thrift::TType::LIST, 2);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{ids}}));
                  {
                    foreach my $iter1184 (@{$self->{ids}}) 
                    {
                      $xfer += $output->writeString($iter1184);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getContactsForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getContactsForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getContactsForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1185 = 0;
                      $self->{success} = [];
                      my $_etype1188 = 0;
                      $xfer += $input->readListBegin(\$_etype1188, \$_size1185);
                      for (my $_i1189 = 0; $_i1189 < $_size1185; ++$_i1189)
                      {
                        my $elem1190 = undef;
                        $elem1190 = Contact->new();
                        $xfer += $elem1190->read($input);
                        push(@{$self->{success}},$elem1190);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getContactsForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1191 (@{$self->{success}}) 
                    {
                      $xfer += ${iter1191}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getDisplayName_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getDisplayName_args->mk_accessors( qw( mid ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{mid} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{mid}) {
                  $self->{mid} = $vals->{mid};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getDisplayName_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{mid});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getDisplayName_args');
              if (defined $self->{mid}) {
                $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                $xfer += $output->writeString($self->{mid});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getDisplayName_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getDisplayName_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getDisplayName_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getDisplayName_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                $xfer += $output->writeString($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getFavoriteMidsForChannel_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getFavoriteMidsForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getFavoriteMidsForChannel_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getFavoriteMidsForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getFavoriteMidsForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getFavoriteMidsForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1192 = 0;
                      $self->{success} = [];
                      my $_etype1195 = 0;
                      $xfer += $input->readListBegin(\$_etype1195, \$_size1192);
                      for (my $_i1196 = 0; $_i1196 < $_size1192; ++$_i1196)
                      {
                        my $elem1197 = undef;
                        $xfer += $input->readString(\$elem1197);
                        push(@{$self->{success}},$elem1197);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getFavoriteMidsForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1198 (@{$self->{success}}) 
                    {
                      $xfer += $output->writeString($iter1198);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getFriendMids_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getFriendMids_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getFriendMids_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getFriendMids_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getFriendMids_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getFriendMids_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1199 = 0;
                      $self->{success} = [];
                      my $_etype1202 = 0;
                      $xfer += $input->readListBegin(\$_etype1202, \$_size1199);
                      for (my $_i1203 = 0; $_i1203 < $_size1199; ++$_i1203)
                      {
                        my $elem1204 = undef;
                        $xfer += $input->readString(\$elem1204);
                        push(@{$self->{success}},$elem1204);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getFriendMids_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1205 (@{$self->{success}}) 
                    {
                      $xfer += $output->writeString($iter1205);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getGroupMemberMids_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getGroupMemberMids_args->mk_accessors( qw( groupId ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{groupId} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{groupId}) {
                  $self->{groupId} = $vals->{groupId};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getGroupMemberMids_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{groupId});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getGroupMemberMids_args');
              if (defined $self->{groupId}) {
                $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 1);
                $xfer += $output->writeString($self->{groupId});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getGroupMemberMids_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getGroupMemberMids_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getGroupMemberMids_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1206 = 0;
                      $self->{success} = [];
                      my $_etype1209 = 0;
                      $xfer += $input->readListBegin(\$_etype1209, \$_size1206);
                      for (my $_i1210 = 0; $_i1210 < $_size1206; ++$_i1210)
                      {
                        my $elem1211 = undef;
                        $xfer += $input->readString(\$elem1211);
                        push(@{$self->{success}},$elem1211);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getGroupMemberMids_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1212 (@{$self->{success}}) 
                    {
                      $xfer += $output->writeString($iter1212);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getGroupsForChannel_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getGroupsForChannel_args->mk_accessors( qw( groupIds ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{groupIds} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{groupIds}) {
                  $self->{groupIds} = $vals->{groupIds};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getGroupsForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1213 = 0;
                      $self->{groupIds} = [];
                      my $_etype1216 = 0;
                      $xfer += $input->readListBegin(\$_etype1216, \$_size1213);
                      for (my $_i1217 = 0; $_i1217 < $_size1213; ++$_i1217)
                      {
                        my $elem1218 = undef;
                        $xfer += $input->readString(\$elem1218);
                        push(@{$self->{groupIds}},$elem1218);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getGroupsForChannel_args');
              if (defined $self->{groupIds}) {
                $xfer += $output->writeFieldBegin('groupIds', Thrift::TType::LIST, 1);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{groupIds}}));
                  {
                    foreach my $iter1219 (@{$self->{groupIds}}) 
                    {
                      $xfer += $output->writeString($iter1219);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getGroupsForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getGroupsForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getGroupsForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1220 = 0;
                      $self->{success} = [];
                      my $_etype1223 = 0;
                      $xfer += $input->readListBegin(\$_etype1223, \$_size1220);
                      for (my $_i1224 = 0; $_i1224 < $_size1220; ++$_i1224)
                      {
                        my $elem1225 = undef;
                        $elem1225 = Group->new();
                        $xfer += $elem1225->read($input);
                        push(@{$self->{success}},$elem1225);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getGroupsForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1226 (@{$self->{success}}) 
                    {
                      $xfer += ${iter1226}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getIdentityCredential_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getIdentityCredential_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getIdentityCredential_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getIdentityCredential_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getIdentityCredential_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getIdentityCredential_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{success} = IdentityCredential->new();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getIdentityCredential_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1227 = 0;
                      $self->{success} = [];
                      my $_etype1230 = 0;
                      $xfer += $input->readListBegin(\$_etype1230, \$_size1227);
                      for (my $_i1231 = 0; $_i1231 < $_size1227; ++$_i1231)
                      {
                        my $elem1232 = undef;
                        $xfer += $input->readString(\$elem1232);
                        push(@{$self->{success}},$elem1232);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1233 (@{$self->{success}}) 
                    {
                      $xfer += $output->writeString($iter1233);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getMetaProfile_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getMetaProfile_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getMetaProfile_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getMetaProfile_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getMetaProfile_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getMetaProfile_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{success} = MetaProfile->new();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getMetaProfile_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getMid_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getMid_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getMid_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getMid_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getMid_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getMid_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getMid_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                $xfer += $output->writeString($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getPrimaryClientForChannel_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getPrimaryClientForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getPrimaryClientForChannel_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getPrimaryClientForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getPrimaryClientForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getPrimaryClientForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{success} = SimpleChannelClient->new();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getPrimaryClientForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getProfileForChannel_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getProfileForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getProfileForChannel_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getProfileForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getProfileForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getProfileForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{success} = Profile->new();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getProfileForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getSimpleChannelContacts_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getSimpleChannelContacts_args->mk_accessors( qw( ids ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{ids} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{ids}) {
                  $self->{ids} = $vals->{ids};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getSimpleChannelContacts_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1234 = 0;
                      $self->{ids} = [];
                      my $_etype1237 = 0;
                      $xfer += $input->readListBegin(\$_etype1237, \$_size1234);
                      for (my $_i1238 = 0; $_i1238 < $_size1234; ++$_i1238)
                      {
                        my $elem1239 = undef;
                        $xfer += $input->readString(\$elem1239);
                        push(@{$self->{ids}},$elem1239);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getSimpleChannelContacts_args');
              if (defined $self->{ids}) {
                $xfer += $output->writeFieldBegin('ids', Thrift::TType::LIST, 1);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{ids}}));
                  {
                    foreach my $iter1240 (@{$self->{ids}}) 
                    {
                      $xfer += $output->writeString($iter1240);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getSimpleChannelContacts_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getSimpleChannelContacts_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getSimpleChannelContacts_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1241 = 0;
                      $self->{success} = [];
                      my $_etype1244 = 0;
                      $xfer += $input->readListBegin(\$_etype1244, \$_size1241);
                      for (my $_i1245 = 0; $_i1245 < $_size1241; ++$_i1245)
                      {
                        my $elem1246 = undef;
                        $elem1246 = SimpleChannelContact->new();
                        $xfer += $elem1246->read($input);
                        push(@{$self->{success}},$elem1246);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getSimpleChannelContacts_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1247 (@{$self->{success}}) 
                    {
                      $xfer += ${iter1247}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserCountryForBilling_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getUserCountryForBilling_args->mk_accessors( qw( country remoteIp ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{country} = undef;
              $self->{remoteIp} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{country}) {
                  $self->{country} = $vals->{country};
                }
                if (defined $vals->{remoteIp}) {
                  $self->{remoteIp} = $vals->{remoteIp};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserCountryForBilling_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{country});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^3$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{remoteIp});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserCountryForBilling_args');
              if (defined $self->{country}) {
                $xfer += $output->writeFieldBegin('country', Thrift::TType::STRING, 2);
                $xfer += $output->writeString($self->{country});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{remoteIp}) {
                $xfer += $output->writeFieldBegin('remoteIp', Thrift::TType::STRING, 3);
                $xfer += $output->writeString($self->{remoteIp});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserCountryForBilling_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getUserCountryForBilling_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserCountryForBilling_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserCountryForBilling_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                $xfer += $output->writeString($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserCreateTime_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserCreateTime_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserCreateTime_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserCreateTime_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getUserCreateTime_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserCreateTime_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::I64) {
                    $xfer += $input->readI64(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserCreateTime_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
                $xfer += $output->writeI64($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserIdentities_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserIdentities_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserIdentities_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserIdentities_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getUserIdentities_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserIdentities_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::MAP) {
                    {
                      my $_size1248 = 0;
                      $self->{success} = {};
                      my $_ktype1249 = 0;
                      my $_vtype1250 = 0;
                      $xfer += $input->readMapBegin(\$_ktype1249, \$_vtype1250, \$_size1248);
                      for (my $_i1252 = 0; $_i1252 < $_size1248; ++$_i1252)
                      {
                        my $key1253 = 0;
                        my $val1254 = '';
                        $xfer += $input->readI32(\$key1253);
                        $xfer += $input->readString(\$val1254);
                        $self->{success}->{$key1253} = $val1254;
                      }
                      $xfer += $input->readMapEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserIdentities_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                {
                  $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                  {
                    while( my ($kiter1255,$viter1256) = each %{$self->{success}}) 
                    {
                      $xfer += $output->writeI32($kiter1255);
                      $xfer += $output->writeString($viter1256);
                    }
                  }
                  $xfer += $output->writeMapEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserLanguage_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserLanguage_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserLanguage_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserLanguage_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getUserLanguage_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserLanguage_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserLanguage_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                $xfer += $output->writeString($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::LIST) {
                    {
                      my $_size1257 = 0;
                      $self->{success} = [];
                      my $_etype1260 = 0;
                      $xfer += $input->readListBegin(\$_etype1260, \$_size1257);
                      for (my $_i1261 = 0; $_i1261 < $_size1257; ++$_i1261)
                      {
                        my $elem1262 = undef;
                        $xfer += $input->readString(\$elem1262);
                        push(@{$self->{success}},$elem1262);
                      }
                      $xfer += $input->readListEnd();
                    }
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                  {
                    foreach my $iter1263 (@{$self->{success}}) 
                    {
                      $xfer += $output->writeString($iter1263);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_isGroupMember_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_isGroupMember_args->mk_accessors( qw( groupId ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{groupId} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{groupId}) {
                  $self->{groupId} = $vals->{groupId};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_isGroupMember_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{groupId});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_isGroupMember_args');
              if (defined $self->{groupId}) {
                $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 1);
                $xfer += $output->writeString($self->{groupId});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_isGroupMember_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_isGroupMember_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_isGroupMember_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::BOOL) {
                    $xfer += $input->readBool(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_isGroupMember_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                $xfer += $output->writeBool($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_isInContact_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_isInContact_args->mk_accessors( qw( mid ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{mid} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{mid}) {
                  $self->{mid} = $vals->{mid};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_isInContact_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{mid});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_isInContact_args');
              if (defined $self->{mid}) {
                $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                $xfer += $output->writeString($self->{mid});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_isInContact_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_isInContact_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_isInContact_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::BOOL) {
                    $xfer += $input->readBool(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_isInContact_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                $xfer += $output->writeBool($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_registerChannelCP_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_registerChannelCP_args->mk_accessors( qw( cpId registerPassword ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{cpId} = undef;
              $self->{registerPassword} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{cpId}) {
                  $self->{cpId} = $vals->{cpId};
                }
                if (defined $vals->{registerPassword}) {
                  $self->{registerPassword} = $vals->{registerPassword};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_registerChannelCP_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{cpId});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^3$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{registerPassword});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_registerChannelCP_args');
              if (defined $self->{cpId}) {
                $xfer += $output->writeFieldBegin('cpId', Thrift::TType::STRING, 2);
                $xfer += $output->writeString($self->{cpId});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{registerPassword}) {
                $xfer += $output->writeFieldBegin('registerPassword', Thrift::TType::STRING, 3);
                $xfer += $output->writeString($self->{registerPassword});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_registerChannelCP_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_registerChannelCP_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_registerChannelCP_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_registerChannelCP_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                $xfer += $output->writeString($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_removeNotificationStatus_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_removeNotificationStatus_args->mk_accessors( qw( notificationStatus ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{notificationStatus} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{notificationStatus}) {
                  $self->{notificationStatus} = $vals->{notificationStatus};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_removeNotificationStatus_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::I32) {
                    $xfer += $input->readI32(\$self->{notificationStatus});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_removeNotificationStatus_args');
              if (defined $self->{notificationStatus}) {
                $xfer += $output->writeFieldBegin('notificationStatus', Thrift::TType::I32, 2);
                $xfer += $output->writeI32($self->{notificationStatus});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_removeNotificationStatus_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_removeNotificationStatus_result->mk_accessors( qw( ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_removeNotificationStatus_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_removeNotificationStatus_result');
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_sendMessageForChannel_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_sendMessageForChannel_args->mk_accessors( qw( message ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{message} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{message}) {
                  $self->{message} = $vals->{message};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_sendMessageForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{message} = Message->new();
                    $xfer += $self->{message}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_sendMessageForChannel_args');
              if (defined $self->{message}) {
                $xfer += $output->writeFieldBegin('message', Thrift::TType::STRUCT, 2);
                $xfer += $self->{message}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_sendMessageForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_sendMessageForChannel_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_sendMessageForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{success} = Message->new();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_sendMessageForChannel_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_sendPinCodeOperation_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_sendPinCodeOperation_args->mk_accessors( qw( verifier ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{verifier} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{verifier}) {
                  $self->{verifier} = $vals->{verifier};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_sendPinCodeOperation_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{verifier});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_sendPinCodeOperation_args');
              if (defined $self->{verifier}) {
                $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 1);
                $xfer += $output->writeString($self->{verifier});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_sendPinCodeOperation_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_sendPinCodeOperation_result->mk_accessors( qw( ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_sendPinCodeOperation_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_sendPinCodeOperation_result');
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_updateProfileAttributeForChannel_args;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_updateProfileAttributeForChannel_args->mk_accessors( qw( profileAttribute value ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{profileAttribute} = undef;
              $self->{value} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{profileAttribute}) {
                  $self->{profileAttribute} = $vals->{profileAttribute};
                }
                if (defined $vals->{value}) {
                  $self->{value} = $vals->{value};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_updateProfileAttributeForChannel_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^2$/ && do{                  if ($ftype == Thrift::TType::I32) {
                    $xfer += $input->readI32(\$self->{profileAttribute});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                  /^3$/ && do{                  if ($ftype == Thrift::TType::STRING) {
                    $xfer += $input->readString(\$self->{value});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_updateProfileAttributeForChannel_args');
              if (defined $self->{profileAttribute}) {
                $xfer += $output->writeFieldBegin('profileAttribute', Thrift::TType::I32, 2);
                $xfer += $output->writeI32($self->{profileAttribute});
                $xfer += $output->writeFieldEnd();
              }
              if (defined $self->{value}) {
                $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
                $xfer += $output->writeString($self->{value});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedService_updateProfileAttributeForChannel_result;
use base qw(Class::Accessor);
ChannelApplicationProvidedService_updateProfileAttributeForChannel_result->mk_accessors( qw( ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{e} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{e}) {
                  $self->{e} = $vals->{e};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'ChannelApplicationProvidedService_updateProfileAttributeForChannel_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1)
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == Thrift::TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == Thrift::TType::STRUCT) {
                    $self->{e} = TalkException->new();
                    $xfer += $self->{e}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('ChannelApplicationProvidedService_updateProfileAttributeForChannel_result');
              if (defined $self->{e}) {
                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                $xfer += $self->{e}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package ChannelApplicationProvidedServiceIf;

use strict;


sub activeBuddySubscriberCount{
  my $self = shift;

  die 'implement interface';
}

sub addOperationForChannel{
  my $self = shift;
  my $opType = shift;
  my $param1 = shift;
  my $param2 = shift;
  my $param3 = shift;

  die 'implement interface';
}

sub displayBuddySubscriberCount{
  my $self = shift;

  die 'implement interface';
}

sub findContactByUseridWithoutAbuseBlockForChannel{
  my $self = shift;
  my $userid = shift;

  die 'implement interface';
}

sub getAllContactIdsForChannel{
  my $self = shift;

  die 'implement interface';
}

sub getCompactContacts{
  my $self = shift;
  my $lastModifiedTimestamp = shift;

  die 'implement interface';
}

sub getContactsForChannel{
  my $self = shift;
  my $ids = shift;

  die 'implement interface';
}

sub getDisplayName{
  my $self = shift;
  my $mid = shift;

  die 'implement interface';
}

sub getFavoriteMidsForChannel{
  my $self = shift;

  die 'implement interface';
}

sub getFriendMids{
  my $self = shift;

  die 'implement interface';
}

sub getGroupMemberMids{
  my $self = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub getGroupsForChannel{
  my $self = shift;
  my $groupIds = shift;

  die 'implement interface';
}

sub getIdentityCredential{
  my $self = shift;

  die 'implement interface';
}

sub getJoinedGroupIdsForChannel{
  my $self = shift;

  die 'implement interface';
}

sub getMetaProfile{
  my $self = shift;

  die 'implement interface';
}

sub getMid{
  my $self = shift;

  die 'implement interface';
}

sub getPrimaryClientForChannel{
  my $self = shift;

  die 'implement interface';
}

sub getProfileForChannel{
  my $self = shift;

  die 'implement interface';
}

sub getSimpleChannelContacts{
  my $self = shift;
  my $ids = shift;

  die 'implement interface';
}

sub getUserCountryForBilling{
  my $self = shift;
  my $country = shift;
  my $remoteIp = shift;

  die 'implement interface';
}

sub getUserCreateTime{
  my $self = shift;

  die 'implement interface';
}

sub getUserIdentities{
  my $self = shift;

  die 'implement interface';
}

sub getUserLanguage{
  my $self = shift;

  die 'implement interface';
}

sub getUserMidsWhoAddedMe{
  my $self = shift;

  die 'implement interface';
}

sub isGroupMember{
  my $self = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub isInContact{
  my $self = shift;
  my $mid = shift;

  die 'implement interface';
}

sub registerChannelCP{
  my $self = shift;
  my $cpId = shift;
  my $registerPassword = shift;

  die 'implement interface';
}

sub removeNotificationStatus{
  my $self = shift;
  my $notificationStatus = shift;

  die 'implement interface';
}

sub sendMessageForChannel{
  my $self = shift;
  my $message = shift;

  die 'implement interface';
}

sub sendPinCodeOperation{
  my $self = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub updateProfileAttributeForChannel{
  my $self = shift;
  my $profileAttribute = shift;
  my $value = shift;

  die 'implement interface';
}

package ChannelApplicationProvidedServiceRest;

use strict;


sub new {
              my ($classname, $impl) = @_;
              my $self     ={ impl => $impl };

              return bless($self,$classname);
}

sub activeBuddySubscriberCount{
              my ($self, $request) = @_;

              return $self->{impl}->activeBuddySubscriberCount();
            }

sub addOperationForChannel{
              my ($self, $request) = @_;

              my $opType = ($request->{'opType'}) ? $request->{'opType'} : undef;
              my $param1 = ($request->{'param1'}) ? $request->{'param1'} : undef;
              my $param2 = ($request->{'param2'}) ? $request->{'param2'} : undef;
              my $param3 = ($request->{'param3'}) ? $request->{'param3'} : undef;
              return $self->{impl}->addOperationForChannel($opType, $param1, $param2, $param3);
            }

sub displayBuddySubscriberCount{
              my ($self, $request) = @_;

              return $self->{impl}->displayBuddySubscriberCount();
            }

sub findContactByUseridWithoutAbuseBlockForChannel{
              my ($self, $request) = @_;

              my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
              return $self->{impl}->findContactByUseridWithoutAbuseBlockForChannel($userid);
            }

sub getAllContactIdsForChannel{
              my ($self, $request) = @_;

              return $self->{impl}->getAllContactIdsForChannel();
            }

sub getCompactContacts{
              my ($self, $request) = @_;

              my $lastModifiedTimestamp = ($request->{'lastModifiedTimestamp'}) ? $request->{'lastModifiedTimestamp'} : undef;
              return $self->{impl}->getCompactContacts($lastModifiedTimestamp);
            }

sub getContactsForChannel{
              my ($self, $request) = @_;

              my $ids = ($request->{'ids'}) ? $request->{'ids'} : undef;
              return $self->{impl}->getContactsForChannel($ids);
            }

sub getDisplayName{
              my ($self, $request) = @_;

              my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
              return $self->{impl}->getDisplayName($mid);
            }

sub getFavoriteMidsForChannel{
              my ($self, $request) = @_;

              return $self->{impl}->getFavoriteMidsForChannel();
            }

sub getFriendMids{
              my ($self, $request) = @_;

              return $self->{impl}->getFriendMids();
            }

sub getGroupMemberMids{
              my ($self, $request) = @_;

              my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
              return $self->{impl}->getGroupMemberMids($groupId);
            }

sub getGroupsForChannel{
              my ($self, $request) = @_;

              my $groupIds = ($request->{'groupIds'}) ? $request->{'groupIds'} : undef;
              return $self->{impl}->getGroupsForChannel($groupIds);
            }

sub getIdentityCredential{
              my ($self, $request) = @_;

              return $self->{impl}->getIdentityCredential();
            }

sub getJoinedGroupIdsForChannel{
              my ($self, $request) = @_;

              return $self->{impl}->getJoinedGroupIdsForChannel();
            }

sub getMetaProfile{
              my ($self, $request) = @_;

              return $self->{impl}->getMetaProfile();
            }

sub getMid{
              my ($self, $request) = @_;

              return $self->{impl}->getMid();
            }

sub getPrimaryClientForChannel{
              my ($self, $request) = @_;

              return $self->{impl}->getPrimaryClientForChannel();
            }

sub getProfileForChannel{
              my ($self, $request) = @_;

              return $self->{impl}->getProfileForChannel();
            }

sub getSimpleChannelContacts{
              my ($self, $request) = @_;

              my $ids = ($request->{'ids'}) ? $request->{'ids'} : undef;
              return $self->{impl}->getSimpleChannelContacts($ids);
            }

sub getUserCountryForBilling{
              my ($self, $request) = @_;

              my $country = ($request->{'country'}) ? $request->{'country'} : undef;
              my $remoteIp = ($request->{'remoteIp'}) ? $request->{'remoteIp'} : undef;
              return $self->{impl}->getUserCountryForBilling($country, $remoteIp);
            }

sub getUserCreateTime{
              my ($self, $request) = @_;

              return $self->{impl}->getUserCreateTime();
            }

sub getUserIdentities{
              my ($self, $request) = @_;

              return $self->{impl}->getUserIdentities();
            }

sub getUserLanguage{
              my ($self, $request) = @_;

              return $self->{impl}->getUserLanguage();
            }

sub getUserMidsWhoAddedMe{
              my ($self, $request) = @_;

              return $self->{impl}->getUserMidsWhoAddedMe();
            }

sub isGroupMember{
              my ($self, $request) = @_;

              my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
              return $self->{impl}->isGroupMember($groupId);
            }

sub isInContact{
              my ($self, $request) = @_;

              my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
              return $self->{impl}->isInContact($mid);
            }

sub registerChannelCP{
              my ($self, $request) = @_;

              my $cpId = ($request->{'cpId'}) ? $request->{'cpId'} : undef;
              my $registerPassword = ($request->{'registerPassword'}) ? $request->{'registerPassword'} : undef;
              return $self->{impl}->registerChannelCP($cpId, $registerPassword);
            }

sub removeNotificationStatus{
              my ($self, $request) = @_;

              my $notificationStatus = ($request->{'notificationStatus'}) ? $request->{'notificationStatus'} : undef;
              return $self->{impl}->removeNotificationStatus($notificationStatus);
            }

sub sendMessageForChannel{
              my ($self, $request) = @_;

              my $message = ($request->{'message'}) ? $request->{'message'} : undef;
              return $self->{impl}->sendMessageForChannel($message);
            }

sub sendPinCodeOperation{
              my ($self, $request) = @_;

              my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
              return $self->{impl}->sendPinCodeOperation($verifier);
            }

sub updateProfileAttributeForChannel{
              my ($self, $request) = @_;

              my $profileAttribute = ($request->{'profileAttribute'}) ? $request->{'profileAttribute'} : undef;
              my $value = ($request->{'value'}) ? $request->{'value'} : undef;
              return $self->{impl}->updateProfileAttributeForChannel($profileAttribute, $value);
            }

package ChannelApplicationProvidedServiceClient;


use base qw(ChannelApplicationProvidedServiceIf);
sub new {
              my ($classname, $input, $output) = @_;
              my $self      = {};
              $self->{input}  = $input;
              $self->{output} = defined $output ? $output : $input;
              $self->{seqid}  = 0;
              return bless($self,$classname);
}

sub activeBuddySubscriberCount{
  my $self = shift;

                            $self->send_activeBuddySubscriberCount();
              return $self->recv_activeBuddySubscriberCount();
}

sub send_activeBuddySubscriberCount{
  my $self = shift;

              $self->{output}->writeMessageBegin('activeBuddySubscriberCount', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_activeBuddySubscriberCount_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_activeBuddySubscriberCount{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_activeBuddySubscriberCount_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "activeBuddySubscriberCount failed: unknown result";
}
sub addOperationForChannel{
  my $self = shift;
  my $opType = shift;
  my $param1 = shift;
  my $param2 = shift;
  my $param3 = shift;

                            $self->send_addOperationForChannel($opType, $param1, $param2, $param3);
              $self->recv_addOperationForChannel();
}

sub send_addOperationForChannel{
  my $self = shift;
  my $opType = shift;
  my $param1 = shift;
  my $param2 = shift;
  my $param3 = shift;

              $self->{output}->writeMessageBegin('addOperationForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_addOperationForChannel_args->new();
              $args->{opType} = $opType;
              $args->{param1} = $param1;
              $args->{param2} = $param2;
              $args->{param3} = $param3;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_addOperationForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_addOperationForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{e}) {
                die $result->{e};
              }
              return;
}
sub displayBuddySubscriberCount{
  my $self = shift;

                            $self->send_displayBuddySubscriberCount();
              return $self->recv_displayBuddySubscriberCount();
}

sub send_displayBuddySubscriberCount{
  my $self = shift;

              $self->{output}->writeMessageBegin('displayBuddySubscriberCount', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_displayBuddySubscriberCount_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_displayBuddySubscriberCount{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_displayBuddySubscriberCount_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "displayBuddySubscriberCount failed: unknown result";
}
sub findContactByUseridWithoutAbuseBlockForChannel{
  my $self = shift;
  my $userid = shift;

                            $self->send_findContactByUseridWithoutAbuseBlockForChannel($userid);
              return $self->recv_findContactByUseridWithoutAbuseBlockForChannel();
}

sub send_findContactByUseridWithoutAbuseBlockForChannel{
  my $self = shift;
  my $userid = shift;

              $self->{output}->writeMessageBegin('findContactByUseridWithoutAbuseBlockForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args->new();
              $args->{userid} = $userid;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_findContactByUseridWithoutAbuseBlockForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "findContactByUseridWithoutAbuseBlockForChannel failed: unknown result";
}
sub getAllContactIdsForChannel{
  my $self = shift;

                            $self->send_getAllContactIdsForChannel();
              return $self->recv_getAllContactIdsForChannel();
}

sub send_getAllContactIdsForChannel{
  my $self = shift;

              $self->{output}->writeMessageBegin('getAllContactIdsForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getAllContactIdsForChannel_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getAllContactIdsForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getAllContactIdsForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getAllContactIdsForChannel failed: unknown result";
}
sub getCompactContacts{
  my $self = shift;
  my $lastModifiedTimestamp = shift;

                            $self->send_getCompactContacts($lastModifiedTimestamp);
              return $self->recv_getCompactContacts();
}

sub send_getCompactContacts{
  my $self = shift;
  my $lastModifiedTimestamp = shift;

              $self->{output}->writeMessageBegin('getCompactContacts', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getCompactContacts_args->new();
              $args->{lastModifiedTimestamp} = $lastModifiedTimestamp;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getCompactContacts{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getCompactContacts_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getCompactContacts failed: unknown result";
}
sub getContactsForChannel{
  my $self = shift;
  my $ids = shift;

                            $self->send_getContactsForChannel($ids);
              return $self->recv_getContactsForChannel();
}

sub send_getContactsForChannel{
  my $self = shift;
  my $ids = shift;

              $self->{output}->writeMessageBegin('getContactsForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getContactsForChannel_args->new();
              $args->{ids} = $ids;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getContactsForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getContactsForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getContactsForChannel failed: unknown result";
}
sub getDisplayName{
  my $self = shift;
  my $mid = shift;

                            $self->send_getDisplayName($mid);
              return $self->recv_getDisplayName();
}

sub send_getDisplayName{
  my $self = shift;
  my $mid = shift;

              $self->{output}->writeMessageBegin('getDisplayName', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getDisplayName_args->new();
              $args->{mid} = $mid;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getDisplayName{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getDisplayName_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getDisplayName failed: unknown result";
}
sub getFavoriteMidsForChannel{
  my $self = shift;

                            $self->send_getFavoriteMidsForChannel();
              return $self->recv_getFavoriteMidsForChannel();
}

sub send_getFavoriteMidsForChannel{
  my $self = shift;

              $self->{output}->writeMessageBegin('getFavoriteMidsForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getFavoriteMidsForChannel_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getFavoriteMidsForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getFavoriteMidsForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getFavoriteMidsForChannel failed: unknown result";
}
sub getFriendMids{
  my $self = shift;

                            $self->send_getFriendMids();
              return $self->recv_getFriendMids();
}

sub send_getFriendMids{
  my $self = shift;

              $self->{output}->writeMessageBegin('getFriendMids', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getFriendMids_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getFriendMids{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getFriendMids_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getFriendMids failed: unknown result";
}
sub getGroupMemberMids{
  my $self = shift;
  my $groupId = shift;

                            $self->send_getGroupMemberMids($groupId);
              return $self->recv_getGroupMemberMids();
}

sub send_getGroupMemberMids{
  my $self = shift;
  my $groupId = shift;

              $self->{output}->writeMessageBegin('getGroupMemberMids', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getGroupMemberMids_args->new();
              $args->{groupId} = $groupId;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getGroupMemberMids{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getGroupMemberMids_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getGroupMemberMids failed: unknown result";
}
sub getGroupsForChannel{
  my $self = shift;
  my $groupIds = shift;

                            $self->send_getGroupsForChannel($groupIds);
              return $self->recv_getGroupsForChannel();
}

sub send_getGroupsForChannel{
  my $self = shift;
  my $groupIds = shift;

              $self->{output}->writeMessageBegin('getGroupsForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getGroupsForChannel_args->new();
              $args->{groupIds} = $groupIds;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getGroupsForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getGroupsForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getGroupsForChannel failed: unknown result";
}
sub getIdentityCredential{
  my $self = shift;

                            $self->send_getIdentityCredential();
              return $self->recv_getIdentityCredential();
}

sub send_getIdentityCredential{
  my $self = shift;

              $self->{output}->writeMessageBegin('getIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getIdentityCredential_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getIdentityCredential{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getIdentityCredential_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getIdentityCredential failed: unknown result";
}
sub getJoinedGroupIdsForChannel{
  my $self = shift;

                            $self->send_getJoinedGroupIdsForChannel();
              return $self->recv_getJoinedGroupIdsForChannel();
}

sub send_getJoinedGroupIdsForChannel{
  my $self = shift;

              $self->{output}->writeMessageBegin('getJoinedGroupIdsForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getJoinedGroupIdsForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getJoinedGroupIdsForChannel failed: unknown result";
}
sub getMetaProfile{
  my $self = shift;

                            $self->send_getMetaProfile();
              return $self->recv_getMetaProfile();
}

sub send_getMetaProfile{
  my $self = shift;

              $self->{output}->writeMessageBegin('getMetaProfile', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getMetaProfile_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getMetaProfile{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getMetaProfile_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getMetaProfile failed: unknown result";
}
sub getMid{
  my $self = shift;

                            $self->send_getMid();
              return $self->recv_getMid();
}

sub send_getMid{
  my $self = shift;

              $self->{output}->writeMessageBegin('getMid', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getMid_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getMid{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getMid_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getMid failed: unknown result";
}
sub getPrimaryClientForChannel{
  my $self = shift;

                            $self->send_getPrimaryClientForChannel();
              return $self->recv_getPrimaryClientForChannel();
}

sub send_getPrimaryClientForChannel{
  my $self = shift;

              $self->{output}->writeMessageBegin('getPrimaryClientForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getPrimaryClientForChannel_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getPrimaryClientForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getPrimaryClientForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getPrimaryClientForChannel failed: unknown result";
}
sub getProfileForChannel{
  my $self = shift;

                            $self->send_getProfileForChannel();
              return $self->recv_getProfileForChannel();
}

sub send_getProfileForChannel{
  my $self = shift;

              $self->{output}->writeMessageBegin('getProfileForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getProfileForChannel_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getProfileForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getProfileForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getProfileForChannel failed: unknown result";
}
sub getSimpleChannelContacts{
  my $self = shift;
  my $ids = shift;

                            $self->send_getSimpleChannelContacts($ids);
              return $self->recv_getSimpleChannelContacts();
}

sub send_getSimpleChannelContacts{
  my $self = shift;
  my $ids = shift;

              $self->{output}->writeMessageBegin('getSimpleChannelContacts', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getSimpleChannelContacts_args->new();
              $args->{ids} = $ids;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getSimpleChannelContacts{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getSimpleChannelContacts_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getSimpleChannelContacts failed: unknown result";
}
sub getUserCountryForBilling{
  my $self = shift;
  my $country = shift;
  my $remoteIp = shift;

                            $self->send_getUserCountryForBilling($country, $remoteIp);
              return $self->recv_getUserCountryForBilling();
}

sub send_getUserCountryForBilling{
  my $self = shift;
  my $country = shift;
  my $remoteIp = shift;

              $self->{output}->writeMessageBegin('getUserCountryForBilling', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getUserCountryForBilling_args->new();
              $args->{country} = $country;
              $args->{remoteIp} = $remoteIp;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getUserCountryForBilling{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getUserCountryForBilling_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getUserCountryForBilling failed: unknown result";
}
sub getUserCreateTime{
  my $self = shift;

                            $self->send_getUserCreateTime();
              return $self->recv_getUserCreateTime();
}

sub send_getUserCreateTime{
  my $self = shift;

              $self->{output}->writeMessageBegin('getUserCreateTime', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getUserCreateTime_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getUserCreateTime{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getUserCreateTime_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getUserCreateTime failed: unknown result";
}
sub getUserIdentities{
  my $self = shift;

                            $self->send_getUserIdentities();
              return $self->recv_getUserIdentities();
}

sub send_getUserIdentities{
  my $self = shift;

              $self->{output}->writeMessageBegin('getUserIdentities', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getUserIdentities_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getUserIdentities{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getUserIdentities_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getUserIdentities failed: unknown result";
}
sub getUserLanguage{
  my $self = shift;

                            $self->send_getUserLanguage();
              return $self->recv_getUserLanguage();
}

sub send_getUserLanguage{
  my $self = shift;

              $self->{output}->writeMessageBegin('getUserLanguage', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getUserLanguage_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getUserLanguage{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getUserLanguage_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getUserLanguage failed: unknown result";
}
sub getUserMidsWhoAddedMe{
  my $self = shift;

                            $self->send_getUserMidsWhoAddedMe();
              return $self->recv_getUserMidsWhoAddedMe();
}

sub send_getUserMidsWhoAddedMe{
  my $self = shift;

              $self->{output}->writeMessageBegin('getUserMidsWhoAddedMe', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args->new();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getUserMidsWhoAddedMe{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "getUserMidsWhoAddedMe failed: unknown result";
}
sub isGroupMember{
  my $self = shift;
  my $groupId = shift;

                            $self->send_isGroupMember($groupId);
              return $self->recv_isGroupMember();
}

sub send_isGroupMember{
  my $self = shift;
  my $groupId = shift;

              $self->{output}->writeMessageBegin('isGroupMember', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_isGroupMember_args->new();
              $args->{groupId} = $groupId;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_isGroupMember{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_isGroupMember_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "isGroupMember failed: unknown result";
}
sub isInContact{
  my $self = shift;
  my $mid = shift;

                            $self->send_isInContact($mid);
              return $self->recv_isInContact();
}

sub send_isInContact{
  my $self = shift;
  my $mid = shift;

              $self->{output}->writeMessageBegin('isInContact', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_isInContact_args->new();
              $args->{mid} = $mid;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_isInContact{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_isInContact_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "isInContact failed: unknown result";
}
sub registerChannelCP{
  my $self = shift;
  my $cpId = shift;
  my $registerPassword = shift;

                            $self->send_registerChannelCP($cpId, $registerPassword);
              return $self->recv_registerChannelCP();
}

sub send_registerChannelCP{
  my $self = shift;
  my $cpId = shift;
  my $registerPassword = shift;

              $self->{output}->writeMessageBegin('registerChannelCP', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_registerChannelCP_args->new();
              $args->{cpId} = $cpId;
              $args->{registerPassword} = $registerPassword;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_registerChannelCP{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_registerChannelCP_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "registerChannelCP failed: unknown result";
}
sub removeNotificationStatus{
  my $self = shift;
  my $notificationStatus = shift;

                            $self->send_removeNotificationStatus($notificationStatus);
              $self->recv_removeNotificationStatus();
}

sub send_removeNotificationStatus{
  my $self = shift;
  my $notificationStatus = shift;

              $self->{output}->writeMessageBegin('removeNotificationStatus', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_removeNotificationStatus_args->new();
              $args->{notificationStatus} = $notificationStatus;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_removeNotificationStatus{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_removeNotificationStatus_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{e}) {
                die $result->{e};
              }
              return;
}
sub sendMessageForChannel{
  my $self = shift;
  my $message = shift;

                            $self->send_sendMessageForChannel($message);
              return $self->recv_sendMessageForChannel();
}

sub send_sendMessageForChannel{
  my $self = shift;
  my $message = shift;

              $self->{output}->writeMessageBegin('sendMessageForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_sendMessageForChannel_args->new();
              $args->{message} = $message;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_sendMessageForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_sendMessageForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              if (defined $result->{e}) {
                die $result->{e};
              }
              die "sendMessageForChannel failed: unknown result";
}
sub sendPinCodeOperation{
  my $self = shift;
  my $verifier = shift;

                            $self->send_sendPinCodeOperation($verifier);
              $self->recv_sendPinCodeOperation();
}

sub send_sendPinCodeOperation{
  my $self = shift;
  my $verifier = shift;

              $self->{output}->writeMessageBegin('sendPinCodeOperation', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_sendPinCodeOperation_args->new();
              $args->{verifier} = $verifier;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_sendPinCodeOperation{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_sendPinCodeOperation_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{e}) {
                die $result->{e};
              }
              return;
}
sub updateProfileAttributeForChannel{
  my $self = shift;
  my $profileAttribute = shift;
  my $value = shift;

                            $self->send_updateProfileAttributeForChannel($profileAttribute, $value);
              $self->recv_updateProfileAttributeForChannel();
}

sub send_updateProfileAttributeForChannel{
  my $self = shift;
  my $profileAttribute = shift;
  my $value = shift;

              $self->{output}->writeMessageBegin('updateProfileAttributeForChannel', Thrift::TMessageType::CALL, $self->{seqid});
              my $args = ChannelApplicationProvidedService_updateProfileAttributeForChannel_args->new();
              $args->{profileAttribute} = $profileAttribute;
              $args->{value} = $value;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_updateProfileAttributeForChannel{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                my $x = Thrift::TApplicationException->new();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = ChannelApplicationProvidedService_updateProfileAttributeForChannel_result->new();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{e}) {
                die $result->{e};
              }
              return;
}
package ChannelApplicationProvidedServiceProcessor;

use strict;


sub new {
                my ($classname, $handler) = @_;
                my $self      = {};
                $self->{handler} = $handler;
                return bless ($self, $classname);
}

sub process {
                my ($self, $input, $output) = @_;
                my $rseqid = 0;
                my $fname  = undef;
                my $mtype  = 0;

                $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                my $methodname = 'process_'.$fname;
                if (!$self->can($methodname)) {
                  $input->skip(Thrift::TType::STRUCT);
                  $input->readMessageEnd();
                  my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
                  $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
                  $x->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  return;
                }
                $self->$methodname($rseqid, $input, $output);
                return 1;
}

sub process_activeBuddySubscriberCount {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_activeBuddySubscriberCount_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_activeBuddySubscriberCount_result->new();
                eval {
                  $result->{success} = $self->{handler}->activeBuddySubscriberCount();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('activeBuddySubscriberCount', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('activeBuddySubscriberCount', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_addOperationForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_addOperationForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_addOperationForChannel_result->new();
                eval {
                  $self->{handler}->addOperationForChannel($args->opType, $args->param1, $args->param2, $args->param3);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('addOperationForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('addOperationForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_displayBuddySubscriberCount {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_displayBuddySubscriberCount_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_displayBuddySubscriberCount_result->new();
                eval {
                  $result->{success} = $self->{handler}->displayBuddySubscriberCount();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('displayBuddySubscriberCount', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('displayBuddySubscriberCount', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_findContactByUseridWithoutAbuseBlockForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_findContactByUseridWithoutAbuseBlockForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->findContactByUseridWithoutAbuseBlockForChannel($args->userid);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('findContactByUseridWithoutAbuseBlockForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('findContactByUseridWithoutAbuseBlockForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getAllContactIdsForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getAllContactIdsForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getAllContactIdsForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getAllContactIdsForChannel();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getAllContactIdsForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getAllContactIdsForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getCompactContacts {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getCompactContacts_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getCompactContacts_result->new();
                eval {
                  $result->{success} = $self->{handler}->getCompactContacts($args->lastModifiedTimestamp);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getCompactContacts', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getCompactContacts', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getContactsForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getContactsForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getContactsForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getContactsForChannel($args->ids);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getContactsForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getContactsForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getDisplayName {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getDisplayName_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getDisplayName_result->new();
                eval {
                  $result->{success} = $self->{handler}->getDisplayName($args->mid);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getDisplayName', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getDisplayName', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getFavoriteMidsForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getFavoriteMidsForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getFavoriteMidsForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getFavoriteMidsForChannel();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getFavoriteMidsForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getFavoriteMidsForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getFriendMids {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getFriendMids_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getFriendMids_result->new();
                eval {
                  $result->{success} = $self->{handler}->getFriendMids();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getFriendMids', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getFriendMids', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getGroupMemberMids {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getGroupMemberMids_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getGroupMemberMids_result->new();
                eval {
                  $result->{success} = $self->{handler}->getGroupMemberMids($args->groupId);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getGroupMemberMids', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getGroupMemberMids', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getGroupsForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getGroupsForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getGroupsForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getGroupsForChannel($args->groupIds);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getGroupsForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getGroupsForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getIdentityCredential {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getIdentityCredential_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getIdentityCredential_result->new();
                eval {
                  $result->{success} = $self->{handler}->getIdentityCredential();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getJoinedGroupIdsForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getJoinedGroupIdsForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getJoinedGroupIdsForChannel();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getJoinedGroupIdsForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getJoinedGroupIdsForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getMetaProfile {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getMetaProfile_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getMetaProfile_result->new();
                eval {
                  $result->{success} = $self->{handler}->getMetaProfile();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getMetaProfile', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getMetaProfile', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getMid {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getMid_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getMid_result->new();
                eval {
                  $result->{success} = $self->{handler}->getMid();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getMid', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getMid', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getPrimaryClientForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getPrimaryClientForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getPrimaryClientForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getPrimaryClientForChannel();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getPrimaryClientForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getPrimaryClientForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getProfileForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getProfileForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getProfileForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->getProfileForChannel();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getProfileForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getProfileForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getSimpleChannelContacts {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getSimpleChannelContacts_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getSimpleChannelContacts_result->new();
                eval {
                  $result->{success} = $self->{handler}->getSimpleChannelContacts($args->ids);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getSimpleChannelContacts', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getSimpleChannelContacts', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getUserCountryForBilling {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getUserCountryForBilling_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getUserCountryForBilling_result->new();
                eval {
                  $result->{success} = $self->{handler}->getUserCountryForBilling($args->country, $args->remoteIp);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getUserCountryForBilling', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getUserCountryForBilling', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getUserCreateTime {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getUserCreateTime_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getUserCreateTime_result->new();
                eval {
                  $result->{success} = $self->{handler}->getUserCreateTime();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getUserCreateTime', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getUserCreateTime', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getUserIdentities {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getUserIdentities_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getUserIdentities_result->new();
                eval {
                  $result->{success} = $self->{handler}->getUserIdentities();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getUserIdentities', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getUserIdentities', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getUserLanguage {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getUserLanguage_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getUserLanguage_result->new();
                eval {
                  $result->{success} = $self->{handler}->getUserLanguage();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getUserLanguage', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getUserLanguage', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getUserMidsWhoAddedMe {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_getUserMidsWhoAddedMe_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_getUserMidsWhoAddedMe_result->new();
                eval {
                  $result->{success} = $self->{handler}->getUserMidsWhoAddedMe();
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('getUserMidsWhoAddedMe', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('getUserMidsWhoAddedMe', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_isGroupMember {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_isGroupMember_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_isGroupMember_result->new();
                eval {
                  $result->{success} = $self->{handler}->isGroupMember($args->groupId);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('isGroupMember', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('isGroupMember', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_isInContact {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_isInContact_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_isInContact_result->new();
                eval {
                  $result->{success} = $self->{handler}->isInContact($args->mid);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('isInContact', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('isInContact', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_registerChannelCP {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_registerChannelCP_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_registerChannelCP_result->new();
                eval {
                  $result->{success} = $self->{handler}->registerChannelCP($args->cpId, $args->registerPassword);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('registerChannelCP', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('registerChannelCP', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_removeNotificationStatus {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_removeNotificationStatus_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_removeNotificationStatus_result->new();
                eval {
                  $self->{handler}->removeNotificationStatus($args->notificationStatus);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('removeNotificationStatus', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('removeNotificationStatus', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_sendMessageForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_sendMessageForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_sendMessageForChannel_result->new();
                eval {
                  $result->{success} = $self->{handler}->sendMessageForChannel($args->message);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('sendMessageForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('sendMessageForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_sendPinCodeOperation {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_sendPinCodeOperation_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_sendPinCodeOperation_result->new();
                eval {
                  $self->{handler}->sendPinCodeOperation($args->verifier);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('sendPinCodeOperation', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('sendPinCodeOperation', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_updateProfileAttributeForChannel {
                my ($self, $seqid, $input, $output) = @_;
                my $args = ChannelApplicationProvidedService_updateProfileAttributeForChannel_args->new();
                $args->read($input);
                $input->readMessageEnd();
                my $result = ChannelApplicationProvidedService_updateProfileAttributeForChannel_result->new();
                eval {
                  $self->{handler}->updateProfileAttributeForChannel($args->profileAttribute, $args->value);
                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                  $result->{e} = $@;
                  $@ = undef;
                }
                if ($@) {
                  $@ =~ s/^\s+|\s+$//g;
                  my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                  $output->writeMessageBegin('updateProfileAttributeForChannel', Thrift::TMessageType::EXCEPTION, $seqid);
                  $err->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  $@ = undef;
                  return;
                }
                $output->writeMessageBegin('updateProfileAttributeForChannel', Thrift::TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

1;
