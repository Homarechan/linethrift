#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Types;


# HELPER FUNCTIONS AND STRUCTURES

package TalkService_searchCollection_args;
use base qw(Class::Accessor);
TalkService_searchCollection_args->mk_accessors( qw( query param ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{query} = undef;
                        $self->{param} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{query}) {
                            $self->{query} = $vals->{query};
                          }
                          if (defined $vals->{param}) {
                            $self->{param} = $vals->{param};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_searchCollection_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{query});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{param} = SearchPagingParameter->new();
                              $xfer += $self->{param}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_searchCollection_args');
                        if (defined $self->{query}) {
                          $xfer += $output->writeFieldBegin('query', Thrift::TType::STRING, 1);
                          $xfer += $output->writeString($self->{query});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{param}) {
                          $xfer += $output->writeFieldBegin('param', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{param}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_searchCollection_result;
use base qw(Class::Accessor);
TalkService_searchCollection_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_searchCollection_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = SearchResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_searchCollection_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getChatRoomAnnouncementsBulk_args;
use base qw(Class::Accessor);
TalkService_getChatRoomAnnouncementsBulk_args->mk_accessors( qw( chatRoomMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{chatRoomMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{chatRoomMids}) {
                            $self->{chatRoomMids} = $vals->{chatRoomMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getChatRoomAnnouncementsBulk_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1504 = 0;
                                $self->{chatRoomMids} = [];
                                my $_etype1507 = 0;
                                $xfer += $input->readListBegin(\$_etype1507, \$_size1504);
                                for (my $_i1508 = 0; $_i1508 < $_size1504; ++$_i1508)
                                {
                                  my $elem1509 = undef;
                                  $xfer += $input->readString(\$elem1509);
                                  push(@{$self->{chatRoomMids}},$elem1509);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getChatRoomAnnouncementsBulk_args');
                        if (defined $self->{chatRoomMids}) {
                          $xfer += $output->writeFieldBegin('chatRoomMids', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{chatRoomMids}}));
                            {
                              foreach my $iter1510 (@{$self->{chatRoomMids}}) 
                              {
                                $xfer += $output->writeString($iter1510);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getChatRoomAnnouncementsBulk_result;
use base qw(Class::Accessor);
TalkService_getChatRoomAnnouncementsBulk_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getChatRoomAnnouncementsBulk_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1511 = 0;
                                $self->{success} = {};
                                my $_ktype1512 = 0;
                                my $_vtype1513 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1512, \$_vtype1513, \$_size1511);
                                for (my $_i1515 = 0; $_i1515 < $_size1511; ++$_i1515)
                                {
                                  my $key1516 = '';
                                  my $val1517 = [];
                                  $xfer += $input->readString(\$key1516);
                                  {
                                    my $_size1518 = 0;
                                    $val1517 = [];
                                    my $_etype1521 = 0;
                                    $xfer += $input->readListBegin(\$_etype1521, \$_size1518);
                                    for (my $_i1522 = 0; $_i1522 < $_size1518; ++$_i1522)
                                    {
                                      my $elem1523 = undef;
                                      $elem1523 = ChatRoomAnnouncement->new();
                                      $xfer += $elem1523->read($input);
                                      push(@{$val1517},$elem1523);
                                    }
                                    $xfer += $input->readListEnd();
                                  }
                                  $self->{success}->{$key1516} = $val1517;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getChatRoomAnnouncementsBulk_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::LIST, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1524,$viter1525) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1524);
                                {
                                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{${viter1525}}));
                                  {
                                    foreach my $iter1526 (@{${viter1525}}) 
                                    {
                                      $xfer += ${iter1526}->write($output);
                                    }
                                  }
                                  $xfer += $output->writeListEnd();
                                }
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getChatRoomAnnouncements_args;
use base qw(Class::Accessor);
TalkService_getChatRoomAnnouncements_args->mk_accessors( qw( chatRoomMid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{chatRoomMid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{chatRoomMid}) {
                            $self->{chatRoomMid} = $vals->{chatRoomMid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getChatRoomAnnouncements_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{chatRoomMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getChatRoomAnnouncements_args');
                        if (defined $self->{chatRoomMid}) {
                          $xfer += $output->writeFieldBegin('chatRoomMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{chatRoomMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getChatRoomAnnouncements_result;
use base qw(Class::Accessor);
TalkService_getChatRoomAnnouncements_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getChatRoomAnnouncements_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1527 = 0;
                                $self->{success} = [];
                                my $_etype1530 = 0;
                                $xfer += $input->readListBegin(\$_etype1530, \$_size1527);
                                for (my $_i1531 = 0; $_i1531 < $_size1527; ++$_i1531)
                                {
                                  my $elem1532 = undef;
                                  $elem1532 = ChatRoomAnnouncement->new();
                                  $xfer += $elem1532->read($input);
                                  push(@{$self->{success}},$elem1532);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getChatRoomAnnouncements_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1533 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1533}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createChatRoomAnnouncement_args;
use base qw(Class::Accessor);
TalkService_createChatRoomAnnouncement_args->mk_accessors( qw( reqSeq chatRoomMid type contents ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{chatRoomMid} = undef;
                        $self->{type} = undef;
                        $self->{contents} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{chatRoomMid}) {
                            $self->{chatRoomMid} = $vals->{chatRoomMid};
                          }
                          if (defined $vals->{type}) {
                            $self->{type} = $vals->{type};
                          }
                          if (defined $vals->{contents}) {
                            $self->{contents} = $vals->{contents};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createChatRoomAnnouncement_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{chatRoomMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{type});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{contents} = ChatRoomAnnouncementContents->new();
                              $xfer += $self->{contents}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createChatRoomAnnouncement_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{chatRoomMid}) {
                          $xfer += $output->writeFieldBegin('chatRoomMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{chatRoomMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{type}) {
                          $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{type});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contents}) {
                          $xfer += $output->writeFieldBegin('contents', Thrift::TType::STRUCT, 4);
                          $xfer += $self->{contents}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createChatRoomAnnouncement_result;
use base qw(Class::Accessor);
TalkService_createChatRoomAnnouncement_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createChatRoomAnnouncement_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = ChatRoomAnnouncement->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createChatRoomAnnouncement_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeChatRoomAnnouncement_args;
use base qw(Class::Accessor);
TalkService_removeChatRoomAnnouncement_args->mk_accessors( qw( reqSeq chatRoomMid announcementSeq ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{chatRoomMid} = undef;
                        $self->{announcementSeq} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{chatRoomMid}) {
                            $self->{chatRoomMid} = $vals->{chatRoomMid};
                          }
                          if (defined $vals->{announcementSeq}) {
                            $self->{announcementSeq} = $vals->{announcementSeq};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeChatRoomAnnouncement_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{chatRoomMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{announcementSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeChatRoomAnnouncement_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{chatRoomMid}) {
                          $xfer += $output->writeFieldBegin('chatRoomMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{chatRoomMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{announcementSeq}) {
                          $xfer += $output->writeFieldBegin('announcementSeq', Thrift::TType::I64, 3);
                          $xfer += $output->writeI64($self->{announcementSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeChatRoomAnnouncement_result;
use base qw(Class::Accessor);
TalkService_removeChatRoomAnnouncement_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeChatRoomAnnouncement_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeChatRoomAnnouncement_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unsendMessage_args;
use base qw(Class::Accessor);
TalkService_unsendMessage_args->mk_accessors( qw( seq messageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{messageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unsendMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unsendMessage_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unsendMessage_result;
use base qw(Class::Accessor);
TalkService_unsendMessage_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unsendMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unsendMessage_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupWithoutMembers_args;
use base qw(Class::Accessor);
TalkService_getGroupWithoutMembers_args->mk_accessors( qw( groupId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{groupId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupWithoutMembers_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupWithoutMembers_args');
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupWithoutMembers_result;
use base qw(Class::Accessor);
TalkService_getGroupWithoutMembers_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupWithoutMembers_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Group->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupWithoutMembers_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestResendMessage_args;
use base qw(Class::Accessor);
TalkService_requestResendMessage_args->mk_accessors( qw( reqSeq senderMid messageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{senderMid} = undef;
                        $self->{messageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{senderMid}) {
                            $self->{senderMid} = $vals->{senderMid};
                          }
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestResendMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{senderMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestResendMessage_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{senderMid}) {
                          $xfer += $output->writeFieldBegin('senderMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{senderMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestResendMessage_result;
use base qw(Class::Accessor);
TalkService_requestResendMessage_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestResendMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestResendMessage_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_respondResendMessage_args;
use base qw(Class::Accessor);
TalkService_respondResendMessage_args->mk_accessors( qw( reqSeq receiverMid originalMessageId resendMessage errorCode ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{receiverMid} = undef;
                        $self->{originalMessageId} = undef;
                        $self->{resendMessage} = undef;
                        $self->{errorCode} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{receiverMid}) {
                            $self->{receiverMid} = $vals->{receiverMid};
                          }
                          if (defined $vals->{originalMessageId}) {
                            $self->{originalMessageId} = $vals->{originalMessageId};
                          }
                          if (defined $vals->{resendMessage}) {
                            $self->{resendMessage} = $vals->{resendMessage};
                          }
                          if (defined $vals->{errorCode}) {
                            $self->{errorCode} = $vals->{errorCode};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_respondResendMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{receiverMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{originalMessageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{resendMessage} = Message->new();
                              $xfer += $self->{resendMessage}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{errorCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_respondResendMessage_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMid}) {
                          $xfer += $output->writeFieldBegin('receiverMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{receiverMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{originalMessageId}) {
                          $xfer += $output->writeFieldBegin('originalMessageId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{originalMessageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{resendMessage}) {
                          $xfer += $output->writeFieldBegin('resendMessage', Thrift::TType::STRUCT, 4);
                          $xfer += $self->{resendMessage}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{errorCode}) {
                          $xfer += $output->writeFieldBegin('errorCode', Thrift::TType::I32, 5);
                          $xfer += $output->writeI32($self->{errorCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_respondResendMessage_result;
use base qw(Class::Accessor);
TalkService_respondResendMessage_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_respondResendMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_respondResendMessage_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acceptGroupInvitation_args;
use base qw(Class::Accessor);
TalkService_acceptGroupInvitation_args->mk_accessors( qw( reqSeq groupId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acceptGroupInvitation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acceptGroupInvitation_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acceptGroupInvitation_result;
use base qw(Class::Accessor);
TalkService_acceptGroupInvitation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acceptGroupInvitation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acceptGroupInvitation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acceptGroupInvitationByTicket_args;
use base qw(Class::Accessor);
TalkService_acceptGroupInvitationByTicket_args->mk_accessors( qw( reqSeq GroupMid ticketId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{GroupMid} = undef;
                        $self->{ticketId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{GroupMid}) {
                            $self->{GroupMid} = $vals->{GroupMid};
                          }
                          if (defined $vals->{ticketId}) {
                            $self->{ticketId} = $vals->{ticketId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acceptGroupInvitationByTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{GroupMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{ticketId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acceptGroupInvitationByTicket_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{GroupMid}) {
                          $xfer += $output->writeFieldBegin('GroupMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{GroupMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{ticketId}) {
                          $xfer += $output->writeFieldBegin('ticketId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{ticketId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acceptGroupInvitationByTicket_result;
use base qw(Class::Accessor);
TalkService_acceptGroupInvitationByTicket_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acceptGroupInvitationByTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acceptGroupInvitationByTicket_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acceptProximityMatches_args;
use base qw(Class::Accessor);
TalkService_acceptProximityMatches_args->mk_accessors( qw( sessionId ids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{ids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{ids}) {
                            $self->{ids} = $vals->{ids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acceptProximityMatches_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1534 = 0;
                                $self->{ids} = {};
                                my $_etype1537 = 0;
                                $xfer += $input->readSetBegin(\$_etype1537, \$_size1534);
                                for (my $_i1538 = 0; $_i1538 < $_size1534; ++$_i1538)
                                {
                                  my $elem1539 = undef;
                                  $xfer += $input->readString(\$elem1539);
                                  $self->{ids}->{$elem1539} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acceptProximityMatches_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{ids}) {
                          $xfer += $output->writeFieldBegin('ids', Thrift::TType::SET, 3);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{ids}}));
                            {
                              foreach my $iter1540 (@{$self->{ids}})
                              {
                                $xfer += $output->writeString($iter1540);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acceptProximityMatches_result;
use base qw(Class::Accessor);
TalkService_acceptProximityMatches_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acceptProximityMatches_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acceptProximityMatches_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acquireCallRoute_args;
use base qw(Class::Accessor);
TalkService_acquireCallRoute_args->mk_accessors( qw( to ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{to} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{to}) {
                            $self->{to} = $vals->{to};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acquireCallRoute_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{to});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acquireCallRoute_args');
                        if (defined $self->{to}) {
                          $xfer += $output->writeFieldBegin('to', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{to});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acquireCallRoute_result;
use base qw(Class::Accessor);
TalkService_acquireCallRoute_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acquireCallRoute_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1541 = 0;
                                $self->{success} = [];
                                my $_etype1544 = 0;
                                $xfer += $input->readListBegin(\$_etype1544, \$_size1541);
                                for (my $_i1545 = 0; $_i1545 < $_size1541; ++$_i1545)
                                {
                                  my $elem1546 = undef;
                                  $xfer += $input->readString(\$elem1546);
                                  push(@{$self->{success}},$elem1546);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acquireCallRoute_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1547 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1547);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acquireCallTicket_args;
use base qw(Class::Accessor);
TalkService_acquireCallTicket_args->mk_accessors( qw( to ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{to} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{to}) {
                            $self->{to} = $vals->{to};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acquireCallTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{to});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acquireCallTicket_args');
                        if (defined $self->{to}) {
                          $xfer += $output->writeFieldBegin('to', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{to});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acquireCallTicket_result;
use base qw(Class::Accessor);
TalkService_acquireCallTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acquireCallTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acquireCallTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acquireEncryptedAccessToken_args;
use base qw(Class::Accessor);
TalkService_acquireEncryptedAccessToken_args->mk_accessors( qw( featureType ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{featureType} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{featureType}) {
                            $self->{featureType} = $vals->{featureType};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acquireEncryptedAccessToken_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{featureType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acquireEncryptedAccessToken_args');
                        if (defined $self->{featureType}) {
                          $xfer += $output->writeFieldBegin('featureType', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{featureType});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_acquireEncryptedAccessToken_result;
use base qw(Class::Accessor);
TalkService_acquireEncryptedAccessToken_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_acquireEncryptedAccessToken_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_acquireEncryptedAccessToken_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_addSnsId_args;
use base qw(Class::Accessor);
TalkService_addSnsId_args->mk_accessors( qw( snsIdType snsAccessToken ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{snsIdType} = undef;
                        $self->{snsAccessToken} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{snsIdType}) {
                            $self->{snsIdType} = $vals->{snsIdType};
                          }
                          if (defined $vals->{snsAccessToken}) {
                            $self->{snsAccessToken} = $vals->{snsAccessToken};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_addSnsId_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{snsIdType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{snsAccessToken});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_addSnsId_args');
                        if (defined $self->{snsIdType}) {
                          $xfer += $output->writeFieldBegin('snsIdType', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{snsIdType});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{snsAccessToken}) {
                          $xfer += $output->writeFieldBegin('snsAccessToken', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{snsAccessToken});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_addSnsId_result;
use base qw(Class::Accessor);
TalkService_addSnsId_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_addSnsId_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_addSnsId_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_blockContact_args;
use base qw(Class::Accessor);
TalkService_blockContact_args->mk_accessors( qw( reqSeq id ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{id} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{id}) {
                            $self->{id} = $vals->{id};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_blockContact_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{id});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_blockContact_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{id}) {
                          $xfer += $output->writeFieldBegin('id', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{id});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_blockContact_result;
use base qw(Class::Accessor);
TalkService_blockContact_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_blockContact_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_blockContact_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_blockRecommendation_args;
use base qw(Class::Accessor);
TalkService_blockRecommendation_args->mk_accessors( qw( reqSeq id ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{id} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{id}) {
                            $self->{id} = $vals->{id};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_blockRecommendation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{id});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_blockRecommendation_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{id}) {
                          $xfer += $output->writeFieldBegin('id', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{id});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_blockRecommendation_result;
use base qw(Class::Accessor);
TalkService_blockRecommendation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_blockRecommendation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_blockRecommendation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_cancelGroupInvitation_args;
use base qw(Class::Accessor);
TalkService_cancelGroupInvitation_args->mk_accessors( qw( reqSeq groupId contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupId} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_cancelGroupInvitation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1548 = 0;
                                $self->{contactIds} = [];
                                my $_etype1551 = 0;
                                $xfer += $input->readListBegin(\$_etype1551, \$_size1548);
                                for (my $_i1552 = 0; $_i1552 < $_size1548; ++$_i1552)
                                {
                                  my $elem1553 = undef;
                                  $xfer += $input->readString(\$elem1553);
                                  push(@{$self->{contactIds}},$elem1553);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_cancelGroupInvitation_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter1554 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter1554);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_cancelGroupInvitation_result;
use base qw(Class::Accessor);
TalkService_cancelGroupInvitation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_cancelGroupInvitation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_cancelGroupInvitation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_changeVerificationMethod_args;
use base qw(Class::Accessor);
TalkService_changeVerificationMethod_args->mk_accessors( qw( sessionId method ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{method} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{method}) {
                            $self->{method} = $vals->{method};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_changeVerificationMethod_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{method});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_changeVerificationMethod_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{method}) {
                          $xfer += $output->writeFieldBegin('method', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{method});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_changeVerificationMethod_result;
use base qw(Class::Accessor);
TalkService_changeVerificationMethod_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_changeVerificationMethod_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = VerificationSessionData->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_changeVerificationMethod_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_clearIdentityCredential_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_clearIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_clearIdentityCredential_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_clearIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_clearIdentityCredential_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_clearIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_clearIdentityCredential_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_clearMessageBox_args;
use base qw(Class::Accessor);
TalkService_clearMessageBox_args->mk_accessors( qw( channelId messageBoxId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{channelId} = undef;
                        $self->{messageBoxId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{channelId}) {
                            $self->{channelId} = $vals->{channelId};
                          }
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_clearMessageBox_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{channelId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_clearMessageBox_args');
                        if (defined $self->{channelId}) {
                          $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{channelId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_clearMessageBox_result;
use base qw(Class::Accessor);
TalkService_clearMessageBox_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_clearMessageBox_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_clearMessageBox_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_closeProximityMatch_args;
use base qw(Class::Accessor);
TalkService_closeProximityMatch_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_closeProximityMatch_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_closeProximityMatch_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_closeProximityMatch_result;
use base qw(Class::Accessor);
TalkService_closeProximityMatch_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_closeProximityMatch_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_closeProximityMatch_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_commitSendMessage_args;
use base qw(Class::Accessor);
TalkService_commitSendMessage_args->mk_accessors( qw( seq messageId receiverMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{messageId} = undef;
                        $self->{receiverMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                          if (defined $vals->{receiverMids}) {
                            $self->{receiverMids} = $vals->{receiverMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_commitSendMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1555 = 0;
                                $self->{receiverMids} = [];
                                my $_etype1558 = 0;
                                $xfer += $input->readListBegin(\$_etype1558, \$_size1555);
                                for (my $_i1559 = 0; $_i1559 < $_size1555; ++$_i1559)
                                {
                                  my $elem1560 = undef;
                                  $xfer += $input->readString(\$elem1560);
                                  push(@{$self->{receiverMids}},$elem1560);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_commitSendMessage_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMids}) {
                          $xfer += $output->writeFieldBegin('receiverMids', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{receiverMids}}));
                            {
                              foreach my $iter1561 (@{$self->{receiverMids}}) 
                              {
                                $xfer += $output->writeString($iter1561);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_commitSendMessage_result;
use base qw(Class::Accessor);
TalkService_commitSendMessage_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_commitSendMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1562 = 0;
                                $self->{success} = {};
                                my $_ktype1563 = 0;
                                my $_vtype1564 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1563, \$_vtype1564, \$_size1562);
                                for (my $_i1566 = 0; $_i1566 < $_size1562; ++$_i1566)
                                {
                                  my $key1567 = '';
                                  my $val1568 = '';
                                  $xfer += $input->readString(\$key1567);
                                  $xfer += $input->readString(\$val1568);
                                  $self->{success}->{$key1567} = $val1568;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_commitSendMessage_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1569,$viter1570) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1569);
                                $xfer += $output->writeString($viter1570);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_commitSendMessages_args;
use base qw(Class::Accessor);
TalkService_commitSendMessages_args->mk_accessors( qw( seq messageIds receiverMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{messageIds} = undef;
                        $self->{receiverMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{messageIds}) {
                            $self->{messageIds} = $vals->{messageIds};
                          }
                          if (defined $vals->{receiverMids}) {
                            $self->{receiverMids} = $vals->{receiverMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_commitSendMessages_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1571 = 0;
                                $self->{messageIds} = [];
                                my $_etype1574 = 0;
                                $xfer += $input->readListBegin(\$_etype1574, \$_size1571);
                                for (my $_i1575 = 0; $_i1575 < $_size1571; ++$_i1575)
                                {
                                  my $elem1576 = undef;
                                  $xfer += $input->readString(\$elem1576);
                                  push(@{$self->{messageIds}},$elem1576);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1577 = 0;
                                $self->{receiverMids} = [];
                                my $_etype1580 = 0;
                                $xfer += $input->readListBegin(\$_etype1580, \$_size1577);
                                for (my $_i1581 = 0; $_i1581 < $_size1577; ++$_i1581)
                                {
                                  my $elem1582 = undef;
                                  $xfer += $input->readString(\$elem1582);
                                  push(@{$self->{receiverMids}},$elem1582);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_commitSendMessages_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageIds}) {
                          $xfer += $output->writeFieldBegin('messageIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{messageIds}}));
                            {
                              foreach my $iter1583 (@{$self->{messageIds}}) 
                              {
                                $xfer += $output->writeString($iter1583);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMids}) {
                          $xfer += $output->writeFieldBegin('receiverMids', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{receiverMids}}));
                            {
                              foreach my $iter1584 (@{$self->{receiverMids}}) 
                              {
                                $xfer += $output->writeString($iter1584);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_commitSendMessages_result;
use base qw(Class::Accessor);
TalkService_commitSendMessages_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_commitSendMessages_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1585 = 0;
                                $self->{success} = {};
                                my $_ktype1586 = 0;
                                my $_vtype1587 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1586, \$_vtype1587, \$_size1585);
                                for (my $_i1589 = 0; $_i1589 < $_size1585; ++$_i1589)
                                {
                                  my $key1590 = '';
                                  my $val1591 = '';
                                  $xfer += $input->readString(\$key1590);
                                  $xfer += $input->readString(\$val1591);
                                  $self->{success}->{$key1590} = $val1591;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_commitSendMessages_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1592,$viter1593) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1592);
                                $xfer += $output->writeString($viter1593);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_commitUpdateProfile_args;
use base qw(Class::Accessor);
TalkService_commitUpdateProfile_args->mk_accessors( qw( seq attrs receiverMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{attrs} = undef;
                        $self->{receiverMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{attrs}) {
                            $self->{attrs} = $vals->{attrs};
                          }
                          if (defined $vals->{receiverMids}) {
                            $self->{receiverMids} = $vals->{receiverMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_commitUpdateProfile_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1594 = 0;
                                $self->{attrs} = [];
                                my $_etype1597 = 0;
                                $xfer += $input->readListBegin(\$_etype1597, \$_size1594);
                                for (my $_i1598 = 0; $_i1598 < $_size1594; ++$_i1598)
                                {
                                  my $elem1599 = undef;
                                  $xfer += $input->readI32(\$elem1599);
                                  push(@{$self->{attrs}},$elem1599);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1600 = 0;
                                $self->{receiverMids} = [];
                                my $_etype1603 = 0;
                                $xfer += $input->readListBegin(\$_etype1603, \$_size1600);
                                for (my $_i1604 = 0; $_i1604 < $_size1600; ++$_i1604)
                                {
                                  my $elem1605 = undef;
                                  $xfer += $input->readString(\$elem1605);
                                  push(@{$self->{receiverMids}},$elem1605);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_commitUpdateProfile_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{attrs}) {
                          $xfer += $output->writeFieldBegin('attrs', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{attrs}}));
                            {
                              foreach my $iter1606 (@{$self->{attrs}}) 
                              {
                                $xfer += $output->writeI32($iter1606);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMids}) {
                          $xfer += $output->writeFieldBegin('receiverMids', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{receiverMids}}));
                            {
                              foreach my $iter1607 (@{$self->{receiverMids}}) 
                              {
                                $xfer += $output->writeString($iter1607);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_commitUpdateProfile_result;
use base qw(Class::Accessor);
TalkService_commitUpdateProfile_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_commitUpdateProfile_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1608 = 0;
                                $self->{success} = {};
                                my $_ktype1609 = 0;
                                my $_vtype1610 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1609, \$_vtype1610, \$_size1608);
                                for (my $_i1612 = 0; $_i1612 < $_size1608; ++$_i1612)
                                {
                                  my $key1613 = '';
                                  my $val1614 = '';
                                  $xfer += $input->readString(\$key1613);
                                  $xfer += $input->readString(\$val1614);
                                  $self->{success}->{$key1613} = $val1614;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_commitUpdateProfile_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1615,$viter1616) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1615);
                                $xfer += $output->writeString($viter1616);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_confirmEmail_args;
use base qw(Class::Accessor);
TalkService_confirmEmail_args->mk_accessors( qw( verifier pinCode ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifier} = undef;
                        $self->{pinCode} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                          if (defined $vals->{pinCode}) {
                            $self->{pinCode} = $vals->{pinCode};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_confirmEmail_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{pinCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_confirmEmail_args');
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{pinCode}) {
                          $xfer += $output->writeFieldBegin('pinCode', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{pinCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_confirmEmail_result;
use base qw(Class::Accessor);
TalkService_confirmEmail_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_confirmEmail_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_confirmEmail_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createGroup_args;
use base qw(Class::Accessor);
TalkService_createGroup_args->mk_accessors( qw( seq name contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{name} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{name}) {
                            $self->{name} = $vals->{name};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{name});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1617 = 0;
                                $self->{contactIds} = [];
                                my $_etype1620 = 0;
                                $xfer += $input->readListBegin(\$_etype1620, \$_size1617);
                                for (my $_i1621 = 0; $_i1621 < $_size1617; ++$_i1621)
                                {
                                  my $elem1622 = undef;
                                  $xfer += $input->readString(\$elem1622);
                                  push(@{$self->{contactIds}},$elem1622);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createGroup_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{name}) {
                          $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{name});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter1623 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter1623);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createGroup_result;
use base qw(Class::Accessor);
TalkService_createGroup_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Group->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createGroup_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createQrcodeBase64Image_args;
use base qw(Class::Accessor);
TalkService_createQrcodeBase64Image_args->mk_accessors( qw( url characterSet imageSize x y width height ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{url} = undef;
                        $self->{characterSet} = undef;
                        $self->{imageSize} = undef;
                        $self->{x} = undef;
                        $self->{y} = undef;
                        $self->{width} = undef;
                        $self->{height} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{url}) {
                            $self->{url} = $vals->{url};
                          }
                          if (defined $vals->{characterSet}) {
                            $self->{characterSet} = $vals->{characterSet};
                          }
                          if (defined $vals->{imageSize}) {
                            $self->{imageSize} = $vals->{imageSize};
                          }
                          if (defined $vals->{x}) {
                            $self->{x} = $vals->{x};
                          }
                          if (defined $vals->{y}) {
                            $self->{y} = $vals->{y};
                          }
                          if (defined $vals->{width}) {
                            $self->{width} = $vals->{width};
                          }
                          if (defined $vals->{height}) {
                            $self->{height} = $vals->{height};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createQrcodeBase64Image_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{url});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{characterSet});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{imageSize});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{x});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{y});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{width});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^8$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{height});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createQrcodeBase64Image_args');
                        if (defined $self->{url}) {
                          $xfer += $output->writeFieldBegin('url', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{url});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{characterSet}) {
                          $xfer += $output->writeFieldBegin('characterSet', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{characterSet});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{imageSize}) {
                          $xfer += $output->writeFieldBegin('imageSize', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{imageSize});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{x}) {
                          $xfer += $output->writeFieldBegin('x', Thrift::TType::I32, 5);
                          $xfer += $output->writeI32($self->{x});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{y}) {
                          $xfer += $output->writeFieldBegin('y', Thrift::TType::I32, 6);
                          $xfer += $output->writeI32($self->{y});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{width}) {
                          $xfer += $output->writeFieldBegin('width', Thrift::TType::I32, 7);
                          $xfer += $output->writeI32($self->{width});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{height}) {
                          $xfer += $output->writeFieldBegin('height', Thrift::TType::I32, 8);
                          $xfer += $output->writeI32($self->{height});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createQrcodeBase64Image_result;
use base qw(Class::Accessor);
TalkService_createQrcodeBase64Image_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createQrcodeBase64Image_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createQrcodeBase64Image_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createRoom_args;
use base qw(Class::Accessor);
TalkService_createRoom_args->mk_accessors( qw( reqSeq contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createRoom_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1624 = 0;
                                $self->{contactIds} = [];
                                my $_etype1627 = 0;
                                $xfer += $input->readListBegin(\$_etype1627, \$_size1624);
                                for (my $_i1628 = 0; $_i1628 < $_size1624; ++$_i1628)
                                {
                                  my $elem1629 = undef;
                                  $xfer += $input->readString(\$elem1629);
                                  push(@{$self->{contactIds}},$elem1629);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createRoom_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter1630 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter1630);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createRoom_result;
use base qw(Class::Accessor);
TalkService_createRoom_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createRoom_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Room->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createRoom_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createSession_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createSession_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createSession_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createSession_result;
use base qw(Class::Accessor);
TalkService_createSession_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createSession_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createSession_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchAnnouncements_args;
use base qw(Class::Accessor);
TalkService_fetchAnnouncements_args->mk_accessors( qw( lastFetchedIndex ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{lastFetchedIndex} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{lastFetchedIndex}) {
                            $self->{lastFetchedIndex} = $vals->{lastFetchedIndex};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchAnnouncements_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{lastFetchedIndex});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchAnnouncements_args');
                        if (defined $self->{lastFetchedIndex}) {
                          $xfer += $output->writeFieldBegin('lastFetchedIndex', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{lastFetchedIndex});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchAnnouncements_result;
use base qw(Class::Accessor);
TalkService_fetchAnnouncements_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchAnnouncements_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1631 = 0;
                                $self->{success} = [];
                                my $_etype1634 = 0;
                                $xfer += $input->readListBegin(\$_etype1634, \$_size1631);
                                for (my $_i1635 = 0; $_i1635 < $_size1631; ++$_i1635)
                                {
                                  my $elem1636 = undef;
                                  $elem1636 = Announcement->new();
                                  $xfer += $elem1636->read($input);
                                  push(@{$self->{success}},$elem1636);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchAnnouncements_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1637 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1637}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchMessages_args;
use base qw(Class::Accessor);
TalkService_fetchMessages_args->mk_accessors( qw( localTs count ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{localTs} = undef;
                        $self->{count} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{localTs}) {
                            $self->{localTs} = $vals->{localTs};
                          }
                          if (defined $vals->{count}) {
                            $self->{count} = $vals->{count};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchMessages_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{localTs});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{count});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchMessages_args');
                        if (defined $self->{localTs}) {
                          $xfer += $output->writeFieldBegin('localTs', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{localTs});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{count}) {
                          $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{count});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchMessages_result;
use base qw(Class::Accessor);
TalkService_fetchMessages_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchMessages_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1638 = 0;
                                $self->{success} = [];
                                my $_etype1641 = 0;
                                $xfer += $input->readListBegin(\$_etype1641, \$_size1638);
                                for (my $_i1642 = 0; $_i1642 < $_size1638; ++$_i1642)
                                {
                                  my $elem1643 = undef;
                                  $elem1643 = Message->new();
                                  $xfer += $elem1643->read($input);
                                  push(@{$self->{success}},$elem1643);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchMessages_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1644 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1644}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchOperations_args;
use base qw(Class::Accessor);
TalkService_fetchOperations_args->mk_accessors( qw( localRev count ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{localRev} = undef;
                        $self->{count} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{localRev}) {
                            $self->{localRev} = $vals->{localRev};
                          }
                          if (defined $vals->{count}) {
                            $self->{count} = $vals->{count};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchOperations_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{localRev});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{count});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchOperations_args');
                        if (defined $self->{localRev}) {
                          $xfer += $output->writeFieldBegin('localRev', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{localRev});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{count}) {
                          $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{count});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchOperations_result;
use base qw(Class::Accessor);
TalkService_fetchOperations_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchOperations_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1645 = 0;
                                $self->{success} = [];
                                my $_etype1648 = 0;
                                $xfer += $input->readListBegin(\$_etype1648, \$_size1645);
                                for (my $_i1649 = 0; $_i1649 < $_size1645; ++$_i1649)
                                {
                                  my $elem1650 = undef;
                                  $elem1650 = Operation->new();
                                  $xfer += $elem1650->read($input);
                                  push(@{$self->{success}},$elem1650);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = ShouldSyncException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchOperations_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1651 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1651}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchOps_args;
use base qw(Class::Accessor);
TalkService_fetchOps_args->mk_accessors( qw( localRev count globalRev individualRev ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{localRev} = undef;
                        $self->{count} = undef;
                        $self->{globalRev} = undef;
                        $self->{individualRev} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{localRev}) {
                            $self->{localRev} = $vals->{localRev};
                          }
                          if (defined $vals->{count}) {
                            $self->{count} = $vals->{count};
                          }
                          if (defined $vals->{globalRev}) {
                            $self->{globalRev} = $vals->{globalRev};
                          }
                          if (defined $vals->{individualRev}) {
                            $self->{individualRev} = $vals->{individualRev};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchOps_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{localRev});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{count});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{globalRev});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{individualRev});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchOps_args');
                        if (defined $self->{localRev}) {
                          $xfer += $output->writeFieldBegin('localRev', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{localRev});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{count}) {
                          $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{count});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{globalRev}) {
                          $xfer += $output->writeFieldBegin('globalRev', Thrift::TType::I64, 4);
                          $xfer += $output->writeI64($self->{globalRev});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{individualRev}) {
                          $xfer += $output->writeFieldBegin('individualRev', Thrift::TType::I64, 5);
                          $xfer += $output->writeI64($self->{individualRev});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_fetchOps_result;
use base qw(Class::Accessor);
TalkService_fetchOps_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_fetchOps_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1652 = 0;
                                $self->{success} = [];
                                my $_etype1655 = 0;
                                $xfer += $input->readListBegin(\$_etype1655, \$_size1652);
                                for (my $_i1656 = 0; $_i1656 < $_size1652; ++$_i1656)
                                {
                                  my $elem1657 = undef;
                                  $elem1657 = Operation->new();
                                  $xfer += $elem1657->read($input);
                                  push(@{$self->{success}},$elem1657);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = ShouldSyncException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_fetchOps_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1658 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1658}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByEmail_args;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByEmail_args->mk_accessors( qw( reqSeq emails ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{emails} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{emails}) {
                            $self->{emails} = $vals->{emails};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByEmail_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1659 = 0;
                                $self->{emails} = {};
                                my $_etype1662 = 0;
                                $xfer += $input->readSetBegin(\$_etype1662, \$_size1659);
                                for (my $_i1663 = 0; $_i1663 < $_size1659; ++$_i1663)
                                {
                                  my $elem1664 = undef;
                                  $xfer += $input->readString(\$elem1664);
                                  $self->{emails}->{$elem1664} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByEmail_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{emails}) {
                          $xfer += $output->writeFieldBegin('emails', Thrift::TType::SET, 2);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{emails}}));
                            {
                              foreach my $iter1665 (@{$self->{emails}})
                              {
                                $xfer += $output->writeString($iter1665);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByEmail_result;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByEmail_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByEmail_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1666 = 0;
                                $self->{success} = {};
                                my $_ktype1667 = 0;
                                my $_vtype1668 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1667, \$_vtype1668, \$_size1666);
                                for (my $_i1670 = 0; $_i1670 < $_size1666; ++$_i1670)
                                {
                                  my $key1671 = '';
                                  my $val1672 = new Contact();
                                  $xfer += $input->readString(\$key1671);
                                  $val1672 = Contact->new();
                                  $xfer += $val1672->read($input);
                                  $self->{success}->{$key1671} = $val1672;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByEmail_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1673,$viter1674) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1673);
                                $xfer += ${viter1674}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByMid_args;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByMid_args->mk_accessors( qw( reqSeq mid type reference ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{mid} = undef;
                        $self->{type} = undef;
                        $self->{reference} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{type}) {
                            $self->{type} = $vals->{type};
                          }
                          if (defined $vals->{reference}) {
                            $self->{reference} = $vals->{reference};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByMid_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{type});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{reference});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByMid_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{type}) {
                          $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{type});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{reference}) {
                          $xfer += $output->writeFieldBegin('reference', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{reference});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByMid_result;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByMid_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByMid_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1675 = 0;
                                $self->{success} = {};
                                my $_ktype1676 = 0;
                                my $_vtype1677 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1676, \$_vtype1677, \$_size1675);
                                for (my $_i1679 = 0; $_i1679 < $_size1675; ++$_i1679)
                                {
                                  my $key1680 = '';
                                  my $val1681 = new Contact();
                                  $xfer += $input->readString(\$key1680);
                                  $val1681 = Contact->new();
                                  $xfer += $val1681->read($input);
                                  $self->{success}->{$key1680} = $val1681;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByMid_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1682,$viter1683) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1682);
                                $xfer += ${viter1683}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findGroupByTicketV2_args;
use base qw(Class::Accessor);
TalkService_findGroupByTicketV2_args->mk_accessors( qw( ticketId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{ticketId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{ticketId}) {
                            $self->{ticketId} = $vals->{ticketId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findGroupByTicketV2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{ticketId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findGroupByTicketV2_args');
                        if (defined $self->{ticketId}) {
                          $xfer += $output->writeFieldBegin('ticketId', Thrift::TType::STRING, 1);
                          $xfer += $output->writeString($self->{ticketId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findGroupByTicketV2_result;
use base qw(Class::Accessor);
TalkService_findGroupByTicketV2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findGroupByTicketV2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Group->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findGroupByTicketV2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByPhone_args;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByPhone_args->mk_accessors( qw( reqSeq phones ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{phones} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{phones}) {
                            $self->{phones} = $vals->{phones};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByPhone_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1684 = 0;
                                $self->{phones} = {};
                                my $_etype1687 = 0;
                                $xfer += $input->readSetBegin(\$_etype1687, \$_size1684);
                                for (my $_i1688 = 0; $_i1688 < $_size1684; ++$_i1688)
                                {
                                  my $elem1689 = undef;
                                  $xfer += $input->readString(\$elem1689);
                                  $self->{phones}->{$elem1689} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByPhone_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{phones}) {
                          $xfer += $output->writeFieldBegin('phones', Thrift::TType::SET, 2);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{phones}}));
                            {
                              foreach my $iter1690 (@{$self->{phones}})
                              {
                                $xfer += $output->writeString($iter1690);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByPhone_result;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByPhone_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByPhone_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1691 = 0;
                                $self->{success} = {};
                                my $_ktype1692 = 0;
                                my $_vtype1693 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1692, \$_vtype1693, \$_size1691);
                                for (my $_i1695 = 0; $_i1695 < $_size1691; ++$_i1695)
                                {
                                  my $key1696 = '';
                                  my $val1697 = new Contact();
                                  $xfer += $input->readString(\$key1696);
                                  $val1697 = Contact->new();
                                  $xfer += $val1697->read($input);
                                  $self->{success}->{$key1696} = $val1697;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByPhone_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1698,$viter1699) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1698);
                                $xfer += ${viter1699}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getFriendRequests_args;
use base qw(Class::Accessor);
TalkService_getFriendRequests_args->mk_accessors( qw( direction lastSeenSeqId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{direction} = undef;
                        $self->{lastSeenSeqId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{direction}) {
                            $self->{direction} = $vals->{direction};
                          }
                          if (defined $vals->{lastSeenSeqId}) {
                            $self->{lastSeenSeqId} = $vals->{lastSeenSeqId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getFriendRequests_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{direction});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{lastSeenSeqId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getFriendRequests_args');
                        if (defined $self->{direction}) {
                          $xfer += $output->writeFieldBegin('direction', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{direction});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastSeenSeqId}) {
                          $xfer += $output->writeFieldBegin('lastSeenSeqId', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{lastSeenSeqId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getFriendRequests_result;
use base qw(Class::Accessor);
TalkService_getFriendRequests_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getFriendRequests_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1700 = 0;
                                $self->{success} = [];
                                my $_etype1703 = 0;
                                $xfer += $input->readListBegin(\$_etype1703, \$_size1700);
                                for (my $_i1704 = 0; $_i1704 < $_size1700; ++$_i1704)
                                {
                                  my $elem1705 = undef;
                                  $elem1705 = FriendRequest->new();
                                  $xfer += $elem1705->read($input);
                                  push(@{$self->{success}},$elem1705);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getFriendRequests_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1706 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1706}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeFriendRequest_args;
use base qw(Class::Accessor);
TalkService_removeFriendRequest_args->mk_accessors( qw( direction midOrEMid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{direction} = undef;
                        $self->{midOrEMid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{direction}) {
                            $self->{direction} = $vals->{direction};
                          }
                          if (defined $vals->{midOrEMid}) {
                            $self->{midOrEMid} = $vals->{midOrEMid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeFriendRequest_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{direction});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{midOrEMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeFriendRequest_args');
                        if (defined $self->{direction}) {
                          $xfer += $output->writeFieldBegin('direction', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{direction});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{midOrEMid}) {
                          $xfer += $output->writeFieldBegin('midOrEMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{midOrEMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeFriendRequest_result;
use base qw(Class::Accessor);
TalkService_removeFriendRequest_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeFriendRequest_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeFriendRequest_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByUserid_args;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByUserid_args->mk_accessors( qw( reqSeq userid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{userid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByUserid_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByUserid_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactsByUserid_result;
use base qw(Class::Accessor);
TalkService_findAndAddContactsByUserid_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactsByUserid_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1707 = 0;
                                $self->{success} = {};
                                my $_ktype1708 = 0;
                                my $_vtype1709 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1708, \$_vtype1709, \$_size1707);
                                for (my $_i1711 = 0; $_i1711 < $_size1707; ++$_i1711)
                                {
                                  my $key1712 = '';
                                  my $val1713 = new Contact();
                                  $xfer += $input->readString(\$key1712);
                                  $val1713 = Contact->new();
                                  $xfer += $val1713->read($input);
                                  $self->{success}->{$key1712} = $val1713;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactsByUserid_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1714,$viter1715) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1714);
                                $xfer += ${viter1715}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactByUserid_args;
use base qw(Class::Accessor);
TalkService_findContactByUserid_args->mk_accessors( qw( userid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{userid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactByUserid_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactByUserid_args');
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactByUserid_result;
use base qw(Class::Accessor);
TalkService_findContactByUserid_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactByUserid_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Contact->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactByUserid_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactByUserTicket_args;
use base qw(Class::Accessor);
TalkService_findContactByUserTicket_args->mk_accessors( qw( ticketIdWithTag ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{ticketIdWithTag} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{ticketIdWithTag}) {
                            $self->{ticketIdWithTag} = $vals->{ticketIdWithTag};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactByUserTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{ticketIdWithTag});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactByUserTicket_args');
                        if (defined $self->{ticketIdWithTag}) {
                          $xfer += $output->writeFieldBegin('ticketIdWithTag', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{ticketIdWithTag});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactByUserTicket_result;
use base qw(Class::Accessor);
TalkService_findContactByUserTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactByUserTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Contact->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactByUserTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactsByEmail_args;
use base qw(Class::Accessor);
TalkService_findContactsByEmail_args->mk_accessors( qw( emails ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{emails} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{emails}) {
                            $self->{emails} = $vals->{emails};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactsByEmail_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1716 = 0;
                                $self->{emails} = {};
                                my $_etype1719 = 0;
                                $xfer += $input->readSetBegin(\$_etype1719, \$_size1716);
                                for (my $_i1720 = 0; $_i1720 < $_size1716; ++$_i1720)
                                {
                                  my $elem1721 = undef;
                                  $xfer += $input->readString(\$elem1721);
                                  $self->{emails}->{$elem1721} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactsByEmail_args');
                        if (defined $self->{emails}) {
                          $xfer += $output->writeFieldBegin('emails', Thrift::TType::SET, 2);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{emails}}));
                            {
                              foreach my $iter1722 (@{$self->{emails}})
                              {
                                $xfer += $output->writeString($iter1722);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactsByEmail_result;
use base qw(Class::Accessor);
TalkService_findContactsByEmail_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactsByEmail_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1723 = 0;
                                $self->{success} = {};
                                my $_ktype1724 = 0;
                                my $_vtype1725 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1724, \$_vtype1725, \$_size1723);
                                for (my $_i1727 = 0; $_i1727 < $_size1723; ++$_i1727)
                                {
                                  my $key1728 = '';
                                  my $val1729 = new Contact();
                                  $xfer += $input->readString(\$key1728);
                                  $val1729 = Contact->new();
                                  $xfer += $val1729->read($input);
                                  $self->{success}->{$key1728} = $val1729;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactsByEmail_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1730,$viter1731) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1730);
                                $xfer += ${viter1731}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactsByPhone_args;
use base qw(Class::Accessor);
TalkService_findContactsByPhone_args->mk_accessors( qw( phones ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{phones} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{phones}) {
                            $self->{phones} = $vals->{phones};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactsByPhone_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1732 = 0;
                                $self->{phones} = {};
                                my $_etype1735 = 0;
                                $xfer += $input->readSetBegin(\$_etype1735, \$_size1732);
                                for (my $_i1736 = 0; $_i1736 < $_size1732; ++$_i1736)
                                {
                                  my $elem1737 = undef;
                                  $xfer += $input->readString(\$elem1737);
                                  $self->{phones}->{$elem1737} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactsByPhone_args');
                        if (defined $self->{phones}) {
                          $xfer += $output->writeFieldBegin('phones', Thrift::TType::SET, 2);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{phones}}));
                            {
                              foreach my $iter1738 (@{$self->{phones}})
                              {
                                $xfer += $output->writeString($iter1738);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactsByPhone_result;
use base qw(Class::Accessor);
TalkService_findContactsByPhone_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactsByPhone_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1739 = 0;
                                $self->{success} = {};
                                my $_ktype1740 = 0;
                                my $_vtype1741 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1740, \$_vtype1741, \$_size1739);
                                for (my $_i1743 = 0; $_i1743 < $_size1739; ++$_i1743)
                                {
                                  my $key1744 = '';
                                  my $val1745 = new Contact();
                                  $xfer += $input->readString(\$key1744);
                                  $val1745 = Contact->new();
                                  $xfer += $val1745->read($input);
                                  $self->{success}->{$key1744} = $val1745;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactsByPhone_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter1746,$viter1747) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter1746);
                                $xfer += ${viter1747}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findSnsIdUserStatus_args;
use base qw(Class::Accessor);
TalkService_findSnsIdUserStatus_args->mk_accessors( qw( snsIdType snsAccessToken udidHash ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{snsIdType} = undef;
                        $self->{snsAccessToken} = undef;
                        $self->{udidHash} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{snsIdType}) {
                            $self->{snsIdType} = $vals->{snsIdType};
                          }
                          if (defined $vals->{snsAccessToken}) {
                            $self->{snsAccessToken} = $vals->{snsAccessToken};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findSnsIdUserStatus_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{snsIdType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{snsAccessToken});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findSnsIdUserStatus_args');
                        if (defined $self->{snsIdType}) {
                          $xfer += $output->writeFieldBegin('snsIdType', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{snsIdType});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{snsAccessToken}) {
                          $xfer += $output->writeFieldBegin('snsAccessToken', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{snsAccessToken});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findSnsIdUserStatus_result;
use base qw(Class::Accessor);
TalkService_findSnsIdUserStatus_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findSnsIdUserStatus_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = SnsIdUserStatus->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findSnsIdUserStatus_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_finishUpdateVerification_args;
use base qw(Class::Accessor);
TalkService_finishUpdateVerification_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_finishUpdateVerification_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_finishUpdateVerification_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_finishUpdateVerification_result;
use base qw(Class::Accessor);
TalkService_finishUpdateVerification_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_finishUpdateVerification_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_finishUpdateVerification_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_generateUserTicket_args;
use base qw(Class::Accessor);
TalkService_generateUserTicket_args->mk_accessors( qw( expirationTime maxUseCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{expirationTime} = undef;
                        $self->{maxUseCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{expirationTime}) {
                            $self->{expirationTime} = $vals->{expirationTime};
                          }
                          if (defined $vals->{maxUseCount}) {
                            $self->{maxUseCount} = $vals->{maxUseCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_generateUserTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{expirationTime});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{maxUseCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_generateUserTicket_args');
                        if (defined $self->{expirationTime}) {
                          $xfer += $output->writeFieldBegin('expirationTime', Thrift::TType::I64, 3);
                          $xfer += $output->writeI64($self->{expirationTime});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{maxUseCount}) {
                          $xfer += $output->writeFieldBegin('maxUseCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{maxUseCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_generateUserTicket_result;
use base qw(Class::Accessor);
TalkService_generateUserTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_generateUserTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Ticket->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_generateUserTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_destroyMessage_args;
use base qw(Class::Accessor);
TalkService_destroyMessage_args->mk_accessors( qw( seq chatId messageId sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{chatId} = undef;
                        $self->{messageId} = undef;
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{chatId}) {
                            $self->{chatId} = $vals->{chatId};
                          }
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_destroyMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{chatId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_destroyMessage_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{chatId}) {
                          $xfer += $output->writeFieldBegin('chatId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{chatId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_destroyMessage_result;
use base qw(Class::Accessor);
TalkService_destroyMessage_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_destroyMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_destroyMessage_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAcceptedProximityMatches_args;
use base qw(Class::Accessor);
TalkService_getAcceptedProximityMatches_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAcceptedProximityMatches_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAcceptedProximityMatches_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAcceptedProximityMatches_result;
use base qw(Class::Accessor);
TalkService_getAcceptedProximityMatches_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAcceptedProximityMatches_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1748 = 0;
                                $self->{success} = {};
                                my $_etype1751 = 0;
                                $xfer += $input->readSetBegin(\$_etype1751, \$_size1748);
                                for (my $_i1752 = 0; $_i1752 < $_size1748; ++$_i1752)
                                {
                                  my $elem1753 = undef;
                                  $xfer += $input->readString(\$elem1753);
                                  $self->{success}->{$elem1753} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAcceptedProximityMatches_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::SET, 0);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1754 (@{$self->{success}})
                              {
                                $xfer += $output->writeString($iter1754);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getActiveBuddySubscriberIds_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getActiveBuddySubscriberIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getActiveBuddySubscriberIds_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getActiveBuddySubscriberIds_result;
use base qw(Class::Accessor);
TalkService_getActiveBuddySubscriberIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getActiveBuddySubscriberIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1755 = 0;
                                $self->{success} = [];
                                my $_etype1758 = 0;
                                $xfer += $input->readListBegin(\$_etype1758, \$_size1755);
                                for (my $_i1759 = 0; $_i1759 < $_size1755; ++$_i1759)
                                {
                                  my $elem1760 = undef;
                                  $xfer += $input->readString(\$elem1760);
                                  push(@{$self->{success}},$elem1760);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getActiveBuddySubscriberIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1761 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1761);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAllContactIds_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAllContactIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAllContactIds_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAllContactIds_result;
use base qw(Class::Accessor);
TalkService_getAllContactIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAllContactIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1762 = 0;
                                $self->{success} = [];
                                my $_etype1765 = 0;
                                $xfer += $input->readListBegin(\$_etype1765, \$_size1762);
                                for (my $_i1766 = 0; $_i1766 < $_size1762; ++$_i1766)
                                {
                                  my $elem1767 = undef;
                                  $xfer += $input->readString(\$elem1767);
                                  push(@{$self->{success}},$elem1767);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAllContactIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1768 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1768);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAuthQrcode_args;
use base qw(Class::Accessor);
TalkService_getAuthQrcode_args->mk_accessors( qw( keepLoggedIn systemName ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{keepLoggedIn} = undef;
                        $self->{systemName} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{keepLoggedIn}) {
                            $self->{keepLoggedIn} = $vals->{keepLoggedIn};
                          }
                          if (defined $vals->{systemName}) {
                            $self->{systemName} = $vals->{systemName};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAuthQrcode_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{keepLoggedIn});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{systemName});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAuthQrcode_args');
                        if (defined $self->{keepLoggedIn}) {
                          $xfer += $output->writeFieldBegin('keepLoggedIn', Thrift::TType::BOOL, 2);
                          $xfer += $output->writeBool($self->{keepLoggedIn});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{systemName}) {
                          $xfer += $output->writeFieldBegin('systemName', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{systemName});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAuthQrcode_result;
use base qw(Class::Accessor);
TalkService_getAuthQrcode_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAuthQrcode_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = AuthQrcode->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAuthQrcode_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBlockedContactIds_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBlockedContactIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBlockedContactIds_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBlockedContactIds_result;
use base qw(Class::Accessor);
TalkService_getBlockedContactIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBlockedContactIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1769 = 0;
                                $self->{success} = [];
                                my $_etype1772 = 0;
                                $xfer += $input->readListBegin(\$_etype1772, \$_size1769);
                                for (my $_i1773 = 0; $_i1773 < $_size1769; ++$_i1773)
                                {
                                  my $elem1774 = undef;
                                  $xfer += $input->readString(\$elem1774);
                                  push(@{$self->{success}},$elem1774);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBlockedContactIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1775 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1775);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithPhoneNumber_args;
use base qw(Class::Accessor);
TalkService_registerWithPhoneNumber_args->mk_accessors( qw( sessionId migrationPincodeSessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{migrationPincodeSessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{migrationPincodeSessionId}) {
                            $self->{migrationPincodeSessionId} = $vals->{migrationPincodeSessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithPhoneNumber_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{migrationPincodeSessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithPhoneNumber_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{migrationPincodeSessionId}) {
                          $xfer += $output->writeFieldBegin('migrationPincodeSessionId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{migrationPincodeSessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithPhoneNumber_result;
use base qw(Class::Accessor);
TalkService_registerWithPhoneNumber_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithPhoneNumber_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = RegisterWithPhoneNumberResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithPhoneNumber_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithPhoneNumberAndPassword_args;
use base qw(Class::Accessor);
TalkService_registerWithPhoneNumberAndPassword_args->mk_accessors( qw( sessionId keynm encrypted ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{keynm} = undef;
                        $self->{encrypted} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{keynm}) {
                            $self->{keynm} = $vals->{keynm};
                          }
                          if (defined $vals->{encrypted}) {
                            $self->{encrypted} = $vals->{encrypted};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithPhoneNumberAndPassword_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{keynm});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{encrypted});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithPhoneNumberAndPassword_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{keynm}) {
                          $xfer += $output->writeFieldBegin('keynm', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{keynm});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{encrypted}) {
                          $xfer += $output->writeFieldBegin('encrypted', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{encrypted});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithPhoneNumberAndPassword_result;
use base qw(Class::Accessor);
TalkService_registerWithPhoneNumberAndPassword_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithPhoneNumberAndPassword_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = RegisterWithPhoneNumberResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithPhoneNumberAndPassword_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAnalyticsInfo_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAnalyticsInfo_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAnalyticsInfo_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getAnalyticsInfo_result;
use base qw(Class::Accessor);
TalkService_getAnalyticsInfo_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getAnalyticsInfo_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = AnalyticsInfo->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getAnalyticsInfo_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportClientStatistics_args;
use base qw(Class::Accessor);
TalkService_reportClientStatistics_args->mk_accessors( qw( reqSeq category count ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{category} = undef;
                        $self->{count} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{category}) {
                            $self->{category} = $vals->{category};
                          }
                          if (defined $vals->{count}) {
                            $self->{count} = $vals->{count};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportClientStatistics_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{category});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{count});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportClientStatistics_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{category}) {
                          $xfer += $output->writeFieldBegin('category', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{category});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{count}) {
                          $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{count});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportClientStatistics_result;
use base qw(Class::Accessor);
TalkService_reportClientStatistics_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportClientStatistics_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportClientStatistics_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyPhoneNumberForLogin_args;
use base qw(Class::Accessor);
TalkService_verifyPhoneNumberForLogin_args->mk_accessors( qw( verifierFromPhone pinCodeForPhone verifierFromLogin ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifierFromPhone} = undef;
                        $self->{pinCodeForPhone} = undef;
                        $self->{verifierFromLogin} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifierFromPhone}) {
                            $self->{verifierFromPhone} = $vals->{verifierFromPhone};
                          }
                          if (defined $vals->{pinCodeForPhone}) {
                            $self->{pinCodeForPhone} = $vals->{pinCodeForPhone};
                          }
                          if (defined $vals->{verifierFromLogin}) {
                            $self->{verifierFromLogin} = $vals->{verifierFromLogin};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyPhoneNumberForLogin_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifierFromPhone});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{pinCodeForPhone});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifierFromLogin});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyPhoneNumberForLogin_args');
                        if (defined $self->{verifierFromPhone}) {
                          $xfer += $output->writeFieldBegin('verifierFromPhone', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{verifierFromPhone});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{pinCodeForPhone}) {
                          $xfer += $output->writeFieldBegin('pinCodeForPhone', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{pinCodeForPhone});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{verifierFromLogin}) {
                          $xfer += $output->writeFieldBegin('verifierFromLogin', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{verifierFromLogin});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyPhoneNumberForLogin_result;
use base qw(Class::Accessor);
TalkService_verifyPhoneNumberForLogin_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyPhoneNumberForLogin_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyPhoneNumberForLogin_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyPhoneNumber_args;
use base qw(Class::Accessor);
TalkService_verifyPhoneNumber_args->mk_accessors( qw( sessionId pinCode udidHash migrationPincodeSessionId oldUdidHash ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{pinCode} = undef;
                        $self->{udidHash} = undef;
                        $self->{migrationPincodeSessionId} = undef;
                        $self->{oldUdidHash} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{pinCode}) {
                            $self->{pinCode} = $vals->{pinCode};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{migrationPincodeSessionId}) {
                            $self->{migrationPincodeSessionId} = $vals->{migrationPincodeSessionId};
                          }
                          if (defined $vals->{oldUdidHash}) {
                            $self->{oldUdidHash} = $vals->{oldUdidHash};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyPhoneNumber_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{pinCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{migrationPincodeSessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{oldUdidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyPhoneNumber_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{pinCode}) {
                          $xfer += $output->writeFieldBegin('pinCode', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{pinCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{migrationPincodeSessionId}) {
                          $xfer += $output->writeFieldBegin('migrationPincodeSessionId', Thrift::TType::STRING, 5);
                          $xfer += $output->writeString($self->{migrationPincodeSessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{oldUdidHash}) {
                          $xfer += $output->writeFieldBegin('oldUdidHash', Thrift::TType::STRING, 6);
                          $xfer += $output->writeString($self->{oldUdidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyPhoneNumber_result;
use base qw(Class::Accessor);
TalkService_verifyPhoneNumber_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyPhoneNumber_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = PhoneVerificationResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyPhoneNumber_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBlockedContactIdsByRange_args;
use base qw(Class::Accessor);
TalkService_getBlockedContactIdsByRange_args->mk_accessors( qw( start count ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{start} = undef;
                        $self->{count} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{start}) {
                            $self->{start} = $vals->{start};
                          }
                          if (defined $vals->{count}) {
                            $self->{count} = $vals->{count};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBlockedContactIdsByRange_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{start});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{count});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBlockedContactIdsByRange_args');
                        if (defined $self->{start}) {
                          $xfer += $output->writeFieldBegin('start', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{start});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{count}) {
                          $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{count});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBlockedContactIdsByRange_result;
use base qw(Class::Accessor);
TalkService_getBlockedContactIdsByRange_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBlockedContactIdsByRange_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1776 = 0;
                                $self->{success} = [];
                                my $_etype1779 = 0;
                                $xfer += $input->readListBegin(\$_etype1779, \$_size1776);
                                for (my $_i1780 = 0; $_i1780 < $_size1776; ++$_i1780)
                                {
                                  my $elem1781 = undef;
                                  $xfer += $input->readString(\$elem1781);
                                  push(@{$self->{success}},$elem1781);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBlockedContactIdsByRange_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1782 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1782);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBlockedRecommendationIds_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBlockedRecommendationIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBlockedRecommendationIds_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBlockedRecommendationIds_result;
use base qw(Class::Accessor);
TalkService_getBlockedRecommendationIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBlockedRecommendationIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1783 = 0;
                                $self->{success} = [];
                                my $_etype1786 = 0;
                                $xfer += $input->readListBegin(\$_etype1786, \$_size1783);
                                for (my $_i1787 = 0; $_i1787 < $_size1783; ++$_i1787)
                                {
                                  my $elem1788 = undef;
                                  $xfer += $input->readString(\$elem1788);
                                  push(@{$self->{success}},$elem1788);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBlockedRecommendationIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1789 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1789);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBuddyBlockerIds_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBuddyBlockerIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBuddyBlockerIds_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBuddyBlockerIds_result;
use base qw(Class::Accessor);
TalkService_getBuddyBlockerIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBuddyBlockerIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1790 = 0;
                                $self->{success} = [];
                                my $_etype1793 = 0;
                                $xfer += $input->readListBegin(\$_etype1793, \$_size1790);
                                for (my $_i1794 = 0; $_i1794 < $_size1790; ++$_i1794)
                                {
                                  my $elem1795 = undef;
                                  $xfer += $input->readString(\$elem1795);
                                  push(@{$self->{success}},$elem1795);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBuddyBlockerIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1796 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1796);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBuddyLocation_args;
use base qw(Class::Accessor);
TalkService_getBuddyLocation_args->mk_accessors( qw( mid index ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        $self->{index} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{index}) {
                            $self->{index} = $vals->{index};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBuddyLocation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{index});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBuddyLocation_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{index}) {
                          $xfer += $output->writeFieldBegin('index', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{index});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getBuddyLocation_result;
use base qw(Class::Accessor);
TalkService_getBuddyLocation_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getBuddyLocation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Geolocation->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getBuddyLocation_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCompactContactsModifiedSince_args;
use base qw(Class::Accessor);
TalkService_getCompactContactsModifiedSince_args->mk_accessors( qw( timestamp ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{timestamp} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{timestamp}) {
                            $self->{timestamp} = $vals->{timestamp};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCompactContactsModifiedSince_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{timestamp});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCompactContactsModifiedSince_args');
                        if (defined $self->{timestamp}) {
                          $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{timestamp});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCompactContactsModifiedSince_result;
use base qw(Class::Accessor);
TalkService_getCompactContactsModifiedSince_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCompactContactsModifiedSince_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1797 = 0;
                                $self->{success} = [];
                                my $_etype1800 = 0;
                                $xfer += $input->readListBegin(\$_etype1800, \$_size1797);
                                for (my $_i1801 = 0; $_i1801 < $_size1797; ++$_i1801)
                                {
                                  my $elem1802 = undef;
                                  $elem1802 = CompactContact->new();
                                  $xfer += $elem1802->read($input);
                                  push(@{$self->{success}},$elem1802);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCompactContactsModifiedSince_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1803 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1803}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCompactGroup_args;
use base qw(Class::Accessor);
TalkService_getCompactGroup_args->mk_accessors( qw( groupId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{groupId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCompactGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCompactGroup_args');
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCompactGroup_result;
use base qw(Class::Accessor);
TalkService_getCompactGroup_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCompactGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Group->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCompactGroup_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCompactRoom_args;
use base qw(Class::Accessor);
TalkService_getCompactRoom_args->mk_accessors( qw( roomId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{roomId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{roomId}) {
                            $self->{roomId} = $vals->{roomId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCompactRoom_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{roomId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCompactRoom_args');
                        if (defined $self->{roomId}) {
                          $xfer += $output->writeFieldBegin('roomId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{roomId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCompactRoom_result;
use base qw(Class::Accessor);
TalkService_getCompactRoom_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCompactRoom_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Room->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCompactRoom_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getContact_args;
use base qw(Class::Accessor);
TalkService_getContact_args->mk_accessors( qw( id ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{id} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{id}) {
                            $self->{id} = $vals->{id};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getContact_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{id});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getContact_args');
                        if (defined $self->{id}) {
                          $xfer += $output->writeFieldBegin('id', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{id});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getContact_result;
use base qw(Class::Accessor);
TalkService_getContact_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getContact_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Contact->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getContact_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getContacts_args;
use base qw(Class::Accessor);
TalkService_getContacts_args->mk_accessors( qw( ids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{ids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{ids}) {
                            $self->{ids} = $vals->{ids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getContacts_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1804 = 0;
                                $self->{ids} = [];
                                my $_etype1807 = 0;
                                $xfer += $input->readListBegin(\$_etype1807, \$_size1804);
                                for (my $_i1808 = 0; $_i1808 < $_size1804; ++$_i1808)
                                {
                                  my $elem1809 = undef;
                                  $xfer += $input->readString(\$elem1809);
                                  push(@{$self->{ids}},$elem1809);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getContacts_args');
                        if (defined $self->{ids}) {
                          $xfer += $output->writeFieldBegin('ids', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{ids}}));
                            {
                              foreach my $iter1810 (@{$self->{ids}}) 
                              {
                                $xfer += $output->writeString($iter1810);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getContacts_result;
use base qw(Class::Accessor);
TalkService_getContacts_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getContacts_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1811 = 0;
                                $self->{success} = [];
                                my $_etype1814 = 0;
                                $xfer += $input->readListBegin(\$_etype1814, \$_size1811);
                                for (my $_i1815 = 0; $_i1815 < $_size1811; ++$_i1815)
                                {
                                  my $elem1816 = undef;
                                  $elem1816 = Contact->new();
                                  $xfer += $elem1816->read($input);
                                  push(@{$self->{success}},$elem1816);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getContacts_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1817 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1817}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getContactWithFriendRequestStatus_args;
use base qw(Class::Accessor);
TalkService_getContactWithFriendRequestStatus_args->mk_accessors( qw( id ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{id} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{id}) {
                            $self->{id} = $vals->{id};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getContactWithFriendRequestStatus_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{id});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getContactWithFriendRequestStatus_args');
                        if (defined $self->{id}) {
                          $xfer += $output->writeFieldBegin('id', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{id});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getContactWithFriendRequestStatus_result;
use base qw(Class::Accessor);
TalkService_getContactWithFriendRequestStatus_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getContactWithFriendRequestStatus_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Contact->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getContactWithFriendRequestStatus_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCountryWithRequestIp_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCountryWithRequestIp_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCountryWithRequestIp_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getCountryWithRequestIp_result;
use base qw(Class::Accessor);
TalkService_getCountryWithRequestIp_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getCountryWithRequestIp_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getCountryWithRequestIp_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getFavoriteMids_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getFavoriteMids_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getFavoriteMids_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getFavoriteMids_result;
use base qw(Class::Accessor);
TalkService_getFavoriteMids_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getFavoriteMids_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1818 = 0;
                                $self->{success} = [];
                                my $_etype1821 = 0;
                                $xfer += $input->readListBegin(\$_etype1821, \$_size1818);
                                for (my $_i1822 = 0; $_i1822 < $_size1818; ++$_i1822)
                                {
                                  my $elem1823 = undef;
                                  $xfer += $input->readString(\$elem1823);
                                  push(@{$self->{success}},$elem1823);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getFavoriteMids_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1824 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1824);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroup_args;
use base qw(Class::Accessor);
TalkService_getGroup_args->mk_accessors( qw( groupId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{groupId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroup_args');
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroup_result;
use base qw(Class::Accessor);
TalkService_getGroup_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Group->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroup_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupIdsInvited_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupIdsInvited_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupIdsInvited_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupIdsInvited_result;
use base qw(Class::Accessor);
TalkService_getGroupIdsInvited_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupIdsInvited_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1825 = 0;
                                $self->{success} = [];
                                my $_etype1828 = 0;
                                $xfer += $input->readListBegin(\$_etype1828, \$_size1825);
                                for (my $_i1829 = 0; $_i1829 < $_size1825; ++$_i1829)
                                {
                                  my $elem1830 = undef;
                                  $xfer += $input->readString(\$elem1830);
                                  push(@{$self->{success}},$elem1830);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupIdsInvited_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1831 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1831);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupIdsJoined_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupIdsJoined_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupIdsJoined_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupIdsJoined_result;
use base qw(Class::Accessor);
TalkService_getGroupIdsJoined_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupIdsJoined_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1832 = 0;
                                $self->{success} = [];
                                my $_etype1835 = 0;
                                $xfer += $input->readListBegin(\$_etype1835, \$_size1832);
                                for (my $_i1836 = 0; $_i1836 < $_size1832; ++$_i1836)
                                {
                                  my $elem1837 = undef;
                                  $xfer += $input->readString(\$elem1837);
                                  push(@{$self->{success}},$elem1837);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupIdsJoined_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1838 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1838);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroups_args;
use base qw(Class::Accessor);
TalkService_getGroups_args->mk_accessors( qw( groupIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{groupIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{groupIds}) {
                            $self->{groupIds} = $vals->{groupIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroups_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1839 = 0;
                                $self->{groupIds} = [];
                                my $_etype1842 = 0;
                                $xfer += $input->readListBegin(\$_etype1842, \$_size1839);
                                for (my $_i1843 = 0; $_i1843 < $_size1839; ++$_i1843)
                                {
                                  my $elem1844 = undef;
                                  $xfer += $input->readString(\$elem1844);
                                  push(@{$self->{groupIds}},$elem1844);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroups_args');
                        if (defined $self->{groupIds}) {
                          $xfer += $output->writeFieldBegin('groupIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{groupIds}}));
                            {
                              foreach my $iter1845 (@{$self->{groupIds}}) 
                              {
                                $xfer += $output->writeString($iter1845);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroups_result;
use base qw(Class::Accessor);
TalkService_getGroups_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroups_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1846 = 0;
                                $self->{success} = [];
                                my $_etype1849 = 0;
                                $xfer += $input->readListBegin(\$_etype1849, \$_size1846);
                                for (my $_i1850 = 0; $_i1850 < $_size1846; ++$_i1850)
                                {
                                  my $elem1851 = undef;
                                  $elem1851 = Group->new();
                                  $xfer += $elem1851->read($input);
                                  push(@{$self->{success}},$elem1851);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroups_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1852 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1852}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getHiddenContactMids_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getHiddenContactMids_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getHiddenContactMids_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getHiddenContactMids_result;
use base qw(Class::Accessor);
TalkService_getHiddenContactMids_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getHiddenContactMids_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1853 = 0;
                                $self->{success} = [];
                                my $_etype1856 = 0;
                                $xfer += $input->readListBegin(\$_etype1856, \$_size1853);
                                for (my $_i1857 = 0; $_i1857 < $_size1853; ++$_i1857)
                                {
                                  my $elem1858 = undef;
                                  $xfer += $input->readString(\$elem1858);
                                  push(@{$self->{success}},$elem1858);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getHiddenContactMids_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1859 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1859);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getIdentityIdentifier_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getIdentityIdentifier_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getIdentityIdentifier_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getIdentityIdentifier_result;
use base qw(Class::Accessor);
TalkService_getIdentityIdentifier_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getIdentityIdentifier_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getIdentityIdentifier_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getLastAnnouncementIndex_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getLastAnnouncementIndex_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getLastAnnouncementIndex_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getLastAnnouncementIndex_result;
use base qw(Class::Accessor);
TalkService_getLastAnnouncementIndex_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getLastAnnouncementIndex_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getLastAnnouncementIndex_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
                          $xfer += $output->writeI32($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getLastOpRevision_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getLastOpRevision_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getLastOpRevision_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getLastOpRevision_result;
use base qw(Class::Accessor);
TalkService_getLastOpRevision_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getLastOpRevision_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getLastOpRevision_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
                          $xfer += $output->writeI64($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSuggestRevisions_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSuggestRevisions_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSuggestRevisions_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSuggestRevisions_result;
use base qw(Class::Accessor);
TalkService_getSuggestRevisions_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSuggestRevisions_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = SuggestDictionaryRevisions->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSuggestRevisions_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getPreviousMessagesV2WithReadCount_args;
use base qw(Class::Accessor);
TalkService_getPreviousMessagesV2WithReadCount_args->mk_accessors( qw( messageBoxId endMessageId messagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        $self->{endMessageId} = undef;
                        $self->{messagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{endMessageId}) {
                            $self->{endMessageId} = $vals->{endMessageId};
                          }
                          if (defined $vals->{messagesCount}) {
                            $self->{messagesCount} = $vals->{messagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getPreviousMessagesV2WithReadCount_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{endMessageId} = MessageBoxV2MessageId->new();
                              $xfer += $self->{endMessageId}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getPreviousMessagesV2WithReadCount_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{endMessageId}) {
                          $xfer += $output->writeFieldBegin('endMessageId', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{endMessageId}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messagesCount}) {
                          $xfer += $output->writeFieldBegin('messagesCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{messagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getPreviousMessagesV2WithReadCount_result;
use base qw(Class::Accessor);
TalkService_getPreviousMessagesV2WithReadCount_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getPreviousMessagesV2WithReadCount_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1860 = 0;
                                $self->{success} = [];
                                my $_etype1863 = 0;
                                $xfer += $input->readListBegin(\$_etype1863, \$_size1860);
                                for (my $_i1864 = 0; $_i1864 < $_size1860; ++$_i1864)
                                {
                                  my $elem1865 = undef;
                                  $elem1865 = Message->new();
                                  $xfer += $elem1865->read($input);
                                  push(@{$self->{success}},$elem1865);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getPreviousMessagesV2WithReadCount_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1866 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1866}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBox_args;
use base qw(Class::Accessor);
TalkService_getMessageBox_args->mk_accessors( qw( channelId messageBoxId lastMessagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{channelId} = undef;
                        $self->{messageBoxId} = undef;
                        $self->{lastMessagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{channelId}) {
                            $self->{channelId} = $vals->{channelId};
                          }
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{lastMessagesCount}) {
                            $self->{lastMessagesCount} = $vals->{lastMessagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBox_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{channelId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{lastMessagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBox_args');
                        if (defined $self->{channelId}) {
                          $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{channelId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastMessagesCount}) {
                          $xfer += $output->writeFieldBegin('lastMessagesCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{lastMessagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBox_result;
use base qw(Class::Accessor);
TalkService_getMessageBox_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBox_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = TMessageBox->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBox_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxCompactWrapUp_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxCompactWrapUp_args->mk_accessors( qw( mid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxCompactWrapUp_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxCompactWrapUp_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxCompactWrapUp_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxCompactWrapUp_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxCompactWrapUp_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = TMessageBoxWrapUp->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxCompactWrapUp_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxCompactWrapUpList_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxCompactWrapUpList_args->mk_accessors( qw( start messageBoxCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{start} = undef;
                        $self->{messageBoxCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{start}) {
                            $self->{start} = $vals->{start};
                          }
                          if (defined $vals->{messageBoxCount}) {
                            $self->{messageBoxCount} = $vals->{messageBoxCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxCompactWrapUpList_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{start});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messageBoxCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxCompactWrapUpList_args');
                        if (defined $self->{start}) {
                          $xfer += $output->writeFieldBegin('start', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{start});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageBoxCount}) {
                          $xfer += $output->writeFieldBegin('messageBoxCount', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{messageBoxCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxCompactWrapUpList_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxCompactWrapUpList_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxCompactWrapUpList_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = TMessageBoxWrapUpResponse->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxCompactWrapUpList_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxList_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxList_args->mk_accessors( qw( channelId lastMessagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{channelId} = undef;
                        $self->{lastMessagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{channelId}) {
                            $self->{channelId} = $vals->{channelId};
                          }
                          if (defined $vals->{lastMessagesCount}) {
                            $self->{lastMessagesCount} = $vals->{lastMessagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxList_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{channelId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{lastMessagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxList_args');
                        if (defined $self->{channelId}) {
                          $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{channelId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastMessagesCount}) {
                          $xfer += $output->writeFieldBegin('lastMessagesCount', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{lastMessagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxList_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxList_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxList_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1867 = 0;
                                $self->{success} = [];
                                my $_etype1870 = 0;
                                $xfer += $input->readListBegin(\$_etype1870, \$_size1867);
                                for (my $_i1871 = 0; $_i1871 < $_size1867; ++$_i1871)
                                {
                                  my $elem1872 = undef;
                                  $elem1872 = TMessageBox->new();
                                  $xfer += $elem1872->read($input);
                                  push(@{$self->{success}},$elem1872);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxList_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1873 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1873}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxListByStatus_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxListByStatus_args->mk_accessors( qw( channelId lastMessagesCount status ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{channelId} = undef;
                        $self->{lastMessagesCount} = undef;
                        $self->{status} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{channelId}) {
                            $self->{channelId} = $vals->{channelId};
                          }
                          if (defined $vals->{lastMessagesCount}) {
                            $self->{lastMessagesCount} = $vals->{lastMessagesCount};
                          }
                          if (defined $vals->{status}) {
                            $self->{status} = $vals->{status};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxListByStatus_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{channelId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{lastMessagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{status});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxListByStatus_args');
                        if (defined $self->{channelId}) {
                          $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{channelId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastMessagesCount}) {
                          $xfer += $output->writeFieldBegin('lastMessagesCount', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{lastMessagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{status}) {
                          $xfer += $output->writeFieldBegin('status', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{status});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxListByStatus_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxListByStatus_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxListByStatus_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1874 = 0;
                                $self->{success} = [];
                                my $_etype1877 = 0;
                                $xfer += $input->readListBegin(\$_etype1877, \$_size1874);
                                for (my $_i1878 = 0; $_i1878 < $_size1874; ++$_i1878)
                                {
                                  my $elem1879 = undef;
                                  $elem1879 = TMessageBox->new();
                                  $xfer += $elem1879->read($input);
                                  push(@{$self->{success}},$elem1879);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxListByStatus_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1880 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1880}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxWrapUp_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxWrapUp_args->mk_accessors( qw( mid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxWrapUp_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxWrapUp_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxWrapUp_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxWrapUp_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxWrapUp_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = TMessageBoxWrapUp->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxWrapUp_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxWrapUpList_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxWrapUpList_args->mk_accessors( qw( start messageBoxCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{start} = undef;
                        $self->{messageBoxCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{start}) {
                            $self->{start} = $vals->{start};
                          }
                          if (defined $vals->{messageBoxCount}) {
                            $self->{messageBoxCount} = $vals->{messageBoxCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxWrapUpList_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{start});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messageBoxCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxWrapUpList_args');
                        if (defined $self->{start}) {
                          $xfer += $output->writeFieldBegin('start', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{start});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageBoxCount}) {
                          $xfer += $output->writeFieldBegin('messageBoxCount', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{messageBoxCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxWrapUpList_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxWrapUpList_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxWrapUpList_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = TMessageBoxWrapUpResponse->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxWrapUpList_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessagesBySequenceNumber_args;
use base qw(Class::Accessor);
TalkService_getMessagesBySequenceNumber_args->mk_accessors( qw( channelId messageBoxId startSeq endSeq ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{channelId} = undef;
                        $self->{messageBoxId} = undef;
                        $self->{startSeq} = undef;
                        $self->{endSeq} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{channelId}) {
                            $self->{channelId} = $vals->{channelId};
                          }
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{startSeq}) {
                            $self->{startSeq} = $vals->{startSeq};
                          }
                          if (defined $vals->{endSeq}) {
                            $self->{endSeq} = $vals->{endSeq};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessagesBySequenceNumber_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{channelId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{startSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{endSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessagesBySequenceNumber_args');
                        if (defined $self->{channelId}) {
                          $xfer += $output->writeFieldBegin('channelId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{channelId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{startSeq}) {
                          $xfer += $output->writeFieldBegin('startSeq', Thrift::TType::I64, 4);
                          $xfer += $output->writeI64($self->{startSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{endSeq}) {
                          $xfer += $output->writeFieldBegin('endSeq', Thrift::TType::I64, 5);
                          $xfer += $output->writeI64($self->{endSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessagesBySequenceNumber_result;
use base qw(Class::Accessor);
TalkService_getMessagesBySequenceNumber_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessagesBySequenceNumber_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1881 = 0;
                                $self->{success} = [];
                                my $_etype1884 = 0;
                                $xfer += $input->readListBegin(\$_etype1884, \$_size1881);
                                for (my $_i1885 = 0; $_i1885 < $_size1881; ++$_i1885)
                                {
                                  my $elem1886 = undef;
                                  $elem1886 = Message->new();
                                  $xfer += $elem1886->read($input);
                                  push(@{$self->{success}},$elem1886);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessagesBySequenceNumber_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1887 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1887}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getNextMessages_args;
use base qw(Class::Accessor);
TalkService_getNextMessages_args->mk_accessors( qw( messageBoxId startSeq messagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        $self->{startSeq} = undef;
                        $self->{messagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{startSeq}) {
                            $self->{startSeq} = $vals->{startSeq};
                          }
                          if (defined $vals->{messagesCount}) {
                            $self->{messagesCount} = $vals->{messagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getNextMessages_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{startSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getNextMessages_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{startSeq}) {
                          $xfer += $output->writeFieldBegin('startSeq', Thrift::TType::I64, 3);
                          $xfer += $output->writeI64($self->{startSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messagesCount}) {
                          $xfer += $output->writeFieldBegin('messagesCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{messagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getNextMessages_result;
use base qw(Class::Accessor);
TalkService_getNextMessages_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getNextMessages_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1888 = 0;
                                $self->{success} = [];
                                my $_etype1891 = 0;
                                $xfer += $input->readListBegin(\$_etype1891, \$_size1888);
                                for (my $_i1892 = 0; $_i1892 < $_size1888; ++$_i1892)
                                {
                                  my $elem1893 = undef;
                                  $elem1893 = Message->new();
                                  $xfer += $elem1893->read($input);
                                  push(@{$self->{success}},$elem1893);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getNextMessages_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1894 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1894}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getNotificationPolicy_args;
use base qw(Class::Accessor);
TalkService_getNotificationPolicy_args->mk_accessors( qw( carrier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{carrier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{carrier}) {
                            $self->{carrier} = $vals->{carrier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getNotificationPolicy_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{carrier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getNotificationPolicy_args');
                        if (defined $self->{carrier}) {
                          $xfer += $output->writeFieldBegin('carrier', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{carrier});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getNotificationPolicy_result;
use base qw(Class::Accessor);
TalkService_getNotificationPolicy_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getNotificationPolicy_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1895 = 0;
                                $self->{success} = [];
                                my $_etype1898 = 0;
                                $xfer += $input->readListBegin(\$_etype1898, \$_size1895);
                                for (my $_i1899 = 0; $_i1899 < $_size1895; ++$_i1899)
                                {
                                  my $elem1900 = undef;
                                  $xfer += $input->readI32(\$elem1900);
                                  push(@{$self->{success}},$elem1900);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getNotificationPolicy_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1901 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeI32($iter1901);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getPreviousMessages_args;
use base qw(Class::Accessor);
TalkService_getPreviousMessages_args->mk_accessors( qw( messageBoxId endSeq messagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        $self->{endSeq} = undef;
                        $self->{messagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{endSeq}) {
                            $self->{endSeq} = $vals->{endSeq};
                          }
                          if (defined $vals->{messagesCount}) {
                            $self->{messagesCount} = $vals->{messagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getPreviousMessages_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{endSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getPreviousMessages_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{endSeq}) {
                          $xfer += $output->writeFieldBegin('endSeq', Thrift::TType::I64, 3);
                          $xfer += $output->writeI64($self->{endSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messagesCount}) {
                          $xfer += $output->writeFieldBegin('messagesCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{messagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getPreviousMessages_result;
use base qw(Class::Accessor);
TalkService_getPreviousMessages_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getPreviousMessages_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1902 = 0;
                                $self->{success} = [];
                                my $_etype1905 = 0;
                                $xfer += $input->readListBegin(\$_etype1905, \$_size1902);
                                for (my $_i1906 = 0; $_i1906 < $_size1902; ++$_i1906)
                                {
                                  my $elem1907 = undef;
                                  $elem1907 = Message->new();
                                  $xfer += $elem1907->read($input);
                                  push(@{$self->{success}},$elem1907);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getPreviousMessages_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1908 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1908}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getProfile_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getProfile_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getProfile_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getProfile_result;
use base qw(Class::Accessor);
TalkService_getProfile_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getProfile_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Profile->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getProfile_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getProximityMatchCandidateList_args;
use base qw(Class::Accessor);
TalkService_getProximityMatchCandidateList_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getProximityMatchCandidateList_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getProximityMatchCandidateList_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getProximityMatchCandidateList_result;
use base qw(Class::Accessor);
TalkService_getProximityMatchCandidateList_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getProximityMatchCandidateList_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = ProximityMatchCandidateResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getProximityMatchCandidateList_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getProximityMatchCandidates_args;
use base qw(Class::Accessor);
TalkService_getProximityMatchCandidates_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getProximityMatchCandidates_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getProximityMatchCandidates_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getProximityMatchCandidates_result;
use base qw(Class::Accessor);
TalkService_getProximityMatchCandidates_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getProximityMatchCandidates_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::SET) {
                              {
                                my $_size1909 = 0;
                                $self->{success} = {};
                                my $_etype1912 = 0;
                                $xfer += $input->readSetBegin(\$_etype1912, \$_size1909);
                                for (my $_i1913 = 0; $_i1913 < $_size1909; ++$_i1913)
                                {
                                  my $elem1914 = undef;
                                  $elem1914 = Contact->new();
                                  $xfer += $elem1914->read($input);
                                  $self->{success}->{$elem1914} = 1;
                                }
                                $xfer += $input->readSetEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getProximityMatchCandidates_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::SET, 0);
                          {
                            $xfer += $output->writeSetBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1915 (@{$self->{success}})
                              {
                                $xfer += ${iter1915}->write($output);
                              }
                            }
                            $xfer += $output->writeSetEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRecentMessages_args;
use base qw(Class::Accessor);
TalkService_getRecentMessages_args->mk_accessors( qw( messageBoxId messagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        $self->{messagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{messagesCount}) {
                            $self->{messagesCount} = $vals->{messagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRecentMessages_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRecentMessages_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messagesCount}) {
                          $xfer += $output->writeFieldBegin('messagesCount', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{messagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRecentMessages_result;
use base qw(Class::Accessor);
TalkService_getRecentMessages_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRecentMessages_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1916 = 0;
                                $self->{success} = [];
                                my $_etype1919 = 0;
                                $xfer += $input->readListBegin(\$_etype1919, \$_size1916);
                                for (my $_i1920 = 0; $_i1920 < $_size1916; ++$_i1920)
                                {
                                  my $elem1921 = undef;
                                  $elem1921 = Message->new();
                                  $xfer += $elem1921->read($input);
                                  push(@{$self->{success}},$elem1921);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRecentMessages_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1922 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1922}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRecommendationIds_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRecommendationIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRecommendationIds_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRecommendationIds_result;
use base qw(Class::Accessor);
TalkService_getRecommendationIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRecommendationIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1923 = 0;
                                $self->{success} = [];
                                my $_etype1926 = 0;
                                $xfer += $input->readListBegin(\$_etype1926, \$_size1923);
                                for (my $_i1927 = 0; $_i1927 < $_size1923; ++$_i1927)
                                {
                                  my $elem1928 = undef;
                                  $xfer += $input->readString(\$elem1928);
                                  push(@{$self->{success}},$elem1928);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRecommendationIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1929 (@{$self->{success}}) 
                              {
                                $xfer += $output->writeString($iter1929);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRoom_args;
use base qw(Class::Accessor);
TalkService_getRoom_args->mk_accessors( qw( roomId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{roomId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{roomId}) {
                            $self->{roomId} = $vals->{roomId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRoom_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{roomId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRoom_args');
                        if (defined $self->{roomId}) {
                          $xfer += $output->writeFieldBegin('roomId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{roomId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRoom_result;
use base qw(Class::Accessor);
TalkService_getRoom_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRoom_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Room->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRoom_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRSAKeyInfo_args;
use base qw(Class::Accessor);
TalkService_getRSAKeyInfo_args->mk_accessors( qw( provider ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{provider} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRSAKeyInfo_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRSAKeyInfo_args');
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRSAKeyInfo_result;
use base qw(Class::Accessor);
TalkService_getRSAKeyInfo_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRSAKeyInfo_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = RSAKey->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRSAKeyInfo_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getServerTime_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getServerTime_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getServerTime_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getServerTime_result;
use base qw(Class::Accessor);
TalkService_getServerTime_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getServerTime_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getServerTime_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
                          $xfer += $output->writeI64($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSessions_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSessions_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSessions_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSessions_result;
use base qw(Class::Accessor);
TalkService_getSessions_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSessions_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1930 = 0;
                                $self->{success} = [];
                                my $_etype1933 = 0;
                                $xfer += $input->readListBegin(\$_etype1933, \$_size1930);
                                for (my $_i1934 = 0; $_i1934 < $_size1930; ++$_i1934)
                                {
                                  my $elem1935 = undef;
                                  $elem1935 = LoginSession->new();
                                  $xfer += $elem1935->read($input);
                                  push(@{$self->{success}},$elem1935);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSessions_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1936 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1936}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSettings_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSettings_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSettings_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSettings_result;
use base qw(Class::Accessor);
TalkService_getSettings_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSettings_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Settings->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSettings_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupsV2_args;
use base qw(Class::Accessor);
TalkService_getGroupsV2_args->mk_accessors( qw( groupIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{groupIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{groupIds}) {
                            $self->{groupIds} = $vals->{groupIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupsV2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1937 = 0;
                                $self->{groupIds} = [];
                                my $_etype1940 = 0;
                                $xfer += $input->readListBegin(\$_etype1940, \$_size1937);
                                for (my $_i1941 = 0; $_i1941 < $_size1937; ++$_i1941)
                                {
                                  my $elem1942 = undef;
                                  $xfer += $input->readString(\$elem1942);
                                  push(@{$self->{groupIds}},$elem1942);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupsV2_args');
                        if (defined $self->{groupIds}) {
                          $xfer += $output->writeFieldBegin('groupIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{groupIds}}));
                            {
                              foreach my $iter1943 (@{$self->{groupIds}}) 
                              {
                                $xfer += $output->writeString($iter1943);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getGroupsV2_result;
use base qw(Class::Accessor);
TalkService_getGroupsV2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getGroupsV2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1944 = 0;
                                $self->{success} = [];
                                my $_etype1947 = 0;
                                $xfer += $input->readListBegin(\$_etype1947, \$_size1944);
                                for (my $_i1948 = 0; $_i1948 < $_size1944; ++$_i1948)
                                {
                                  my $elem1949 = undef;
                                  $elem1949 = Group->new();
                                  $xfer += $elem1949->read($input);
                                  push(@{$self->{success}},$elem1949);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getGroupsV2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter1950 (@{$self->{success}}) 
                              {
                                $xfer += ${iter1950}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSettingsAttributes_args;
use base qw(Class::Accessor);
TalkService_getSettingsAttributes_args->mk_accessors( qw( attrBitset ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{attrBitset} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{attrBitset}) {
                            $self->{attrBitset} = $vals->{attrBitset};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSettingsAttributes_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{attrBitset});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSettingsAttributes_args');
                        if (defined $self->{attrBitset}) {
                          $xfer += $output->writeFieldBegin('attrBitset', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{attrBitset});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSettingsAttributes_result;
use base qw(Class::Accessor);
TalkService_getSettingsAttributes_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSettingsAttributes_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Settings->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSettingsAttributes_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSystemConfiguration_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSystemConfiguration_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSystemConfiguration_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getSystemConfiguration_result;
use base qw(Class::Accessor);
TalkService_getSystemConfiguration_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getSystemConfiguration_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = SystemConfiguration->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getSystemConfiguration_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getUserTicket_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getUserTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getUserTicket_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getUserTicket_result;
use base qw(Class::Accessor);
TalkService_getUserTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getUserTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Ticket->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getUserTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getWapInvitation_args;
use base qw(Class::Accessor);
TalkService_getWapInvitation_args->mk_accessors( qw( invitationHash ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{invitationHash} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{invitationHash}) {
                            $self->{invitationHash} = $vals->{invitationHash};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getWapInvitation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{invitationHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getWapInvitation_args');
                        if (defined $self->{invitationHash}) {
                          $xfer += $output->writeFieldBegin('invitationHash', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{invitationHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getWapInvitation_result;
use base qw(Class::Accessor);
TalkService_getWapInvitation_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getWapInvitation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = WapInvitation->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getWapInvitation_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_invalidateUserTicket_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_invalidateUserTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_invalidateUserTicket_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_invalidateUserTicket_result;
use base qw(Class::Accessor);
TalkService_invalidateUserTicket_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_invalidateUserTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_invalidateUserTicket_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteFriendsBySms_args;
use base qw(Class::Accessor);
TalkService_inviteFriendsBySms_args->mk_accessors( qw( phoneNumberList ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{phoneNumberList} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{phoneNumberList}) {
                            $self->{phoneNumberList} = $vals->{phoneNumberList};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteFriendsBySms_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1951 = 0;
                                $self->{phoneNumberList} = [];
                                my $_etype1954 = 0;
                                $xfer += $input->readListBegin(\$_etype1954, \$_size1951);
                                for (my $_i1955 = 0; $_i1955 < $_size1951; ++$_i1955)
                                {
                                  my $elem1956 = undef;
                                  $xfer += $input->readString(\$elem1956);
                                  push(@{$self->{phoneNumberList}},$elem1956);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteFriendsBySms_args');
                        if (defined $self->{phoneNumberList}) {
                          $xfer += $output->writeFieldBegin('phoneNumberList', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{phoneNumberList}}));
                            {
                              foreach my $iter1957 (@{$self->{phoneNumberList}}) 
                              {
                                $xfer += $output->writeString($iter1957);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteFriendsBySms_result;
use base qw(Class::Accessor);
TalkService_inviteFriendsBySms_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteFriendsBySms_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteFriendsBySms_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteIntoGroup_args;
use base qw(Class::Accessor);
TalkService_inviteIntoGroup_args->mk_accessors( qw( reqSeq groupId contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupId} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteIntoGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1958 = 0;
                                $self->{contactIds} = [];
                                my $_etype1961 = 0;
                                $xfer += $input->readListBegin(\$_etype1961, \$_size1958);
                                for (my $_i1962 = 0; $_i1962 < $_size1958; ++$_i1962)
                                {
                                  my $elem1963 = undef;
                                  $xfer += $input->readString(\$elem1963);
                                  push(@{$self->{contactIds}},$elem1963);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteIntoGroup_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter1964 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter1964);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteIntoGroup_result;
use base qw(Class::Accessor);
TalkService_inviteIntoGroup_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteIntoGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteIntoGroup_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteIntoRoom_args;
use base qw(Class::Accessor);
TalkService_inviteIntoRoom_args->mk_accessors( qw( reqSeq roomId contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{roomId} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{roomId}) {
                            $self->{roomId} = $vals->{roomId};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteIntoRoom_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{roomId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1965 = 0;
                                $self->{contactIds} = [];
                                my $_etype1968 = 0;
                                $xfer += $input->readListBegin(\$_etype1968, \$_size1965);
                                for (my $_i1969 = 0; $_i1969 < $_size1965; ++$_i1969)
                                {
                                  my $elem1970 = undef;
                                  $xfer += $input->readString(\$elem1970);
                                  push(@{$self->{contactIds}},$elem1970);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteIntoRoom_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{roomId}) {
                          $xfer += $output->writeFieldBegin('roomId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{roomId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter1971 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter1971);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteIntoRoom_result;
use base qw(Class::Accessor);
TalkService_inviteIntoRoom_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteIntoRoom_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteIntoRoom_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteViaEmail_args;
use base qw(Class::Accessor);
TalkService_inviteViaEmail_args->mk_accessors( qw( reqSeq email name ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{email} = undef;
                        $self->{name} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{email}) {
                            $self->{email} = $vals->{email};
                          }
                          if (defined $vals->{name}) {
                            $self->{name} = $vals->{name};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteViaEmail_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{email});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{name});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteViaEmail_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{email}) {
                          $xfer += $output->writeFieldBegin('email', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{email});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{name}) {
                          $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{name});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_inviteViaEmail_result;
use base qw(Class::Accessor);
TalkService_inviteViaEmail_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_inviteViaEmail_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_inviteViaEmail_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_isIdentityIdentifierAvailable_args;
use base qw(Class::Accessor);
TalkService_isIdentityIdentifierAvailable_args->mk_accessors( qw( provider identifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{provider} = undef;
                        $self->{identifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_isIdentityIdentifierAvailable_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_isIdentityIdentifierAvailable_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_isIdentityIdentifierAvailable_result;
use base qw(Class::Accessor);
TalkService_isIdentityIdentifierAvailable_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_isIdentityIdentifierAvailable_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_isIdentityIdentifierAvailable_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                          $xfer += $output->writeBool($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_isUseridAvailable_args;
use base qw(Class::Accessor);
TalkService_isUseridAvailable_args->mk_accessors( qw( userid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{userid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_isUseridAvailable_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_isUseridAvailable_args');
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_isUseridAvailable_result;
use base qw(Class::Accessor);
TalkService_isUseridAvailable_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_isUseridAvailable_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_isUseridAvailable_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                          $xfer += $output->writeBool($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_kickoutFromGroup_args;
use base qw(Class::Accessor);
TalkService_kickoutFromGroup_args->mk_accessors( qw( reqSeq groupId contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupId} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_kickoutFromGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1972 = 0;
                                $self->{contactIds} = [];
                                my $_etype1975 = 0;
                                $xfer += $input->readListBegin(\$_etype1975, \$_size1972);
                                for (my $_i1976 = 0; $_i1976 < $_size1972; ++$_i1976)
                                {
                                  my $elem1977 = undef;
                                  $xfer += $input->readString(\$elem1977);
                                  push(@{$self->{contactIds}},$elem1977);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_kickoutFromGroup_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter1978 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter1978);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_kickoutFromGroup_result;
use base qw(Class::Accessor);
TalkService_kickoutFromGroup_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_kickoutFromGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_kickoutFromGroup_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reissueGroupTicket_args;
use base qw(Class::Accessor);
TalkService_reissueGroupTicket_args->mk_accessors( qw( groupMid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{groupMid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{groupMid}) {
                            $self->{groupMid} = $vals->{groupMid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reissueGroupTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reissueGroupTicket_args');
                        if (defined $self->{groupMid}) {
                          $xfer += $output->writeFieldBegin('groupMid', Thrift::TType::STRING, 1);
                          $xfer += $output->writeString($self->{groupMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reissueGroupTicket_result;
use base qw(Class::Accessor);
TalkService_reissueGroupTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reissueGroupTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reissueGroupTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findGroupByTicket_args;
use base qw(Class::Accessor);
TalkService_findGroupByTicket_args->mk_accessors( qw( ticketId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{ticketId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{ticketId}) {
                            $self->{ticketId} = $vals->{ticketId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findGroupByTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{ticketId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findGroupByTicket_args');
                        if (defined $self->{ticketId}) {
                          $xfer += $output->writeFieldBegin('ticketId', Thrift::TType::STRING, 1);
                          $xfer += $output->writeString($self->{ticketId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findGroupByTicket_result;
use base qw(Class::Accessor);
TalkService_findGroupByTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findGroupByTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Group->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findGroupByTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_leaveGroup_args;
use base qw(Class::Accessor);
TalkService_leaveGroup_args->mk_accessors( qw( reqSeq groupId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_leaveGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_leaveGroup_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_leaveGroup_result;
use base qw(Class::Accessor);
TalkService_leaveGroup_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_leaveGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_leaveGroup_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_leaveRoom_args;
use base qw(Class::Accessor);
TalkService_leaveRoom_args->mk_accessors( qw( reqSeq roomId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{roomId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{roomId}) {
                            $self->{roomId} = $vals->{roomId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_leaveRoom_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{roomId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_leaveRoom_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{roomId}) {
                          $xfer += $output->writeFieldBegin('roomId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{roomId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_leaveRoom_result;
use base qw(Class::Accessor);
TalkService_leaveRoom_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_leaveRoom_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_leaveRoom_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_loginWithIdentityCredential_args->mk_accessors( qw( identityProvider identifier password keepLoggedIn accessLocation systemName certificate ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{identityProvider} = undef;
                        $self->{identifier} = undef;
                        $self->{password} = undef;
                        $self->{keepLoggedIn} = undef;
                        $self->{accessLocation} = undef;
                        $self->{systemName} = undef;
                        $self->{certificate} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{identityProvider}) {
                            $self->{identityProvider} = $vals->{identityProvider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{password}) {
                            $self->{password} = $vals->{password};
                          }
                          if (defined $vals->{keepLoggedIn}) {
                            $self->{keepLoggedIn} = $vals->{keepLoggedIn};
                          }
                          if (defined $vals->{accessLocation}) {
                            $self->{accessLocation} = $vals->{accessLocation};
                          }
                          if (defined $vals->{systemName}) {
                            $self->{systemName} = $vals->{systemName};
                          }
                          if (defined $vals->{certificate}) {
                            $self->{certificate} = $vals->{certificate};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^8$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{identityProvider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{password});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{keepLoggedIn});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{accessLocation});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{systemName});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^9$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{certificate});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithIdentityCredential_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{password}) {
                          $xfer += $output->writeFieldBegin('password', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{password});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{keepLoggedIn}) {
                          $xfer += $output->writeFieldBegin('keepLoggedIn', Thrift::TType::BOOL, 5);
                          $xfer += $output->writeBool($self->{keepLoggedIn});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{accessLocation}) {
                          $xfer += $output->writeFieldBegin('accessLocation', Thrift::TType::STRING, 6);
                          $xfer += $output->writeString($self->{accessLocation});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{systemName}) {
                          $xfer += $output->writeFieldBegin('systemName', Thrift::TType::STRING, 7);
                          $xfer += $output->writeString($self->{systemName});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{identityProvider}) {
                          $xfer += $output->writeFieldBegin('identityProvider', Thrift::TType::I32, 8);
                          $xfer += $output->writeI32($self->{identityProvider});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{certificate}) {
                          $xfer += $output->writeFieldBegin('certificate', Thrift::TType::STRING, 9);
                          $xfer += $output->writeString($self->{certificate});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_loginWithIdentityCredential_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithIdentityCredential_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithIdentityCredentialForCertificate_args;
use base qw(Class::Accessor);
TalkService_loginWithIdentityCredentialForCertificate_args->mk_accessors( qw( identityProvider identifier password keepLoggedIn accessLocation systemName certificate ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{identityProvider} = undef;
                        $self->{identifier} = undef;
                        $self->{password} = undef;
                        $self->{keepLoggedIn} = undef;
                        $self->{accessLocation} = undef;
                        $self->{systemName} = undef;
                        $self->{certificate} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{identityProvider}) {
                            $self->{identityProvider} = $vals->{identityProvider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{password}) {
                            $self->{password} = $vals->{password};
                          }
                          if (defined $vals->{keepLoggedIn}) {
                            $self->{keepLoggedIn} = $vals->{keepLoggedIn};
                          }
                          if (defined $vals->{accessLocation}) {
                            $self->{accessLocation} = $vals->{accessLocation};
                          }
                          if (defined $vals->{systemName}) {
                            $self->{systemName} = $vals->{systemName};
                          }
                          if (defined $vals->{certificate}) {
                            $self->{certificate} = $vals->{certificate};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithIdentityCredentialForCertificate_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^8$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{identityProvider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{password});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{keepLoggedIn});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{accessLocation});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{systemName});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^9$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{certificate});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithIdentityCredentialForCertificate_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{password}) {
                          $xfer += $output->writeFieldBegin('password', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{password});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{keepLoggedIn}) {
                          $xfer += $output->writeFieldBegin('keepLoggedIn', Thrift::TType::BOOL, 5);
                          $xfer += $output->writeBool($self->{keepLoggedIn});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{accessLocation}) {
                          $xfer += $output->writeFieldBegin('accessLocation', Thrift::TType::STRING, 6);
                          $xfer += $output->writeString($self->{accessLocation});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{systemName}) {
                          $xfer += $output->writeFieldBegin('systemName', Thrift::TType::STRING, 7);
                          $xfer += $output->writeString($self->{systemName});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{identityProvider}) {
                          $xfer += $output->writeFieldBegin('identityProvider', Thrift::TType::I32, 8);
                          $xfer += $output->writeI32($self->{identityProvider});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{certificate}) {
                          $xfer += $output->writeFieldBegin('certificate', Thrift::TType::STRING, 9);
                          $xfer += $output->writeString($self->{certificate});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithIdentityCredentialForCertificate_result;
use base qw(Class::Accessor);
TalkService_loginWithIdentityCredentialForCertificate_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithIdentityCredentialForCertificate_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = LoginResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithIdentityCredentialForCertificate_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithVerifier_args;
use base qw(Class::Accessor);
TalkService_loginWithVerifier_args->mk_accessors( qw( verifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithVerifier_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithVerifier_args');
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithVerifier_result;
use base qw(Class::Accessor);
TalkService_loginWithVerifier_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithVerifier_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithVerifier_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithVerifierForCerificate_args;
use base qw(Class::Accessor);
TalkService_loginWithVerifierForCerificate_args->mk_accessors( qw( verifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithVerifierForCerificate_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithVerifierForCerificate_args');
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithVerifierForCerificate_result;
use base qw(Class::Accessor);
TalkService_loginWithVerifierForCerificate_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithVerifierForCerificate_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = LoginResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithVerifierForCerificate_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithVerifierForCertificate_args;
use base qw(Class::Accessor);
TalkService_loginWithVerifierForCertificate_args->mk_accessors( qw( verifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithVerifierForCertificate_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithVerifierForCertificate_args');
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_loginWithVerifierForCertificate_result;
use base qw(Class::Accessor);
TalkService_loginWithVerifierForCertificate_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_loginWithVerifierForCertificate_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = LoginResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_loginWithVerifierForCertificate_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_logout_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_logout_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_logout_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_logout_result;
use base qw(Class::Accessor);
TalkService_logout_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_logout_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_logout_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_logoutSession_args;
use base qw(Class::Accessor);
TalkService_logoutSession_args->mk_accessors( qw( tokenKey ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{tokenKey} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{tokenKey}) {
                            $self->{tokenKey} = $vals->{tokenKey};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_logoutSession_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{tokenKey});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_logoutSession_args');
                        if (defined $self->{tokenKey}) {
                          $xfer += $output->writeFieldBegin('tokenKey', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{tokenKey});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_logoutSession_result;
use base qw(Class::Accessor);
TalkService_logoutSession_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_logoutSession_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_logoutSession_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_noop_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_noop_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_noop_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_noop_result;
use base qw(Class::Accessor);
TalkService_noop_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_noop_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_noop_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifiedRedirect_args;
use base qw(Class::Accessor);
TalkService_notifiedRedirect_args->mk_accessors( qw( paramMap ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{paramMap} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{paramMap}) {
                            $self->{paramMap} = $vals->{paramMap};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifiedRedirect_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1979 = 0;
                                $self->{paramMap} = {};
                                my $_ktype1980 = 0;
                                my $_vtype1981 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1980, \$_vtype1981, \$_size1979);
                                for (my $_i1983 = 0; $_i1983 < $_size1979; ++$_i1983)
                                {
                                  my $key1984 = '';
                                  my $val1985 = '';
                                  $xfer += $input->readString(\$key1984);
                                  $xfer += $input->readString(\$val1985);
                                  $self->{paramMap}->{$key1984} = $val1985;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifiedRedirect_args');
                        if (defined $self->{paramMap}) {
                          $xfer += $output->writeFieldBegin('paramMap', Thrift::TType::MAP, 2);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{paramMap}}));
                            {
                              while( my ($kiter1986,$viter1987) = each %{$self->{paramMap}}) 
                              {
                                $xfer += $output->writeString($kiter1986);
                                $xfer += $output->writeString($viter1987);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifiedRedirect_result;
use base qw(Class::Accessor);
TalkService_notifiedRedirect_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifiedRedirect_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifiedRedirect_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyBuddyOnAir_args;
use base qw(Class::Accessor);
TalkService_notifyBuddyOnAir_args->mk_accessors( qw( seq receiverMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{receiverMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{receiverMids}) {
                            $self->{receiverMids} = $vals->{receiverMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyBuddyOnAir_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size1988 = 0;
                                $self->{receiverMids} = [];
                                my $_etype1991 = 0;
                                $xfer += $input->readListBegin(\$_etype1991, \$_size1988);
                                for (my $_i1992 = 0; $_i1992 < $_size1988; ++$_i1992)
                                {
                                  my $elem1993 = undef;
                                  $xfer += $input->readString(\$elem1993);
                                  push(@{$self->{receiverMids}},$elem1993);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyBuddyOnAir_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMids}) {
                          $xfer += $output->writeFieldBegin('receiverMids', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{receiverMids}}));
                            {
                              foreach my $iter1994 (@{$self->{receiverMids}}) 
                              {
                                $xfer += $output->writeString($iter1994);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyBuddyOnAir_result;
use base qw(Class::Accessor);
TalkService_notifyBuddyOnAir_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyBuddyOnAir_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size1995 = 0;
                                $self->{success} = {};
                                my $_ktype1996 = 0;
                                my $_vtype1997 = 0;
                                $xfer += $input->readMapBegin(\$_ktype1996, \$_vtype1997, \$_size1995);
                                for (my $_i1999 = 0; $_i1999 < $_size1995; ++$_i1999)
                                {
                                  my $key2000 = '';
                                  my $val2001 = '';
                                  $xfer += $input->readString(\$key2000);
                                  $xfer += $input->readString(\$val2001);
                                  $self->{success}->{$key2000} = $val2001;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyBuddyOnAir_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter2002,$viter2003) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter2002);
                                $xfer += $output->writeString($viter2003);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyIndividualEvent_args;
use base qw(Class::Accessor);
TalkService_notifyIndividualEvent_args->mk_accessors( qw( notificationStatus receiverMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{notificationStatus} = undef;
                        $self->{receiverMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{notificationStatus}) {
                            $self->{notificationStatus} = $vals->{notificationStatus};
                          }
                          if (defined $vals->{receiverMids}) {
                            $self->{receiverMids} = $vals->{receiverMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyIndividualEvent_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{notificationStatus});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2004 = 0;
                                $self->{receiverMids} = [];
                                my $_etype2007 = 0;
                                $xfer += $input->readListBegin(\$_etype2007, \$_size2004);
                                for (my $_i2008 = 0; $_i2008 < $_size2004; ++$_i2008)
                                {
                                  my $elem2009 = undef;
                                  $xfer += $input->readString(\$elem2009);
                                  push(@{$self->{receiverMids}},$elem2009);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyIndividualEvent_args');
                        if (defined $self->{notificationStatus}) {
                          $xfer += $output->writeFieldBegin('notificationStatus', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{notificationStatus});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMids}) {
                          $xfer += $output->writeFieldBegin('receiverMids', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{receiverMids}}));
                            {
                              foreach my $iter2010 (@{$self->{receiverMids}}) 
                              {
                                $xfer += $output->writeString($iter2010);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyIndividualEvent_result;
use base qw(Class::Accessor);
TalkService_notifyIndividualEvent_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyIndividualEvent_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyIndividualEvent_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyInstalled_args;
use base qw(Class::Accessor);
TalkService_notifyInstalled_args->mk_accessors( qw( udidHash applicationTypeWithExtensions ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{udidHash} = undef;
                        $self->{applicationTypeWithExtensions} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{applicationTypeWithExtensions}) {
                            $self->{applicationTypeWithExtensions} = $vals->{applicationTypeWithExtensions};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyInstalled_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{applicationTypeWithExtensions});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyInstalled_args');
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{applicationTypeWithExtensions}) {
                          $xfer += $output->writeFieldBegin('applicationTypeWithExtensions', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{applicationTypeWithExtensions});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyInstalled_result;
use base qw(Class::Accessor);
TalkService_notifyInstalled_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyInstalled_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyInstalled_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyRegistrationComplete_args;
use base qw(Class::Accessor);
TalkService_notifyRegistrationComplete_args->mk_accessors( qw( udidHash applicationTypeWithExtensions ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{udidHash} = undef;
                        $self->{applicationTypeWithExtensions} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{applicationTypeWithExtensions}) {
                            $self->{applicationTypeWithExtensions} = $vals->{applicationTypeWithExtensions};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyRegistrationComplete_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{applicationTypeWithExtensions});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyRegistrationComplete_args');
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{applicationTypeWithExtensions}) {
                          $xfer += $output->writeFieldBegin('applicationTypeWithExtensions', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{applicationTypeWithExtensions});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyRegistrationComplete_result;
use base qw(Class::Accessor);
TalkService_notifyRegistrationComplete_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyRegistrationComplete_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyRegistrationComplete_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifySleep_args;
use base qw(Class::Accessor);
TalkService_notifySleep_args->mk_accessors( qw( lastRev badge ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{lastRev} = undef;
                        $self->{badge} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{lastRev}) {
                            $self->{lastRev} = $vals->{lastRev};
                          }
                          if (defined $vals->{badge}) {
                            $self->{badge} = $vals->{badge};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifySleep_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{lastRev});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{badge});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifySleep_args');
                        if (defined $self->{lastRev}) {
                          $xfer += $output->writeFieldBegin('lastRev', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{lastRev});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{badge}) {
                          $xfer += $output->writeFieldBegin('badge', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{badge});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifySleep_result;
use base qw(Class::Accessor);
TalkService_notifySleep_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifySleep_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifySleep_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyUpdated_args;
use base qw(Class::Accessor);
TalkService_notifyUpdated_args->mk_accessors( qw( lastRev deviceInfo ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{lastRev} = undef;
                        $self->{deviceInfo} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{lastRev}) {
                            $self->{lastRev} = $vals->{lastRev};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyUpdated_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{lastRev});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyUpdated_args');
                        if (defined $self->{lastRev}) {
                          $xfer += $output->writeFieldBegin('lastRev', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{lastRev});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_notifyUpdated_result;
use base qw(Class::Accessor);
TalkService_notifyUpdated_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_notifyUpdated_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_notifyUpdated_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_openProximityMatch_args;
use base qw(Class::Accessor);
TalkService_openProximityMatch_args->mk_accessors( qw( location ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{location} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{location}) {
                            $self->{location} = $vals->{location};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_openProximityMatch_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{location} = Location->new();
                              $xfer += $self->{location}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_openProximityMatch_args');
                        if (defined $self->{location}) {
                          $xfer += $output->writeFieldBegin('location', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{location}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_openProximityMatch_result;
use base qw(Class::Accessor);
TalkService_openProximityMatch_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_openProximityMatch_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_openProximityMatch_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerBuddyUser_args;
use base qw(Class::Accessor);
TalkService_registerBuddyUser_args->mk_accessors( qw( buddyId registrarPassword ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{buddyId} = undef;
                        $self->{registrarPassword} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{buddyId}) {
                            $self->{buddyId} = $vals->{buddyId};
                          }
                          if (defined $vals->{registrarPassword}) {
                            $self->{registrarPassword} = $vals->{registrarPassword};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerBuddyUser_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{buddyId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{registrarPassword});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerBuddyUser_args');
                        if (defined $self->{buddyId}) {
                          $xfer += $output->writeFieldBegin('buddyId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{buddyId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{registrarPassword}) {
                          $xfer += $output->writeFieldBegin('registrarPassword', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{registrarPassword});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerBuddyUser_result;
use base qw(Class::Accessor);
TalkService_registerBuddyUser_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerBuddyUser_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerBuddyUser_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerBuddyUserid_args;
use base qw(Class::Accessor);
TalkService_registerBuddyUserid_args->mk_accessors( qw( seq userid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{userid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerBuddyUserid_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerBuddyUserid_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerBuddyUserid_result;
use base qw(Class::Accessor);
TalkService_registerBuddyUserid_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerBuddyUserid_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerBuddyUserid_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDevice_args;
use base qw(Class::Accessor);
TalkService_registerDevice_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDevice_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDevice_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDevice_result;
use base qw(Class::Accessor);
TalkService_registerDevice_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDevice_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDevice_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDeviceWithIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_registerDeviceWithIdentityCredential_args->mk_accessors( qw( sessionId provider identifier verifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{provider} = undef;
                        $self->{identifier} = undef;
                        $self->{verifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDeviceWithIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDeviceWithIdentityCredential_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 5);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDeviceWithIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_registerDeviceWithIdentityCredential_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDeviceWithIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDeviceWithIdentityCredential_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDeviceWithoutPhoneNumber_args;
use base qw(Class::Accessor);
TalkService_registerDeviceWithoutPhoneNumber_args->mk_accessors( qw( region udidHash deviceInfo ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{region} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDeviceWithoutPhoneNumber_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDeviceWithoutPhoneNumber_args');
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 4);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDeviceWithoutPhoneNumber_result;
use base qw(Class::Accessor);
TalkService_registerDeviceWithoutPhoneNumber_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDeviceWithoutPhoneNumber_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDeviceWithoutPhoneNumber_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args->mk_accessors( qw( region udidHash deviceInfo provider identifier verifier mid migrationPincodeSessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{region} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        $self->{provider} = undef;
                        $self->{identifier} = undef;
                        $self->{verifier} = undef;
                        $self->{mid} = undef;
                        $self->{migrationPincodeSessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{migrationPincodeSessionId}) {
                            $self->{migrationPincodeSessionId} = $vals->{migrationPincodeSessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^8$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^9$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{migrationPincodeSessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args');
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 4);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 5);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 6);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 7);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 8);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{migrationPincodeSessionId}) {
                          $xfer += $output->writeFieldBegin('migrationPincodeSessionId', Thrift::TType::STRING, 9);
                          $xfer += $output->writeString($self->{migrationPincodeSessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerUserid_args;
use base qw(Class::Accessor);
TalkService_registerUserid_args->mk_accessors( qw( reqSeq userid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{userid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerUserid_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerUserid_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerUserid_result;
use base qw(Class::Accessor);
TalkService_registerUserid_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerUserid_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerUserid_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                          $xfer += $output->writeBool($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWapDevice_args;
use base qw(Class::Accessor);
TalkService_registerWapDevice_args->mk_accessors( qw( invitationHash guidHash email deviceInfo ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{invitationHash} = undef;
                        $self->{guidHash} = undef;
                        $self->{email} = undef;
                        $self->{deviceInfo} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{invitationHash}) {
                            $self->{invitationHash} = $vals->{invitationHash};
                          }
                          if (defined $vals->{guidHash}) {
                            $self->{guidHash} = $vals->{guidHash};
                          }
                          if (defined $vals->{email}) {
                            $self->{email} = $vals->{email};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWapDevice_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{invitationHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{guidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{email});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWapDevice_args');
                        if (defined $self->{invitationHash}) {
                          $xfer += $output->writeFieldBegin('invitationHash', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{invitationHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{guidHash}) {
                          $xfer += $output->writeFieldBegin('guidHash', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{guidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{email}) {
                          $xfer += $output->writeFieldBegin('email', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{email});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 5);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWapDevice_result;
use base qw(Class::Accessor);
TalkService_registerWapDevice_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWapDevice_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWapDevice_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithExistingSnsIdAndIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_registerWithExistingSnsIdAndIdentityCredential_args->mk_accessors( qw( identityCredential region udidHash deviceInfo ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{identityCredential} = undef;
                        $self->{region} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{identityCredential}) {
                            $self->{identityCredential} = $vals->{identityCredential};
                          }
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithExistingSnsIdAndIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{identityCredential} = IdentityCredential->new();
                              $xfer += $self->{identityCredential}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithExistingSnsIdAndIdentityCredential_args');
                        if (defined $self->{identityCredential}) {
                          $xfer += $output->writeFieldBegin('identityCredential', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{identityCredential}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 5);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithExistingSnsIdAndIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_registerWithExistingSnsIdAndIdentityCredential_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithExistingSnsIdAndIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithExistingSnsIdAndIdentityCredential_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithSnsId_args;
use base qw(Class::Accessor);
TalkService_registerWithSnsId_args->mk_accessors( qw( snsIdType snsAccessToken region udidHash deviceInfo mid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{snsIdType} = undef;
                        $self->{snsAccessToken} = undef;
                        $self->{region} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        $self->{mid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{snsIdType}) {
                            $self->{snsIdType} = $vals->{snsIdType};
                          }
                          if (defined $vals->{snsAccessToken}) {
                            $self->{snsAccessToken} = $vals->{snsAccessToken};
                          }
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithSnsId_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{snsIdType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{snsAccessToken});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithSnsId_args');
                        if (defined $self->{snsIdType}) {
                          $xfer += $output->writeFieldBegin('snsIdType', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{snsIdType});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{snsAccessToken}) {
                          $xfer += $output->writeFieldBegin('snsAccessToken', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{snsAccessToken});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 5);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 6);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 7);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithSnsId_result;
use base qw(Class::Accessor);
TalkService_registerWithSnsId_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithSnsId_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = RegisterWithSnsIdResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithSnsId_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithSnsIdAndIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_registerWithSnsIdAndIdentityCredential_args->mk_accessors( qw( snsIdType snsAccessToken identityCredential region udidHash deviceInfo ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{snsIdType} = undef;
                        $self->{snsAccessToken} = undef;
                        $self->{identityCredential} = undef;
                        $self->{region} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{snsIdType}) {
                            $self->{snsIdType} = $vals->{snsIdType};
                          }
                          if (defined $vals->{snsAccessToken}) {
                            $self->{snsAccessToken} = $vals->{snsAccessToken};
                          }
                          if (defined $vals->{identityCredential}) {
                            $self->{identityCredential} = $vals->{identityCredential};
                          }
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithSnsIdAndIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{snsIdType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{snsAccessToken});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{identityCredential} = IdentityCredential->new();
                              $xfer += $self->{identityCredential}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithSnsIdAndIdentityCredential_args');
                        if (defined $self->{snsIdType}) {
                          $xfer += $output->writeFieldBegin('snsIdType', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{snsIdType});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{snsAccessToken}) {
                          $xfer += $output->writeFieldBegin('snsAccessToken', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{snsAccessToken});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{identityCredential}) {
                          $xfer += $output->writeFieldBegin('identityCredential', Thrift::TType::STRUCT, 4);
                          $xfer += $self->{identityCredential}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 5);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 6);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 7);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerWithSnsIdAndIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_registerWithSnsIdAndIdentityCredential_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerWithSnsIdAndIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerWithSnsIdAndIdentityCredential_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reissueDeviceCredential_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reissueDeviceCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reissueDeviceCredential_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reissueDeviceCredential_result;
use base qw(Class::Accessor);
TalkService_reissueDeviceCredential_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reissueDeviceCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reissueDeviceCredential_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reissueUserTicket_args;
use base qw(Class::Accessor);
TalkService_reissueUserTicket_args->mk_accessors( qw( expirationTime maxUseCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{expirationTime} = undef;
                        $self->{maxUseCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{expirationTime}) {
                            $self->{expirationTime} = $vals->{expirationTime};
                          }
                          if (defined $vals->{maxUseCount}) {
                            $self->{maxUseCount} = $vals->{maxUseCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reissueUserTicket_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{expirationTime});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{maxUseCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reissueUserTicket_args');
                        if (defined $self->{expirationTime}) {
                          $xfer += $output->writeFieldBegin('expirationTime', Thrift::TType::I64, 3);
                          $xfer += $output->writeI64($self->{expirationTime});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{maxUseCount}) {
                          $xfer += $output->writeFieldBegin('maxUseCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{maxUseCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reissueUserTicket_result;
use base qw(Class::Accessor);
TalkService_reissueUserTicket_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reissueUserTicket_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reissueUserTicket_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageReadRange_args;
use base qw(Class::Accessor);
TalkService_getMessageReadRange_args->mk_accessors( qw( chatIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{chatIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{chatIds}) {
                            $self->{chatIds} = $vals->{chatIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageReadRange_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2011 = 0;
                                $self->{chatIds} = [];
                                my $_etype2014 = 0;
                                $xfer += $input->readListBegin(\$_etype2014, \$_size2011);
                                for (my $_i2015 = 0; $_i2015 < $_size2011; ++$_i2015)
                                {
                                  my $elem2016 = undef;
                                  $xfer += $input->readString(\$elem2016);
                                  push(@{$self->{chatIds}},$elem2016);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageReadRange_args');
                        if (defined $self->{chatIds}) {
                          $xfer += $output->writeFieldBegin('chatIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{chatIds}}));
                            {
                              foreach my $iter2017 (@{$self->{chatIds}}) 
                              {
                                $xfer += $output->writeString($iter2017);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageReadRange_result;
use base qw(Class::Accessor);
TalkService_getMessageReadRange_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageReadRange_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2018 = 0;
                                $self->{success} = [];
                                my $_etype2021 = 0;
                                $xfer += $input->readListBegin(\$_etype2021, \$_size2018);
                                for (my $_i2022 = 0; $_i2022 < $_size2018; ++$_i2022)
                                {
                                  my $elem2023 = undef;
                                  $elem2023 = TMessageReadRange->new();
                                  $xfer += $elem2023->read($input);
                                  push(@{$self->{success}},$elem2023);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageReadRange_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2024 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2024}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_rejectGroupInvitation_args;
use base qw(Class::Accessor);
TalkService_rejectGroupInvitation_args->mk_accessors( qw( reqSeq groupId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupId}) {
                            $self->{groupId} = $vals->{groupId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_rejectGroupInvitation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_rejectGroupInvitation_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupId}) {
                          $xfer += $output->writeFieldBegin('groupId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_rejectGroupInvitation_result;
use base qw(Class::Accessor);
TalkService_rejectGroupInvitation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_rejectGroupInvitation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_rejectGroupInvitation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_releaseSession_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_releaseSession_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_releaseSession_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_releaseSession_result;
use base qw(Class::Accessor);
TalkService_releaseSession_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_releaseSession_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_releaseSession_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeAllMessages_args;
use base qw(Class::Accessor);
TalkService_removeAllMessages_args->mk_accessors( qw( seq lastMessageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{lastMessageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{lastMessageId}) {
                            $self->{lastMessageId} = $vals->{lastMessageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeAllMessages_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{lastMessageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeAllMessages_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastMessageId}) {
                          $xfer += $output->writeFieldBegin('lastMessageId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{lastMessageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeAllMessages_result;
use base qw(Class::Accessor);
TalkService_removeAllMessages_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeAllMessages_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeAllMessages_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeBuddyLocation_args;
use base qw(Class::Accessor);
TalkService_removeBuddyLocation_args->mk_accessors( qw( mid index ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        $self->{index} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{index}) {
                            $self->{index} = $vals->{index};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeBuddyLocation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{index});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeBuddyLocation_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{index}) {
                          $xfer += $output->writeFieldBegin('index', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{index});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeBuddyLocation_result;
use base qw(Class::Accessor);
TalkService_removeBuddyLocation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeBuddyLocation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeBuddyLocation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeMessage_args;
use base qw(Class::Accessor);
TalkService_removeMessage_args->mk_accessors( qw( messageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeMessage_args');
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeMessage_result;
use base qw(Class::Accessor);
TalkService_removeMessage_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeMessage_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                          $xfer += $output->writeBool($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_makeUserAddMyselfAsContact_args;
use base qw(Class::Accessor);
TalkService_makeUserAddMyselfAsContact_args->mk_accessors( qw( contactOwnerMid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{contactOwnerMid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{contactOwnerMid}) {
                            $self->{contactOwnerMid} = $vals->{contactOwnerMid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_makeUserAddMyselfAsContact_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{contactOwnerMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_makeUserAddMyselfAsContact_args');
                        if (defined $self->{contactOwnerMid}) {
                          $xfer += $output->writeFieldBegin('contactOwnerMid', Thrift::TType::STRING, 1);
                          $xfer += $output->writeString($self->{contactOwnerMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_makeUserAddMyselfAsContact_result;
use base qw(Class::Accessor);
TalkService_makeUserAddMyselfAsContact_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_makeUserAddMyselfAsContact_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = ContactTransition->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_makeUserAddMyselfAsContact_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeMessageFromMyHome_args;
use base qw(Class::Accessor);
TalkService_removeMessageFromMyHome_args->mk_accessors( qw( messageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeMessageFromMyHome_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeMessageFromMyHome_args');
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeMessageFromMyHome_result;
use base qw(Class::Accessor);
TalkService_removeMessageFromMyHome_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeMessageFromMyHome_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeMessageFromMyHome_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
                          $xfer += $output->writeBool($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeSnsId_args;
use base qw(Class::Accessor);
TalkService_removeSnsId_args->mk_accessors( qw( snsIdType ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{snsIdType} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{snsIdType}) {
                            $self->{snsIdType} = $vals->{snsIdType};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeSnsId_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{snsIdType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeSnsId_args');
                        if (defined $self->{snsIdType}) {
                          $xfer += $output->writeFieldBegin('snsIdType', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{snsIdType});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeSnsId_result;
use base qw(Class::Accessor);
TalkService_removeSnsId_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeSnsId_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeSnsId_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_report_args;
use base qw(Class::Accessor);
TalkService_report_args->mk_accessors( qw( syncOpRevision category report ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{syncOpRevision} = undef;
                        $self->{category} = undef;
                        $self->{report} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{syncOpRevision}) {
                            $self->{syncOpRevision} = $vals->{syncOpRevision};
                          }
                          if (defined $vals->{category}) {
                            $self->{category} = $vals->{category};
                          }
                          if (defined $vals->{report}) {
                            $self->{report} = $vals->{report};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_report_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{syncOpRevision});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{category});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{report});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_report_args');
                        if (defined $self->{syncOpRevision}) {
                          $xfer += $output->writeFieldBegin('syncOpRevision', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{syncOpRevision});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{category}) {
                          $xfer += $output->writeFieldBegin('category', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{category});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{report}) {
                          $xfer += $output->writeFieldBegin('report', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{report});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_report_result;
use base qw(Class::Accessor);
TalkService_report_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_report_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_report_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportContacts_args;
use base qw(Class::Accessor);
TalkService_reportContacts_args->mk_accessors( qw( syncOpRevision category contactReports actionType ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{syncOpRevision} = undef;
                        $self->{category} = undef;
                        $self->{contactReports} = undef;
                        $self->{actionType} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{syncOpRevision}) {
                            $self->{syncOpRevision} = $vals->{syncOpRevision};
                          }
                          if (defined $vals->{category}) {
                            $self->{category} = $vals->{category};
                          }
                          if (defined $vals->{contactReports}) {
                            $self->{contactReports} = $vals->{contactReports};
                          }
                          if (defined $vals->{actionType}) {
                            $self->{actionType} = $vals->{actionType};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportContacts_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{syncOpRevision});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{category});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2025 = 0;
                                $self->{contactReports} = [];
                                my $_etype2028 = 0;
                                $xfer += $input->readListBegin(\$_etype2028, \$_size2025);
                                for (my $_i2029 = 0; $_i2029 < $_size2025; ++$_i2029)
                                {
                                  my $elem2030 = undef;
                                  $elem2030 = ContactReport->new();
                                  $xfer += $elem2030->read($input);
                                  push(@{$self->{contactReports}},$elem2030);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{actionType});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportContacts_args');
                        if (defined $self->{syncOpRevision}) {
                          $xfer += $output->writeFieldBegin('syncOpRevision', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{syncOpRevision});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{category}) {
                          $xfer += $output->writeFieldBegin('category', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{category});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactReports}) {
                          $xfer += $output->writeFieldBegin('contactReports', Thrift::TType::LIST, 4);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{contactReports}}));
                            {
                              foreach my $iter2031 (@{$self->{contactReports}}) 
                              {
                                $xfer += ${iter2031}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{actionType}) {
                          $xfer += $output->writeFieldBegin('actionType', Thrift::TType::I32, 5);
                          $xfer += $output->writeI32($self->{actionType});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportContacts_result;
use base qw(Class::Accessor);
TalkService_reportContacts_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportContacts_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2032 = 0;
                                $self->{success} = [];
                                my $_etype2035 = 0;
                                $xfer += $input->readListBegin(\$_etype2035, \$_size2032);
                                for (my $_i2036 = 0; $_i2036 < $_size2032; ++$_i2036)
                                {
                                  my $elem2037 = undef;
                                  $elem2037 = ContactReportResult->new();
                                  $xfer += $elem2037->read($input);
                                  push(@{$self->{success}},$elem2037);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportContacts_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2038 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2038}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportGroups_args;
use base qw(Class::Accessor);
TalkService_reportGroups_args->mk_accessors( qw( syncOpRevision groups ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{syncOpRevision} = undef;
                        $self->{groups} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{syncOpRevision}) {
                            $self->{syncOpRevision} = $vals->{syncOpRevision};
                          }
                          if (defined $vals->{groups}) {
                            $self->{groups} = $vals->{groups};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportGroups_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{syncOpRevision});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2039 = 0;
                                $self->{groups} = [];
                                my $_etype2042 = 0;
                                $xfer += $input->readListBegin(\$_etype2042, \$_size2039);
                                for (my $_i2043 = 0; $_i2043 < $_size2039; ++$_i2043)
                                {
                                  my $elem2044 = undef;
                                  $elem2044 = Group->new();
                                  $xfer += $elem2044->read($input);
                                  push(@{$self->{groups}},$elem2044);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportGroups_args');
                        if (defined $self->{syncOpRevision}) {
                          $xfer += $output->writeFieldBegin('syncOpRevision', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{syncOpRevision});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groups}) {
                          $xfer += $output->writeFieldBegin('groups', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{groups}}));
                            {
                              foreach my $iter2045 (@{$self->{groups}}) 
                              {
                                $xfer += ${iter2045}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportGroups_result;
use base qw(Class::Accessor);
TalkService_reportGroups_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportGroups_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportGroups_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportProfile_args;
use base qw(Class::Accessor);
TalkService_reportProfile_args->mk_accessors( qw( syncOpRevision profile ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{syncOpRevision} = undef;
                        $self->{profile} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{syncOpRevision}) {
                            $self->{syncOpRevision} = $vals->{syncOpRevision};
                          }
                          if (defined $vals->{profile}) {
                            $self->{profile} = $vals->{profile};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportProfile_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{syncOpRevision});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{profile} = Profile->new();
                              $xfer += $self->{profile}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportProfile_args');
                        if (defined $self->{syncOpRevision}) {
                          $xfer += $output->writeFieldBegin('syncOpRevision', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{syncOpRevision});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{profile}) {
                          $xfer += $output->writeFieldBegin('profile', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{profile}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportProfile_result;
use base qw(Class::Accessor);
TalkService_reportProfile_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportProfile_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportProfile_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportRooms_args;
use base qw(Class::Accessor);
TalkService_reportRooms_args->mk_accessors( qw( syncOpRevision rooms ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{syncOpRevision} = undef;
                        $self->{rooms} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{syncOpRevision}) {
                            $self->{syncOpRevision} = $vals->{syncOpRevision};
                          }
                          if (defined $vals->{rooms}) {
                            $self->{rooms} = $vals->{rooms};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportRooms_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{syncOpRevision});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2046 = 0;
                                $self->{rooms} = [];
                                my $_etype2049 = 0;
                                $xfer += $input->readListBegin(\$_etype2049, \$_size2046);
                                for (my $_i2050 = 0; $_i2050 < $_size2046; ++$_i2050)
                                {
                                  my $elem2051 = undef;
                                  $elem2051 = Room->new();
                                  $xfer += $elem2051->read($input);
                                  push(@{$self->{rooms}},$elem2051);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportRooms_args');
                        if (defined $self->{syncOpRevision}) {
                          $xfer += $output->writeFieldBegin('syncOpRevision', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{syncOpRevision});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{rooms}) {
                          $xfer += $output->writeFieldBegin('rooms', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{rooms}}));
                            {
                              foreach my $iter2052 (@{$self->{rooms}}) 
                              {
                                $xfer += ${iter2052}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportRooms_result;
use base qw(Class::Accessor);
TalkService_reportRooms_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportRooms_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportRooms_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactByMetaTag_args;
use base qw(Class::Accessor);
TalkService_findAndAddContactByMetaTag_args->mk_accessors( qw( reqSeq userid reference ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{userid} = undef;
                        $self->{reference} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                          if (defined $vals->{reference}) {
                            $self->{reference} = $vals->{reference};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactByMetaTag_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{reference});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactByMetaTag_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{reference}) {
                          $xfer += $output->writeFieldBegin('reference', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{reference});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findAndAddContactByMetaTag_result;
use base qw(Class::Accessor);
TalkService_findAndAddContactByMetaTag_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findAndAddContactByMetaTag_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Contact->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findAndAddContactByMetaTag_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportSettings_args;
use base qw(Class::Accessor);
TalkService_reportSettings_args->mk_accessors( qw( syncOpRevision settings ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{syncOpRevision} = undef;
                        $self->{settings} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{syncOpRevision}) {
                            $self->{syncOpRevision} = $vals->{syncOpRevision};
                          }
                          if (defined $vals->{settings}) {
                            $self->{settings} = $vals->{settings};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportSettings_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I64) {
                              $xfer += $input->readI64(\$self->{syncOpRevision});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{settings} = Settings->new();
                              $xfer += $self->{settings}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportSettings_args');
                        if (defined $self->{syncOpRevision}) {
                          $xfer += $output->writeFieldBegin('syncOpRevision', Thrift::TType::I64, 2);
                          $xfer += $output->writeI64($self->{syncOpRevision});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{settings}) {
                          $xfer += $output->writeFieldBegin('settings', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{settings}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportSettings_result;
use base qw(Class::Accessor);
TalkService_reportSettings_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportSettings_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportSettings_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportSpam_args;
use base qw(Class::Accessor);
TalkService_reportSpam_args->mk_accessors( qw( chatMid memberMids spammerReasons senderMids spamMessageIds spamMessages ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{chatMid} = undef;
                        $self->{memberMids} = undef;
                        $self->{spammerReasons} = undef;
                        $self->{senderMids} = undef;
                        $self->{spamMessageIds} = undef;
                        $self->{spamMessages} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{chatMid}) {
                            $self->{chatMid} = $vals->{chatMid};
                          }
                          if (defined $vals->{memberMids}) {
                            $self->{memberMids} = $vals->{memberMids};
                          }
                          if (defined $vals->{spammerReasons}) {
                            $self->{spammerReasons} = $vals->{spammerReasons};
                          }
                          if (defined $vals->{senderMids}) {
                            $self->{senderMids} = $vals->{senderMids};
                          }
                          if (defined $vals->{spamMessageIds}) {
                            $self->{spamMessageIds} = $vals->{spamMessageIds};
                          }
                          if (defined $vals->{spamMessages}) {
                            $self->{spamMessages} = $vals->{spamMessages};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportSpam_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{chatMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2053 = 0;
                                $self->{memberMids} = [];
                                my $_etype2056 = 0;
                                $xfer += $input->readListBegin(\$_etype2056, \$_size2053);
                                for (my $_i2057 = 0; $_i2057 < $_size2053; ++$_i2057)
                                {
                                  my $elem2058 = undef;
                                  $xfer += $input->readString(\$elem2058);
                                  push(@{$self->{memberMids}},$elem2058);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2059 = 0;
                                $self->{spammerReasons} = [];
                                my $_etype2062 = 0;
                                $xfer += $input->readListBegin(\$_etype2062, \$_size2059);
                                for (my $_i2063 = 0; $_i2063 < $_size2059; ++$_i2063)
                                {
                                  my $elem2064 = undef;
                                  $xfer += $input->readI32(\$elem2064);
                                  push(@{$self->{spammerReasons}},$elem2064);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2065 = 0;
                                $self->{senderMids} = [];
                                my $_etype2068 = 0;
                                $xfer += $input->readListBegin(\$_etype2068, \$_size2065);
                                for (my $_i2069 = 0; $_i2069 < $_size2065; ++$_i2069)
                                {
                                  my $elem2070 = undef;
                                  $xfer += $input->readString(\$elem2070);
                                  push(@{$self->{senderMids}},$elem2070);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2071 = 0;
                                $self->{spamMessageIds} = [];
                                my $_etype2074 = 0;
                                $xfer += $input->readListBegin(\$_etype2074, \$_size2071);
                                for (my $_i2075 = 0; $_i2075 < $_size2071; ++$_i2075)
                                {
                                  my $elem2076 = undef;
                                  $xfer += $input->readString(\$elem2076);
                                  push(@{$self->{spamMessageIds}},$elem2076);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2077 = 0;
                                $self->{spamMessages} = [];
                                my $_etype2080 = 0;
                                $xfer += $input->readListBegin(\$_etype2080, \$_size2077);
                                for (my $_i2081 = 0; $_i2081 < $_size2077; ++$_i2081)
                                {
                                  my $elem2082 = undef;
                                  $xfer += $input->readString(\$elem2082);
                                  push(@{$self->{spamMessages}},$elem2082);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportSpam_args');
                        if (defined $self->{chatMid}) {
                          $xfer += $output->writeFieldBegin('chatMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{chatMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{memberMids}) {
                          $xfer += $output->writeFieldBegin('memberMids', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{memberMids}}));
                            {
                              foreach my $iter2083 (@{$self->{memberMids}}) 
                              {
                                $xfer += $output->writeString($iter2083);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{spammerReasons}) {
                          $xfer += $output->writeFieldBegin('spammerReasons', Thrift::TType::LIST, 4);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{spammerReasons}}));
                            {
                              foreach my $iter2084 (@{$self->{spammerReasons}}) 
                              {
                                $xfer += $output->writeI32($iter2084);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{senderMids}) {
                          $xfer += $output->writeFieldBegin('senderMids', Thrift::TType::LIST, 5);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{senderMids}}));
                            {
                              foreach my $iter2085 (@{$self->{senderMids}}) 
                              {
                                $xfer += $output->writeString($iter2085);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{spamMessageIds}) {
                          $xfer += $output->writeFieldBegin('spamMessageIds', Thrift::TType::LIST, 6);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{spamMessageIds}}));
                            {
                              foreach my $iter2086 (@{$self->{spamMessageIds}}) 
                              {
                                $xfer += $output->writeString($iter2086);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{spamMessages}) {
                          $xfer += $output->writeFieldBegin('spamMessages', Thrift::TType::LIST, 7);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{spamMessages}}));
                            {
                              foreach my $iter2087 (@{$self->{spamMessages}}) 
                              {
                                $xfer += $output->writeString($iter2087);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportSpam_result;
use base qw(Class::Accessor);
TalkService_reportSpam_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportSpam_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportSpam_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportSpammer_args;
use base qw(Class::Accessor);
TalkService_reportSpammer_args->mk_accessors( qw( spammerMid spammerReasons spamMessageIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{spammerMid} = undef;
                        $self->{spammerReasons} = undef;
                        $self->{spamMessageIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{spammerMid}) {
                            $self->{spammerMid} = $vals->{spammerMid};
                          }
                          if (defined $vals->{spammerReasons}) {
                            $self->{spammerReasons} = $vals->{spammerReasons};
                          }
                          if (defined $vals->{spamMessageIds}) {
                            $self->{spamMessageIds} = $vals->{spamMessageIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportSpammer_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{spammerMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2088 = 0;
                                $self->{spammerReasons} = [];
                                my $_etype2091 = 0;
                                $xfer += $input->readListBegin(\$_etype2091, \$_size2088);
                                for (my $_i2092 = 0; $_i2092 < $_size2088; ++$_i2092)
                                {
                                  my $elem2093 = undef;
                                  $xfer += $input->readI32(\$elem2093);
                                  push(@{$self->{spammerReasons}},$elem2093);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2094 = 0;
                                $self->{spamMessageIds} = [];
                                my $_etype2097 = 0;
                                $xfer += $input->readListBegin(\$_etype2097, \$_size2094);
                                for (my $_i2098 = 0; $_i2098 < $_size2094; ++$_i2098)
                                {
                                  my $elem2099 = undef;
                                  $xfer += $input->readString(\$elem2099);
                                  push(@{$self->{spamMessageIds}},$elem2099);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportSpammer_args');
                        if (defined $self->{spammerMid}) {
                          $xfer += $output->writeFieldBegin('spammerMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{spammerMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{spammerReasons}) {
                          $xfer += $output->writeFieldBegin('spammerReasons', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{spammerReasons}}));
                            {
                              foreach my $iter2100 (@{$self->{spammerReasons}}) 
                              {
                                $xfer += $output->writeI32($iter2100);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{spamMessageIds}) {
                          $xfer += $output->writeFieldBegin('spamMessageIds', Thrift::TType::LIST, 4);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{spamMessageIds}}));
                            {
                              foreach my $iter2101 (@{$self->{spamMessageIds}}) 
                              {
                                $xfer += $output->writeString($iter2101);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_reportSpammer_result;
use base qw(Class::Accessor);
TalkService_reportSpammer_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_reportSpammer_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_reportSpammer_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestAccountPasswordReset_args;
use base qw(Class::Accessor);
TalkService_requestAccountPasswordReset_args->mk_accessors( qw( provider identifier locale ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{provider} = undef;
                        $self->{identifier} = undef;
                        $self->{locale} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{locale}) {
                            $self->{locale} = $vals->{locale};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestAccountPasswordReset_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{locale});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestAccountPasswordReset_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{locale}) {
                          $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 5);
                          $xfer += $output->writeString($self->{locale});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestAccountPasswordReset_result;
use base qw(Class::Accessor);
TalkService_requestAccountPasswordReset_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestAccountPasswordReset_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestAccountPasswordReset_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestEmailConfirmation_args;
use base qw(Class::Accessor);
TalkService_requestEmailConfirmation_args->mk_accessors( qw( emailConfirmation ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{emailConfirmation} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{emailConfirmation}) {
                            $self->{emailConfirmation} = $vals->{emailConfirmation};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestEmailConfirmation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{emailConfirmation} = EmailConfirmation->new();
                              $xfer += $self->{emailConfirmation}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestEmailConfirmation_args');
                        if (defined $self->{emailConfirmation}) {
                          $xfer += $output->writeFieldBegin('emailConfirmation', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{emailConfirmation}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestEmailConfirmation_result;
use base qw(Class::Accessor);
TalkService_requestEmailConfirmation_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestEmailConfirmation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = EmailConfirmationSession->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestEmailConfirmation_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestIdentityUnbind_args;
use base qw(Class::Accessor);
TalkService_requestIdentityUnbind_args->mk_accessors( qw( provider identifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{provider} = undef;
                        $self->{identifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestIdentityUnbind_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestIdentityUnbind_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestIdentityUnbind_result;
use base qw(Class::Accessor);
TalkService_requestIdentityUnbind_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestIdentityUnbind_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestIdentityUnbind_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_resendEmailConfirmation_args;
use base qw(Class::Accessor);
TalkService_resendEmailConfirmation_args->mk_accessors( qw( verifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_resendEmailConfirmation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_resendEmailConfirmation_args');
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_resendEmailConfirmation_result;
use base qw(Class::Accessor);
TalkService_resendEmailConfirmation_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_resendEmailConfirmation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = EmailConfirmationSession->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_resendEmailConfirmation_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_resendPinCode_args;
use base qw(Class::Accessor);
TalkService_resendPinCode_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_resendPinCode_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_resendPinCode_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_resendPinCode_result;
use base qw(Class::Accessor);
TalkService_resendPinCode_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_resendPinCode_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_resendPinCode_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_resendPinCodeBySMS_args;
use base qw(Class::Accessor);
TalkService_resendPinCodeBySMS_args->mk_accessors( qw( sessionId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_resendPinCodeBySMS_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_resendPinCodeBySMS_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_resendPinCodeBySMS_result;
use base qw(Class::Accessor);
TalkService_resendPinCodeBySMS_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_resendPinCodeBySMS_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_resendPinCodeBySMS_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendChatChecked_args;
use base qw(Class::Accessor);
TalkService_sendChatChecked_args->mk_accessors( qw( seq consumer lastMessageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{consumer} = undef;
                        $self->{lastMessageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{consumer}) {
                            $self->{consumer} = $vals->{consumer};
                          }
                          if (defined $vals->{lastMessageId}) {
                            $self->{lastMessageId} = $vals->{lastMessageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendChatChecked_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{consumer});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{lastMessageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendChatChecked_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{consumer}) {
                          $xfer += $output->writeFieldBegin('consumer', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{consumer});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastMessageId}) {
                          $xfer += $output->writeFieldBegin('lastMessageId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{lastMessageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendChatChecked_result;
use base qw(Class::Accessor);
TalkService_sendChatChecked_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendChatChecked_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendChatChecked_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageAwaitCommit_args;
use base qw(Class::Accessor);
TalkService_sendMessageAwaitCommit_args->mk_accessors( qw( seq message ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{message} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{message}) {
                            $self->{message} = $vals->{message};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageAwaitCommit_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{message} = Message->new();
                              $xfer += $self->{message}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageAwaitCommit_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{message}) {
                          $xfer += $output->writeFieldBegin('message', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{message}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageAwaitCommit_result;
use base qw(Class::Accessor);
TalkService_sendMessageAwaitCommit_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageAwaitCommit_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = CommitMessageResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageAwaitCommit_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendChatRemoved_args;
use base qw(Class::Accessor);
TalkService_sendChatRemoved_args->mk_accessors( qw( seq consumer lastMessageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{consumer} = undef;
                        $self->{lastMessageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{consumer}) {
                            $self->{consumer} = $vals->{consumer};
                          }
                          if (defined $vals->{lastMessageId}) {
                            $self->{lastMessageId} = $vals->{lastMessageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendChatRemoved_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{consumer});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{lastMessageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendChatRemoved_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{consumer}) {
                          $xfer += $output->writeFieldBegin('consumer', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{consumer});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{lastMessageId}) {
                          $xfer += $output->writeFieldBegin('lastMessageId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{lastMessageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendChatRemoved_result;
use base qw(Class::Accessor);
TalkService_sendChatRemoved_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendChatRemoved_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendChatRemoved_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendContentPreviewUpdated_args;
use base qw(Class::Accessor);
TalkService_sendContentPreviewUpdated_args->mk_accessors( qw( esq messageId receiverMids ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{esq} = undef;
                        $self->{messageId} = undef;
                        $self->{receiverMids} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{esq}) {
                            $self->{esq} = $vals->{esq};
                          }
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                          if (defined $vals->{receiverMids}) {
                            $self->{receiverMids} = $vals->{receiverMids};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendContentPreviewUpdated_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{esq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2102 = 0;
                                $self->{receiverMids} = [];
                                my $_etype2105 = 0;
                                $xfer += $input->readListBegin(\$_etype2105, \$_size2102);
                                for (my $_i2106 = 0; $_i2106 < $_size2102; ++$_i2106)
                                {
                                  my $elem2107 = undef;
                                  $xfer += $input->readString(\$elem2107);
                                  push(@{$self->{receiverMids}},$elem2107);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendContentPreviewUpdated_args');
                        if (defined $self->{esq}) {
                          $xfer += $output->writeFieldBegin('esq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{esq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{receiverMids}) {
                          $xfer += $output->writeFieldBegin('receiverMids', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{receiverMids}}));
                            {
                              foreach my $iter2108 (@{$self->{receiverMids}}) 
                              {
                                $xfer += $output->writeString($iter2108);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendContentPreviewUpdated_result;
use base qw(Class::Accessor);
TalkService_sendContentPreviewUpdated_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendContentPreviewUpdated_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size2109 = 0;
                                $self->{success} = {};
                                my $_ktype2110 = 0;
                                my $_vtype2111 = 0;
                                $xfer += $input->readMapBegin(\$_ktype2110, \$_vtype2111, \$_size2109);
                                for (my $_i2113 = 0; $_i2113 < $_size2109; ++$_i2113)
                                {
                                  my $key2114 = '';
                                  my $val2115 = '';
                                  $xfer += $input->readString(\$key2114);
                                  $xfer += $input->readString(\$val2115);
                                  $self->{success}->{$key2114} = $val2115;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendContentPreviewUpdated_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter2116,$viter2117) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter2116);
                                $xfer += $output->writeString($viter2117);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendContentReceipt_args;
use base qw(Class::Accessor);
TalkService_sendContentReceipt_args->mk_accessors( qw( seq consumer messageId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{consumer} = undef;
                        $self->{messageId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{consumer}) {
                            $self->{consumer} = $vals->{consumer};
                          }
                          if (defined $vals->{messageId}) {
                            $self->{messageId} = $vals->{messageId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendContentReceipt_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{consumer});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendContentReceipt_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{consumer}) {
                          $xfer += $output->writeFieldBegin('consumer', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{consumer});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageId}) {
                          $xfer += $output->writeFieldBegin('messageId', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{messageId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendContentReceipt_result;
use base qw(Class::Accessor);
TalkService_sendContentReceipt_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendContentReceipt_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendContentReceipt_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendDummyPush_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendDummyPush_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendDummyPush_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendDummyPush_result;
use base qw(Class::Accessor);
TalkService_sendDummyPush_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendDummyPush_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendDummyPush_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeE2EEPublicKey_args;
use base qw(Class::Accessor);
TalkService_removeE2EEPublicKey_args->mk_accessors( qw( publicKey ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{publicKey} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{publicKey}) {
                            $self->{publicKey} = $vals->{publicKey};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeE2EEPublicKey_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{publicKey} = E2EEPublicKey->new();
                              $xfer += $self->{publicKey}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeE2EEPublicKey_args');
                        if (defined $self->{publicKey}) {
                          $xfer += $output->writeFieldBegin('publicKey', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{publicKey}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_removeE2EEPublicKey_result;
use base qw(Class::Accessor);
TalkService_removeE2EEPublicKey_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_removeE2EEPublicKey_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_removeE2EEPublicKey_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_negotiateE2EEPublicKey_args;
use base qw(Class::Accessor);
TalkService_negotiateE2EEPublicKey_args->mk_accessors( qw( mid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_negotiateE2EEPublicKey_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_negotiateE2EEPublicKey_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_negotiateE2EEPublicKey_result;
use base qw(Class::Accessor);
TalkService_negotiateE2EEPublicKey_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_negotiateE2EEPublicKey_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = E2EENegotiationResult->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_negotiateE2EEPublicKey_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getE2EEPublicKey_args;
use base qw(Class::Accessor);
TalkService_getE2EEPublicKey_args->mk_accessors( qw( mid version keyId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        $self->{version} = undef;
                        $self->{keyId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{version}) {
                            $self->{version} = $vals->{version};
                          }
                          if (defined $vals->{keyId}) {
                            $self->{keyId} = $vals->{keyId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getE2EEPublicKey_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{version});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{keyId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getE2EEPublicKey_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{version}) {
                          $xfer += $output->writeFieldBegin('version', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{version});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{keyId}) {
                          $xfer += $output->writeFieldBegin('keyId', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{keyId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getE2EEPublicKey_result;
use base qw(Class::Accessor);
TalkService_getE2EEPublicKey_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getE2EEPublicKey_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = E2EEPublicKey->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getE2EEPublicKey_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestE2EEKeyExchange_args;
use base qw(Class::Accessor);
TalkService_requestE2EEKeyExchange_args->mk_accessors( qw( reqSeq temporalPublicKey publicKey verifier ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{temporalPublicKey} = undef;
                        $self->{publicKey} = undef;
                        $self->{verifier} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{temporalPublicKey}) {
                            $self->{temporalPublicKey} = $vals->{temporalPublicKey};
                          }
                          if (defined $vals->{publicKey}) {
                            $self->{publicKey} = $vals->{publicKey};
                          }
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestE2EEKeyExchange_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{temporalPublicKey});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{publicKey} = E2EEPublicKey->new();
                              $xfer += $self->{publicKey}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestE2EEKeyExchange_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{temporalPublicKey}) {
                          $xfer += $output->writeFieldBegin('temporalPublicKey', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{temporalPublicKey});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{publicKey}) {
                          $xfer += $output->writeFieldBegin('publicKey', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{publicKey}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_requestE2EEKeyExchange_result;
use base qw(Class::Accessor);
TalkService_requestE2EEKeyExchange_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_requestE2EEKeyExchange_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_requestE2EEKeyExchange_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getLastE2EEPublicKeys_args;
use base qw(Class::Accessor);
TalkService_getLastE2EEPublicKeys_args->mk_accessors( qw( chatMid ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{chatMid} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{chatMid}) {
                            $self->{chatMid} = $vals->{chatMid};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getLastE2EEPublicKeys_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{chatMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getLastE2EEPublicKeys_args');
                        if (defined $self->{chatMid}) {
                          $xfer += $output->writeFieldBegin('chatMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{chatMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getLastE2EEPublicKeys_result;
use base qw(Class::Accessor);
TalkService_getLastE2EEPublicKeys_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getLastE2EEPublicKeys_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size2118 = 0;
                                $self->{success} = {};
                                my $_ktype2119 = 0;
                                my $_vtype2120 = 0;
                                $xfer += $input->readMapBegin(\$_ktype2119, \$_vtype2120, \$_size2118);
                                for (my $_i2122 = 0; $_i2122 < $_size2118; ++$_i2122)
                                {
                                  my $key2123 = '';
                                  my $val2124 = new E2EEPublicKey();
                                  $xfer += $input->readString(\$key2123);
                                  $val2124 = E2EEPublicKey->new();
                                  $xfer += $val2124->read($input);
                                  $self->{success}->{$key2123} = $val2124;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getLastE2EEPublicKeys_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter2125,$viter2126) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter2125);
                                $xfer += ${viter2126}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerE2EEPublicKey_args;
use base qw(Class::Accessor);
TalkService_registerE2EEPublicKey_args->mk_accessors( qw( reqSeq publicKey ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{publicKey} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{publicKey}) {
                            $self->{publicKey} = $vals->{publicKey};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerE2EEPublicKey_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{publicKey} = E2EEPublicKey->new();
                              $xfer += $self->{publicKey}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerE2EEPublicKey_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{publicKey}) {
                          $xfer += $output->writeFieldBegin('publicKey', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{publicKey}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_registerE2EEPublicKey_result;
use base qw(Class::Accessor);
TalkService_registerE2EEPublicKey_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_registerE2EEPublicKey_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = E2EEPublicKey->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_registerE2EEPublicKey_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getE2EEPublicKeys_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getE2EEPublicKeys_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getE2EEPublicKeys_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getE2EEPublicKeys_result;
use base qw(Class::Accessor);
TalkService_getE2EEPublicKeys_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getE2EEPublicKeys_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2127 = 0;
                                $self->{success} = [];
                                my $_etype2130 = 0;
                                $xfer += $input->readListBegin(\$_etype2130, \$_size2127);
                                for (my $_i2131 = 0; $_i2131 < $_size2127; ++$_i2131)
                                {
                                  my $elem2132 = undef;
                                  $elem2132 = E2EEPublicKey->new();
                                  $xfer += $elem2132->read($input);
                                  push(@{$self->{success}},$elem2132);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getE2EEPublicKeys_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2133 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2133}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getE2EEPublicKeysEx_args;
use base qw(Class::Accessor);
TalkService_getE2EEPublicKeysEx_args->mk_accessors( qw( ignoreE2EEStatus ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{ignoreE2EEStatus} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{ignoreE2EEStatus}) {
                            $self->{ignoreE2EEStatus} = $vals->{ignoreE2EEStatus};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getE2EEPublicKeysEx_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{ignoreE2EEStatus});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getE2EEPublicKeysEx_args');
                        if (defined $self->{ignoreE2EEStatus}) {
                          $xfer += $output->writeFieldBegin('ignoreE2EEStatus', Thrift::TType::BOOL, 2);
                          $xfer += $output->writeBool($self->{ignoreE2EEStatus});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getE2EEPublicKeysEx_result;
use base qw(Class::Accessor);
TalkService_getE2EEPublicKeysEx_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getE2EEPublicKeysEx_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2134 = 0;
                                $self->{success} = [];
                                my $_etype2137 = 0;
                                $xfer += $input->readListBegin(\$_etype2137, \$_size2134);
                                for (my $_i2138 = 0; $_i2138 < $_size2134; ++$_i2138)
                                {
                                  my $elem2139 = undef;
                                  $elem2139 = E2EEPublicKey->new();
                                  $xfer += $elem2139->read($input);
                                  push(@{$self->{success}},$elem2139);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getE2EEPublicKeysEx_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2140 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2140}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getReadMessageOpsInBulk_args;
use base qw(Class::Accessor);
TalkService_getReadMessageOpsInBulk_args->mk_accessors( qw( chatIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{chatIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{chatIds}) {
                            $self->{chatIds} = $vals->{chatIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getReadMessageOpsInBulk_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2141 = 0;
                                $self->{chatIds} = [];
                                my $_etype2144 = 0;
                                $xfer += $input->readListBegin(\$_etype2144, \$_size2141);
                                for (my $_i2145 = 0; $_i2145 < $_size2141; ++$_i2145)
                                {
                                  my $elem2146 = undef;
                                  $xfer += $input->readString(\$elem2146);
                                  push(@{$self->{chatIds}},$elem2146);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getReadMessageOpsInBulk_args');
                        if (defined $self->{chatIds}) {
                          $xfer += $output->writeFieldBegin('chatIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{chatIds}}));
                            {
                              foreach my $iter2147 (@{$self->{chatIds}}) 
                              {
                                $xfer += $output->writeString($iter2147);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getReadMessageOpsInBulk_result;
use base qw(Class::Accessor);
TalkService_getReadMessageOpsInBulk_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getReadMessageOpsInBulk_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2148 = 0;
                                $self->{success} = [];
                                my $_etype2151 = 0;
                                $xfer += $input->readListBegin(\$_etype2151, \$_size2148);
                                for (my $_i2152 = 0; $_i2152 < $_size2148; ++$_i2152)
                                {
                                  my $elem2153 = undef;
                                  $elem2153 = Operation->new();
                                  $xfer += $elem2153->read($input);
                                  push(@{$self->{success}},$elem2153);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getReadMessageOpsInBulk_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2154 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2154}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendEvent_args;
use base qw(Class::Accessor);
TalkService_sendEvent_args->mk_accessors( qw( seq message ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{message} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{message}) {
                            $self->{message} = $vals->{message};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendEvent_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{message} = Message->new();
                              $xfer += $self->{message}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendEvent_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{message}) {
                          $xfer += $output->writeFieldBegin('message', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{message}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendEvent_result;
use base qw(Class::Accessor);
TalkService_sendEvent_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendEvent_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Message->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendEvent_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessage_args;
use base qw(Class::Accessor);
TalkService_sendMessage_args->mk_accessors( qw( seq message ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{message} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{message}) {
                            $self->{message} = $vals->{message};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{message} = Message->new();
                              $xfer += $self->{message}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessage_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{message}) {
                          $xfer += $output->writeFieldBegin('message', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{message}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessage_result;
use base qw(Class::Accessor);
TalkService_sendMessage_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Message->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessage_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageIgnored_args;
use base qw(Class::Accessor);
TalkService_sendMessageIgnored_args->mk_accessors( qw( seq consumer messageIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{consumer} = undef;
                        $self->{messageIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{consumer}) {
                            $self->{consumer} = $vals->{consumer};
                          }
                          if (defined $vals->{messageIds}) {
                            $self->{messageIds} = $vals->{messageIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageIgnored_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{consumer});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2155 = 0;
                                $self->{messageIds} = [];
                                my $_etype2158 = 0;
                                $xfer += $input->readListBegin(\$_etype2158, \$_size2155);
                                for (my $_i2159 = 0; $_i2159 < $_size2155; ++$_i2159)
                                {
                                  my $elem2160 = undef;
                                  $xfer += $input->readString(\$elem2160);
                                  push(@{$self->{messageIds}},$elem2160);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageIgnored_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{consumer}) {
                          $xfer += $output->writeFieldBegin('consumer', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{consumer});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageIds}) {
                          $xfer += $output->writeFieldBegin('messageIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{messageIds}}));
                            {
                              foreach my $iter2161 (@{$self->{messageIds}}) 
                              {
                                $xfer += $output->writeString($iter2161);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageIgnored_result;
use base qw(Class::Accessor);
TalkService_sendMessageIgnored_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageIgnored_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageIgnored_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageReceipt_args;
use base qw(Class::Accessor);
TalkService_sendMessageReceipt_args->mk_accessors( qw( seq consumer messageIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{consumer} = undef;
                        $self->{messageIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{consumer}) {
                            $self->{consumer} = $vals->{consumer};
                          }
                          if (defined $vals->{messageIds}) {
                            $self->{messageIds} = $vals->{messageIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageReceipt_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{consumer});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2162 = 0;
                                $self->{messageIds} = [];
                                my $_etype2165 = 0;
                                $xfer += $input->readListBegin(\$_etype2165, \$_size2162);
                                for (my $_i2166 = 0; $_i2166 < $_size2162; ++$_i2166)
                                {
                                  my $elem2167 = undef;
                                  $xfer += $input->readString(\$elem2167);
                                  push(@{$self->{messageIds}},$elem2167);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageReceipt_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{consumer}) {
                          $xfer += $output->writeFieldBegin('consumer', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{consumer});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messageIds}) {
                          $xfer += $output->writeFieldBegin('messageIds', Thrift::TType::LIST, 3);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{messageIds}}));
                            {
                              foreach my $iter2168 (@{$self->{messageIds}}) 
                              {
                                $xfer += $output->writeString($iter2168);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageReceipt_result;
use base qw(Class::Accessor);
TalkService_sendMessageReceipt_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageReceipt_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageReceipt_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactByMetaTag_args;
use base qw(Class::Accessor);
TalkService_findContactByMetaTag_args->mk_accessors( qw( userid reference ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{userid} = undef;
                        $self->{reference} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{userid}) {
                            $self->{userid} = $vals->{userid};
                          }
                          if (defined $vals->{reference}) {
                            $self->{reference} = $vals->{reference};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactByMetaTag_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{userid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{reference});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactByMetaTag_args');
                        if (defined $self->{userid}) {
                          $xfer += $output->writeFieldBegin('userid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{userid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{reference}) {
                          $xfer += $output->writeFieldBegin('reference', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{reference});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_findContactByMetaTag_result;
use base qw(Class::Accessor);
TalkService_findContactByMetaTag_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_findContactByMetaTag_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Contact->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_findContactByMetaTag_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageToMyHome_args;
use base qw(Class::Accessor);
TalkService_sendMessageToMyHome_args->mk_accessors( qw( seq message ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{message} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{message}) {
                            $self->{message} = $vals->{message};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageToMyHome_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{message} = Message->new();
                              $xfer += $self->{message}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageToMyHome_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{message}) {
                          $xfer += $output->writeFieldBegin('message', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{message}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_sendMessageToMyHome_result;
use base qw(Class::Accessor);
TalkService_sendMessageToMyHome_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_sendMessageToMyHome_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Message->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_sendMessageToMyHome_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_setBuddyLocation_args;
use base qw(Class::Accessor);
TalkService_setBuddyLocation_args->mk_accessors( qw( mid index location ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{mid} = undef;
                        $self->{index} = undef;
                        $self->{location} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{index}) {
                            $self->{index} = $vals->{index};
                          }
                          if (defined $vals->{location}) {
                            $self->{location} = $vals->{location};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_setBuddyLocation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{index});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{location} = Geolocation->new();
                              $xfer += $self->{location}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_setBuddyLocation_args');
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{index}) {
                          $xfer += $output->writeFieldBegin('index', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{index});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{location}) {
                          $xfer += $output->writeFieldBegin('location', Thrift::TType::STRUCT, 4);
                          $xfer += $self->{location}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_setBuddyLocation_result;
use base qw(Class::Accessor);
TalkService_setBuddyLocation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_setBuddyLocation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_setBuddyLocation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_setIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_setIdentityCredential_args->mk_accessors( qw( identifier verifier provider ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{identifier} = undef;
                        $self->{verifier} = undef;
                        $self->{provider} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                          if (defined $vals->{provider}) {
                            $self->{provider} = $vals->{provider};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_setIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{provider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_setIdentityCredential_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{provider}) {
                          $xfer += $output->writeFieldBegin('provider', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{provider});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_setIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_setIdentityCredential_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_setIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_setIdentityCredential_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_setNotificationsEnabled_args;
use base qw(Class::Accessor);
TalkService_setNotificationsEnabled_args->mk_accessors( qw( reqSeq type target enablement ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{type} = undef;
                        $self->{target} = undef;
                        $self->{enablement} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{type}) {
                            $self->{type} = $vals->{type};
                          }
                          if (defined $vals->{target}) {
                            $self->{target} = $vals->{target};
                          }
                          if (defined $vals->{enablement}) {
                            $self->{enablement} = $vals->{enablement};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_setNotificationsEnabled_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{type});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{target});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::BOOL) {
                              $xfer += $input->readBool(\$self->{enablement});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_setNotificationsEnabled_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{type}) {
                          $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{type});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{target}) {
                          $xfer += $output->writeFieldBegin('target', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{target});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{enablement}) {
                          $xfer += $output->writeFieldBegin('enablement', Thrift::TType::BOOL, 4);
                          $xfer += $output->writeBool($self->{enablement});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_setNotificationsEnabled_result;
use base qw(Class::Accessor);
TalkService_setNotificationsEnabled_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_setNotificationsEnabled_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_setNotificationsEnabled_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_startUpdateVerification_args;
use base qw(Class::Accessor);
TalkService_startUpdateVerification_args->mk_accessors( qw( region carrier phone udidHash deviceInfo networkCode locale ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{region} = undef;
                        $self->{carrier} = undef;
                        $self->{phone} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        $self->{networkCode} = undef;
                        $self->{locale} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{carrier}) {
                            $self->{carrier} = $vals->{carrier};
                          }
                          if (defined $vals->{phone}) {
                            $self->{phone} = $vals->{phone};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                          if (defined $vals->{networkCode}) {
                            $self->{networkCode} = $vals->{networkCode};
                          }
                          if (defined $vals->{locale}) {
                            $self->{locale} = $vals->{locale};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_startUpdateVerification_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{carrier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{phone});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{networkCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^8$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{locale});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_startUpdateVerification_args');
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{carrier}) {
                          $xfer += $output->writeFieldBegin('carrier', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{carrier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{phone}) {
                          $xfer += $output->writeFieldBegin('phone', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{phone});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 5);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 6);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{networkCode}) {
                          $xfer += $output->writeFieldBegin('networkCode', Thrift::TType::STRING, 7);
                          $xfer += $output->writeString($self->{networkCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{locale}) {
                          $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 8);
                          $xfer += $output->writeString($self->{locale});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_startUpdateVerification_result;
use base qw(Class::Accessor);
TalkService_startUpdateVerification_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_startUpdateVerification_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = VerificationSessionData->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_startUpdateVerification_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_startVerification_args;
use base qw(Class::Accessor);
TalkService_startVerification_args->mk_accessors( qw( region carrier phone udidHash deviceInfo networkCode mid locale simInfo oldUdidHash ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{region} = undef;
                        $self->{carrier} = undef;
                        $self->{phone} = undef;
                        $self->{udidHash} = undef;
                        $self->{deviceInfo} = undef;
                        $self->{networkCode} = undef;
                        $self->{mid} = undef;
                        $self->{locale} = undef;
                        $self->{simInfo} = undef;
                        $self->{oldUdidHash} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                          if (defined $vals->{carrier}) {
                            $self->{carrier} = $vals->{carrier};
                          }
                          if (defined $vals->{phone}) {
                            $self->{phone} = $vals->{phone};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                          if (defined $vals->{networkCode}) {
                            $self->{networkCode} = $vals->{networkCode};
                          }
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{locale}) {
                            $self->{locale} = $vals->{locale};
                          }
                          if (defined $vals->{simInfo}) {
                            $self->{simInfo} = $vals->{simInfo};
                          }
                          if (defined $vals->{oldUdidHash}) {
                            $self->{oldUdidHash} = $vals->{oldUdidHash};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_startVerification_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{carrier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{phone});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^5$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^6$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^7$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{networkCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^8$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^9$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{locale});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^10$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{simInfo} = SIMInfo->new();
                              $xfer += $self->{simInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^11$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{oldUdidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_startVerification_args');
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{carrier}) {
                          $xfer += $output->writeFieldBegin('carrier', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{carrier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{phone}) {
                          $xfer += $output->writeFieldBegin('phone', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{phone});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 5);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 6);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{networkCode}) {
                          $xfer += $output->writeFieldBegin('networkCode', Thrift::TType::STRING, 7);
                          $xfer += $output->writeString($self->{networkCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 8);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{locale}) {
                          $xfer += $output->writeFieldBegin('locale', Thrift::TType::STRING, 9);
                          $xfer += $output->writeString($self->{locale});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{simInfo}) {
                          $xfer += $output->writeFieldBegin('simInfo', Thrift::TType::STRUCT, 10);
                          $xfer += $self->{simInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{oldUdidHash}) {
                          $xfer += $output->writeFieldBegin('oldUdidHash', Thrift::TType::STRING, 11);
                          $xfer += $output->writeString($self->{oldUdidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_startVerification_result;
use base qw(Class::Accessor);
TalkService_startVerification_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_startVerification_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = VerificationSessionData->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_startVerification_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateGroupPreferenceAttribute_args;
use base qw(Class::Accessor);
TalkService_updateGroupPreferenceAttribute_args->mk_accessors( qw( reqSeq groupMid updatedAttrs ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{groupMid} = undef;
                        $self->{updatedAttrs} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{groupMid}) {
                            $self->{groupMid} = $vals->{groupMid};
                          }
                          if (defined $vals->{updatedAttrs}) {
                            $self->{updatedAttrs} = $vals->{updatedAttrs};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateGroupPreferenceAttribute_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{groupMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size2169 = 0;
                                $self->{updatedAttrs} = {};
                                my $_ktype2170 = 0;
                                my $_vtype2171 = 0;
                                $xfer += $input->readMapBegin(\$_ktype2170, \$_vtype2171, \$_size2169);
                                for (my $_i2173 = 0; $_i2173 < $_size2169; ++$_i2173)
                                {
                                  my $key2174 = 0;
                                  my $val2175 = '';
                                  $xfer += $input->readI32(\$key2174);
                                  $xfer += $input->readString(\$val2175);
                                  $self->{updatedAttrs}->{$key2174} = $val2175;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateGroupPreferenceAttribute_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{groupMid}) {
                          $xfer += $output->writeFieldBegin('groupMid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{groupMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{updatedAttrs}) {
                          $xfer += $output->writeFieldBegin('updatedAttrs', Thrift::TType::MAP, 3);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::STRING, scalar(keys %{$self->{updatedAttrs}}));
                            {
                              while( my ($kiter2176,$viter2177) = each %{$self->{updatedAttrs}}) 
                              {
                                $xfer += $output->writeI32($kiter2176);
                                $xfer += $output->writeString($viter2177);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateGroupPreferenceAttribute_result;
use base qw(Class::Accessor);
TalkService_updateGroupPreferenceAttribute_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateGroupPreferenceAttribute_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateGroupPreferenceAttribute_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createRoomV2_args;
use base qw(Class::Accessor);
TalkService_createRoomV2_args->mk_accessors( qw( reqSeq contactIds ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{contactIds} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{contactIds}) {
                            $self->{contactIds} = $vals->{contactIds};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createRoomV2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2178 = 0;
                                $self->{contactIds} = [];
                                my $_etype2181 = 0;
                                $xfer += $input->readListBegin(\$_etype2181, \$_size2178);
                                for (my $_i2182 = 0; $_i2182 < $_size2178; ++$_i2182)
                                {
                                  my $elem2183 = undef;
                                  $xfer += $input->readString(\$elem2183);
                                  push(@{$self->{contactIds}},$elem2183);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createRoomV2_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{contactIds}) {
                          $xfer += $output->writeFieldBegin('contactIds', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contactIds}}));
                            {
                              foreach my $iter2184 (@{$self->{contactIds}}) 
                              {
                                $xfer += $output->writeString($iter2184);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_createRoomV2_result;
use base qw(Class::Accessor);
TalkService_createRoomV2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_createRoomV2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Room->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_createRoomV2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_storeUpdateProfileAttribute_args;
use base qw(Class::Accessor);
TalkService_storeUpdateProfileAttribute_args->mk_accessors( qw( seq profileAttribute value ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{profileAttribute} = undef;
                        $self->{value} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{profileAttribute}) {
                            $self->{profileAttribute} = $vals->{profileAttribute};
                          }
                          if (defined $vals->{value}) {
                            $self->{value} = $vals->{value};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_storeUpdateProfileAttribute_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{profileAttribute});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{value});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_storeUpdateProfileAttribute_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{profileAttribute}) {
                          $xfer += $output->writeFieldBegin('profileAttribute', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{profileAttribute});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{value}) {
                          $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{value});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_storeUpdateProfileAttribute_result;
use base qw(Class::Accessor);
TalkService_storeUpdateProfileAttribute_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_storeUpdateProfileAttribute_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_storeUpdateProfileAttribute_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_syncContactBySnsIds_args;
use base qw(Class::Accessor);
TalkService_syncContactBySnsIds_args->mk_accessors( qw( reqSeq modifications ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{modifications} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{modifications}) {
                            $self->{modifications} = $vals->{modifications};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_syncContactBySnsIds_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2185 = 0;
                                $self->{modifications} = [];
                                my $_etype2188 = 0;
                                $xfer += $input->readListBegin(\$_etype2188, \$_size2185);
                                for (my $_i2189 = 0; $_i2189 < $_size2185; ++$_i2189)
                                {
                                  my $elem2190 = undef;
                                  $elem2190 = SnsFriendModification->new();
                                  $xfer += $elem2190->read($input);
                                  push(@{$self->{modifications}},$elem2190);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_syncContactBySnsIds_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{modifications}) {
                          $xfer += $output->writeFieldBegin('modifications', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{modifications}}));
                            {
                              foreach my $iter2191 (@{$self->{modifications}}) 
                              {
                                $xfer += ${iter2191}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_syncContactBySnsIds_result;
use base qw(Class::Accessor);
TalkService_syncContactBySnsIds_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_syncContactBySnsIds_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2192 = 0;
                                $self->{success} = [];
                                my $_etype2195 = 0;
                                $xfer += $input->readListBegin(\$_etype2195, \$_size2192);
                                for (my $_i2196 = 0; $_i2196 < $_size2192; ++$_i2196)
                                {
                                  my $elem2197 = undef;
                                  $elem2197 = SnsFriendContactRegistration->new();
                                  $xfer += $elem2197->read($input);
                                  push(@{$self->{success}},$elem2197);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_syncContactBySnsIds_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2198 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2198}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_syncContacts_args;
use base qw(Class::Accessor);
TalkService_syncContacts_args->mk_accessors( qw( reqSeq localContacts ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{localContacts} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{localContacts}) {
                            $self->{localContacts} = $vals->{localContacts};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_syncContacts_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2199 = 0;
                                $self->{localContacts} = [];
                                my $_etype2202 = 0;
                                $xfer += $input->readListBegin(\$_etype2202, \$_size2199);
                                for (my $_i2203 = 0; $_i2203 < $_size2199; ++$_i2203)
                                {
                                  my $elem2204 = undef;
                                  $elem2204 = ContactModification->new();
                                  $xfer += $elem2204->read($input);
                                  push(@{$self->{localContacts}},$elem2204);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_syncContacts_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{localContacts}) {
                          $xfer += $output->writeFieldBegin('localContacts', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{localContacts}}));
                            {
                              foreach my $iter2205 (@{$self->{localContacts}}) 
                              {
                                $xfer += ${iter2205}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_syncContacts_result;
use base qw(Class::Accessor);
TalkService_syncContacts_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_syncContacts_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size2206 = 0;
                                $self->{success} = {};
                                my $_ktype2207 = 0;
                                my $_vtype2208 = 0;
                                $xfer += $input->readMapBegin(\$_ktype2207, \$_vtype2208, \$_size2206);
                                for (my $_i2210 = 0; $_i2210 < $_size2206; ++$_i2210)
                                {
                                  my $key2211 = '';
                                  my $val2212 = new ContactRegistration();
                                  $xfer += $input->readString(\$key2211);
                                  $val2212 = ContactRegistration->new();
                                  $xfer += $val2212->read($input);
                                  $self->{success}->{$key2211} = $val2212;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_syncContacts_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter2213,$viter2214) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter2213);
                                $xfer += ${viter2214}->write($output);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_trySendMessage_args;
use base qw(Class::Accessor);
TalkService_trySendMessage_args->mk_accessors( qw( seq message ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{seq} = undef;
                        $self->{message} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{seq}) {
                            $self->{seq} = $vals->{seq};
                          }
                          if (defined $vals->{message}) {
                            $self->{message} = $vals->{message};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_trySendMessage_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{seq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{message} = Message->new();
                              $xfer += $self->{message}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_trySendMessage_args');
                        if (defined $self->{seq}) {
                          $xfer += $output->writeFieldBegin('seq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{seq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{message}) {
                          $xfer += $output->writeFieldBegin('message', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{message}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_trySendMessage_result;
use base qw(Class::Accessor);
TalkService_trySendMessage_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_trySendMessage_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = Message->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_trySendMessage_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getNextMessagesV2_args;
use base qw(Class::Accessor);
TalkService_getNextMessagesV2_args->mk_accessors( qw( messageBoxId startMessageId messagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        $self->{startMessageId} = undef;
                        $self->{messagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{startMessageId}) {
                            $self->{startMessageId} = $vals->{startMessageId};
                          }
                          if (defined $vals->{messagesCount}) {
                            $self->{messagesCount} = $vals->{messagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getNextMessagesV2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{startMessageId} = MessageBoxV2MessageId->new();
                              $xfer += $self->{startMessageId}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getNextMessagesV2_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{startMessageId}) {
                          $xfer += $output->writeFieldBegin('startMessageId', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{startMessageId}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messagesCount}) {
                          $xfer += $output->writeFieldBegin('messagesCount', Thrift::TType::I32, 4);
                          $xfer += $output->writeI32($self->{messagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getNextMessagesV2_result;
use base qw(Class::Accessor);
TalkService_getNextMessagesV2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getNextMessagesV2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2215 = 0;
                                $self->{success} = [];
                                my $_etype2218 = 0;
                                $xfer += $input->readListBegin(\$_etype2218, \$_size2215);
                                for (my $_i2219 = 0; $_i2219 < $_size2215; ++$_i2219)
                                {
                                  my $elem2220 = undef;
                                  $elem2220 = Message->new();
                                  $xfer += $elem2220->read($input);
                                  push(@{$self->{success}},$elem2220);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getNextMessagesV2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2221 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2221}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxCompactWrapUpV2_args;
use base qw(Class::Accessor);
TalkService_getMessageBoxCompactWrapUpV2_args->mk_accessors( qw( messageBoxId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxCompactWrapUpV2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxCompactWrapUpV2_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getMessageBoxCompactWrapUpV2_result;
use base qw(Class::Accessor);
TalkService_getMessageBoxCompactWrapUpV2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getMessageBoxCompactWrapUpV2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = TMessageBoxWrapUp->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getMessageBoxCompactWrapUpV2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRecentMessagesV2_args;
use base qw(Class::Accessor);
TalkService_getRecentMessagesV2_args->mk_accessors( qw( messageBoxId messagesCount ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{messageBoxId} = undef;
                        $self->{messagesCount} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{messageBoxId}) {
                            $self->{messageBoxId} = $vals->{messageBoxId};
                          }
                          if (defined $vals->{messagesCount}) {
                            $self->{messagesCount} = $vals->{messagesCount};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRecentMessagesV2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{messageBoxId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{messagesCount});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRecentMessagesV2_args');
                        if (defined $self->{messageBoxId}) {
                          $xfer += $output->writeFieldBegin('messageBoxId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{messageBoxId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{messagesCount}) {
                          $xfer += $output->writeFieldBegin('messagesCount', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{messagesCount});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_getRecentMessagesV2_result;
use base qw(Class::Accessor);
TalkService_getRecentMessagesV2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_getRecentMessagesV2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2222 = 0;
                                $self->{success} = [];
                                my $_etype2225 = 0;
                                $xfer += $input->readListBegin(\$_etype2225, \$_size2222);
                                for (my $_i2226 = 0; $_i2226 < $_size2222; ++$_i2226)
                                {
                                  my $elem2227 = undef;
                                  $elem2227 = Message->new();
                                  $xfer += $elem2227->read($input);
                                  push(@{$self->{success}},$elem2227);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_getRecentMessagesV2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter2228 (@{$self->{success}}) 
                              {
                                $xfer += ${iter2228}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_validateContactsOnBot_args;
use base qw(Class::Accessor);
TalkService_validateContactsOnBot_args->mk_accessors( qw( contacts ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{contacts} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{contacts}) {
                            $self->{contacts} = $vals->{contacts};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_validateContactsOnBot_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::LIST) {
                              {
                                my $_size2229 = 0;
                                $self->{contacts} = [];
                                my $_etype2232 = 0;
                                $xfer += $input->readListBegin(\$_etype2232, \$_size2229);
                                for (my $_i2233 = 0; $_i2233 < $_size2229; ++$_i2233)
                                {
                                  my $elem2234 = undef;
                                  $xfer += $input->readString(\$elem2234);
                                  push(@{$self->{contacts}},$elem2234);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_validateContactsOnBot_args');
                        if (defined $self->{contacts}) {
                          $xfer += $output->writeFieldBegin('contacts', Thrift::TType::LIST, 2);
                          {
                            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{contacts}}));
                            {
                              foreach my $iter2235 (@{$self->{contacts}}) 
                              {
                                $xfer += $output->writeString($iter2235);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_validateContactsOnBot_result;
use base qw(Class::Accessor);
TalkService_validateContactsOnBot_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_validateContactsOnBot_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size2236 = 0;
                                $self->{success} = {};
                                my $_ktype2237 = 0;
                                my $_vtype2238 = 0;
                                $xfer += $input->readMapBegin(\$_ktype2237, \$_vtype2238, \$_size2236);
                                for (my $_i2240 = 0; $_i2240 < $_size2236; ++$_i2240)
                                {
                                  my $key2241 = '';
                                  my $val2242 = '';
                                  $xfer += $input->readString(\$key2241);
                                  $xfer += $input->readString(\$val2242);
                                  $self->{success}->{$key2241} = $val2242;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_validateContactsOnBot_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
                            {
                              while( my ($kiter2243,$viter2244) = each %{$self->{success}}) 
                              {
                                $xfer += $output->writeString($kiter2243);
                                $xfer += $output->writeString($viter2244);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_tryFriendRequest_args;
use base qw(Class::Accessor);
TalkService_tryFriendRequest_args->mk_accessors( qw( midOrEMid method friendRequestParams ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{midOrEMid} = undef;
                        $self->{method} = undef;
                        $self->{friendRequestParams} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{midOrEMid}) {
                            $self->{midOrEMid} = $vals->{midOrEMid};
                          }
                          if (defined $vals->{method}) {
                            $self->{method} = $vals->{method};
                          }
                          if (defined $vals->{friendRequestParams}) {
                            $self->{friendRequestParams} = $vals->{friendRequestParams};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_tryFriendRequest_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{midOrEMid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{method});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{friendRequestParams});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_tryFriendRequest_args');
                        if (defined $self->{midOrEMid}) {
                          $xfer += $output->writeFieldBegin('midOrEMid', Thrift::TType::STRING, 1);
                          $xfer += $output->writeString($self->{midOrEMid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{method}) {
                          $xfer += $output->writeFieldBegin('method', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{method});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{friendRequestParams}) {
                          $xfer += $output->writeFieldBegin('friendRequestParams', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{friendRequestParams});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_tryFriendRequest_result;
use base qw(Class::Accessor);
TalkService_tryFriendRequest_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_tryFriendRequest_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_tryFriendRequest_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unblockContact_args;
use base qw(Class::Accessor);
TalkService_unblockContact_args->mk_accessors( qw( reqSeq id ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{id} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{id}) {
                            $self->{id} = $vals->{id};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unblockContact_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{id});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unblockContact_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{id}) {
                          $xfer += $output->writeFieldBegin('id', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{id});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unblockContact_result;
use base qw(Class::Accessor);
TalkService_unblockContact_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unblockContact_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unblockContact_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unblockRecommendation_args;
use base qw(Class::Accessor);
TalkService_unblockRecommendation_args->mk_accessors( qw( reqSeq id ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{id} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{id}) {
                            $self->{id} = $vals->{id};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unblockRecommendation_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{id});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unblockRecommendation_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{id}) {
                          $xfer += $output->writeFieldBegin('id', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{id});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unblockRecommendation_result;
use base qw(Class::Accessor);
TalkService_unblockRecommendation_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unblockRecommendation_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unblockRecommendation_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unregisterUserAndDevice_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unregisterUserAndDevice_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unregisterUserAndDevice_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_unregisterUserAndDevice_result;
use base qw(Class::Accessor);
TalkService_unregisterUserAndDevice_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_unregisterUserAndDevice_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_unregisterUserAndDevice_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateApnsDeviceToken_args;
use base qw(Class::Accessor);
TalkService_updateApnsDeviceToken_args->mk_accessors( qw( apnsDeviceToken ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{apnsDeviceToken} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{apnsDeviceToken}) {
                            $self->{apnsDeviceToken} = $vals->{apnsDeviceToken};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateApnsDeviceToken_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{apnsDeviceToken});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateApnsDeviceToken_args');
                        if (defined $self->{apnsDeviceToken}) {
                          $xfer += $output->writeFieldBegin('apnsDeviceToken', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{apnsDeviceToken});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateApnsDeviceToken_result;
use base qw(Class::Accessor);
TalkService_updateApnsDeviceToken_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateApnsDeviceToken_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateApnsDeviceToken_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateBuddySetting_args;
use base qw(Class::Accessor);
TalkService_updateBuddySetting_args->mk_accessors( qw( key value ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{key} = undef;
                        $self->{value} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{key}) {
                            $self->{key} = $vals->{key};
                          }
                          if (defined $vals->{value}) {
                            $self->{value} = $vals->{value};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateBuddySetting_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{key});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{value});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateBuddySetting_args');
                        if (defined $self->{key}) {
                          $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{key});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{value}) {
                          $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{value});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateBuddySetting_result;
use base qw(Class::Accessor);
TalkService_updateBuddySetting_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateBuddySetting_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateBuddySetting_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateC2DMRegistrationId_args;
use base qw(Class::Accessor);
TalkService_updateC2DMRegistrationId_args->mk_accessors( qw( registrationId ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{registrationId} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{registrationId}) {
                            $self->{registrationId} = $vals->{registrationId};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateC2DMRegistrationId_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{registrationId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateC2DMRegistrationId_args');
                        if (defined $self->{registrationId}) {
                          $xfer += $output->writeFieldBegin('registrationId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{registrationId});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateC2DMRegistrationId_result;
use base qw(Class::Accessor);
TalkService_updateC2DMRegistrationId_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateC2DMRegistrationId_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateC2DMRegistrationId_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateContactSetting_args;
use base qw(Class::Accessor);
TalkService_updateContactSetting_args->mk_accessors( qw( reqSeq mid flag value ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{mid} = undef;
                        $self->{flag} = undef;
                        $self->{value} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{mid}) {
                            $self->{mid} = $vals->{mid};
                          }
                          if (defined $vals->{flag}) {
                            $self->{flag} = $vals->{flag};
                          }
                          if (defined $vals->{value}) {
                            $self->{value} = $vals->{value};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateContactSetting_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{mid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{flag});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{value});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateContactSetting_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{mid}) {
                          $xfer += $output->writeFieldBegin('mid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{mid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{flag}) {
                          $xfer += $output->writeFieldBegin('flag', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{flag});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{value}) {
                          $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{value});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateContactSetting_result;
use base qw(Class::Accessor);
TalkService_updateContactSetting_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateContactSetting_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateContactSetting_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateCustomModeSettings_args;
use base qw(Class::Accessor);
TalkService_updateCustomModeSettings_args->mk_accessors( qw( customMode paramMap ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{customMode} = undef;
                        $self->{paramMap} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{customMode}) {
                            $self->{customMode} = $vals->{customMode};
                          }
                          if (defined $vals->{paramMap}) {
                            $self->{paramMap} = $vals->{paramMap};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateCustomModeSettings_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{customMode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::MAP) {
                              {
                                my $_size2245 = 0;
                                $self->{paramMap} = {};
                                my $_ktype2246 = 0;
                                my $_vtype2247 = 0;
                                $xfer += $input->readMapBegin(\$_ktype2246, \$_vtype2247, \$_size2245);
                                for (my $_i2249 = 0; $_i2249 < $_size2245; ++$_i2249)
                                {
                                  my $key2250 = '';
                                  my $val2251 = '';
                                  $xfer += $input->readString(\$key2250);
                                  $xfer += $input->readString(\$val2251);
                                  $self->{paramMap}->{$key2250} = $val2251;
                                }
                                $xfer += $input->readMapEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateCustomModeSettings_args');
                        if (defined $self->{customMode}) {
                          $xfer += $output->writeFieldBegin('customMode', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{customMode});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{paramMap}) {
                          $xfer += $output->writeFieldBegin('paramMap', Thrift::TType::MAP, 3);
                          {
                            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{paramMap}}));
                            {
                              while( my ($kiter2252,$viter2253) = each %{$self->{paramMap}}) 
                              {
                                $xfer += $output->writeString($kiter2252);
                                $xfer += $output->writeString($viter2253);
                              }
                            }
                            $xfer += $output->writeMapEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateCustomModeSettings_result;
use base qw(Class::Accessor);
TalkService_updateCustomModeSettings_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateCustomModeSettings_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateCustomModeSettings_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateDeviceInfo_args;
use base qw(Class::Accessor);
TalkService_updateDeviceInfo_args->mk_accessors( qw( deviceUid deviceInfo ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{deviceUid} = undef;
                        $self->{deviceInfo} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{deviceUid}) {
                            $self->{deviceUid} = $vals->{deviceUid};
                          }
                          if (defined $vals->{deviceInfo}) {
                            $self->{deviceInfo} = $vals->{deviceInfo};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateDeviceInfo_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{deviceUid});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{deviceInfo} = DeviceInfo->new();
                              $xfer += $self->{deviceInfo}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateDeviceInfo_args');
                        if (defined $self->{deviceUid}) {
                          $xfer += $output->writeFieldBegin('deviceUid', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{deviceUid});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{deviceInfo}) {
                          $xfer += $output->writeFieldBegin('deviceInfo', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{deviceInfo}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateDeviceInfo_result;
use base qw(Class::Accessor);
TalkService_updateDeviceInfo_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateDeviceInfo_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateDeviceInfo_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateGroup_args;
use base qw(Class::Accessor);
TalkService_updateGroup_args->mk_accessors( qw( reqSeq group ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{group} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{group}) {
                            $self->{group} = $vals->{group};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateGroup_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{group} = Group->new();
                              $xfer += $self->{group}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateGroup_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{group}) {
                          $xfer += $output->writeFieldBegin('group', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{group}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateGroup_result;
use base qw(Class::Accessor);
TalkService_updateGroup_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateGroup_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateGroup_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateNotificationToken_args;
use base qw(Class::Accessor);
TalkService_updateNotificationToken_args->mk_accessors( qw( type token ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{type} = undef;
                        $self->{token} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{type}) {
                            $self->{type} = $vals->{type};
                          }
                          if (defined $vals->{token}) {
                            $self->{token} = $vals->{token};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateNotificationToken_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{type});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{token});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateNotificationToken_args');
                        if (defined $self->{token}) {
                          $xfer += $output->writeFieldBegin('token', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{token});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{type}) {
                          $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{type});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateNotificationToken_result;
use base qw(Class::Accessor);
TalkService_updateNotificationToken_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateNotificationToken_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateNotificationToken_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateNotificationTokenWithBytes_args;
use base qw(Class::Accessor);
TalkService_updateNotificationTokenWithBytes_args->mk_accessors( qw( type token ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{type} = undef;
                        $self->{token} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{type}) {
                            $self->{type} = $vals->{type};
                          }
                          if (defined $vals->{token}) {
                            $self->{token} = $vals->{token};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateNotificationTokenWithBytes_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^3$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{type});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{token});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateNotificationTokenWithBytes_args');
                        if (defined $self->{token}) {
                          $xfer += $output->writeFieldBegin('token', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{token});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{type}) {
                          $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 3);
                          $xfer += $output->writeI32($self->{type});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateNotificationTokenWithBytes_result;
use base qw(Class::Accessor);
TalkService_updateNotificationTokenWithBytes_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateNotificationTokenWithBytes_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateNotificationTokenWithBytes_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateProfile_args;
use base qw(Class::Accessor);
TalkService_updateProfile_args->mk_accessors( qw( reqSeq profile ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{profile} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{profile}) {
                            $self->{profile} = $vals->{profile};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateProfile_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{profile} = Profile->new();
                              $xfer += $self->{profile}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateProfile_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{profile}) {
                          $xfer += $output->writeFieldBegin('profile', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{profile}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateProfile_result;
use base qw(Class::Accessor);
TalkService_updateProfile_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateProfile_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateProfile_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateProfileAttribute_args;
use base qw(Class::Accessor);
TalkService_updateProfileAttribute_args->mk_accessors( qw( reqSeq attr value ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{attr} = undef;
                        $self->{value} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{attr}) {
                            $self->{attr} = $vals->{attr};
                          }
                          if (defined $vals->{value}) {
                            $self->{value} = $vals->{value};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateProfileAttribute_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{attr});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{value});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateProfileAttribute_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{attr}) {
                          $xfer += $output->writeFieldBegin('attr', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{attr});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{value}) {
                          $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{value});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateProfileAttribute_result;
use base qw(Class::Accessor);
TalkService_updateProfileAttribute_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateProfileAttribute_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateProfileAttribute_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateProfileAttributes_args;
use base qw(Class::Accessor);
TalkService_updateProfileAttributes_args->mk_accessors( qw( reqSeq request ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{request} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{request}) {
                            $self->{request} = $vals->{request};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateProfileAttributes_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{request} = UpdateProfileAttributesRequest->new();
                              $xfer += $self->{request}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateProfileAttributes_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{request}) {
                          $xfer += $output->writeFieldBegin('request', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{request}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateProfileAttributes_result;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateProfileAttributes_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateProfileAttributes_result');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateRegion_args;
use base qw(Class::Accessor);
TalkService_updateRegion_args->mk_accessors( qw( region ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{region} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{region}) {
                            $self->{region} = $vals->{region};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateRegion_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{region});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateRegion_args');
                        if (defined $self->{region}) {
                          $xfer += $output->writeFieldBegin('region', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{region});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateRegion_result;
use base qw(Class::Accessor);
TalkService_updateRegion_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateRegion_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateRegion_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettings_args;
use base qw(Class::Accessor);
TalkService_updateSettings_args->mk_accessors( qw( reqSeq settings ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{settings} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{settings}) {
                            $self->{settings} = $vals->{settings};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettings_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{settings} = Settings->new();
                              $xfer += $self->{settings}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettings_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{settings}) {
                          $xfer += $output->writeFieldBegin('settings', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{settings}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettings_result;
use base qw(Class::Accessor);
TalkService_updateSettings_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettings_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettings_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettings2_args;
use base qw(Class::Accessor);
TalkService_updateSettings2_args->mk_accessors( qw( reqSeq settings ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{settings} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{settings}) {
                            $self->{settings} = $vals->{settings};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettings2_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{settings} = Settings->new();
                              $xfer += $self->{settings}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettings2_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{settings}) {
                          $xfer += $output->writeFieldBegin('settings', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{settings}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettings2_result;
use base qw(Class::Accessor);
TalkService_updateSettings2_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettings2_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettings2_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
                          $xfer += $output->writeI32($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettingsAttribute_args;
use base qw(Class::Accessor);
TalkService_updateSettingsAttribute_args->mk_accessors( qw( reqSeq attr value ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{attr} = undef;
                        $self->{value} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{attr}) {
                            $self->{attr} = $vals->{attr};
                          }
                          if (defined $vals->{value}) {
                            $self->{value} = $vals->{value};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettingsAttribute_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{attr});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{value});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettingsAttribute_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{attr}) {
                          $xfer += $output->writeFieldBegin('attr', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{attr});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{value}) {
                          $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{value});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettingsAttribute_result;
use base qw(Class::Accessor);
TalkService_updateSettingsAttribute_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettingsAttribute_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettingsAttribute_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettingsAttributes_args;
use base qw(Class::Accessor);
TalkService_updateSettingsAttributes_args->mk_accessors( qw( reqSeq attrBitset settings ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{reqSeq} = undef;
                        $self->{attrBitset} = undef;
                        $self->{settings} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{reqSeq}) {
                            $self->{reqSeq} = $vals->{reqSeq};
                          }
                          if (defined $vals->{attrBitset}) {
                            $self->{attrBitset} = $vals->{attrBitset};
                          }
                          if (defined $vals->{settings}) {
                            $self->{settings} = $vals->{settings};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettingsAttributes_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{reqSeq});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^2$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{attrBitset});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{settings} = Settings->new();
                              $xfer += $self->{settings}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettingsAttributes_args');
                        if (defined $self->{reqSeq}) {
                          $xfer += $output->writeFieldBegin('reqSeq', Thrift::TType::I32, 1);
                          $xfer += $output->writeI32($self->{reqSeq});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{attrBitset}) {
                          $xfer += $output->writeFieldBegin('attrBitset', Thrift::TType::I32, 2);
                          $xfer += $output->writeI32($self->{attrBitset});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{settings}) {
                          $xfer += $output->writeFieldBegin('settings', Thrift::TType::STRUCT, 3);
                          $xfer += $self->{settings}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_updateSettingsAttributes_result;
use base qw(Class::Accessor);
TalkService_updateSettingsAttributes_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_updateSettingsAttributes_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_updateSettingsAttributes_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
                          $xfer += $output->writeI32($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyIdentityCredential_args;
use base qw(Class::Accessor);
TalkService_verifyIdentityCredential_args->mk_accessors( qw( identityProvider identifier password ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{identityProvider} = undef;
                        $self->{identifier} = undef;
                        $self->{password} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{identityProvider}) {
                            $self->{identityProvider} = $vals->{identityProvider};
                          }
                          if (defined $vals->{identifier}) {
                            $self->{identifier} = $vals->{identifier};
                          }
                          if (defined $vals->{password}) {
                            $self->{password} = $vals->{password};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyIdentityCredential_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^8$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{identityProvider});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{identifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{password});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyIdentityCredential_args');
                        if (defined $self->{identifier}) {
                          $xfer += $output->writeFieldBegin('identifier', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{identifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{password}) {
                          $xfer += $output->writeFieldBegin('password', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{password});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{identityProvider}) {
                          $xfer += $output->writeFieldBegin('identityProvider', Thrift::TType::I32, 8);
                          $xfer += $output->writeI32($self->{identityProvider});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyIdentityCredential_result;
use base qw(Class::Accessor);
TalkService_verifyIdentityCredential_result->mk_accessors( qw( ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyIdentityCredential_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyIdentityCredential_result');
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyIdentityCredentialWithResult_args;
use base qw(Class::Accessor);
TalkService_verifyIdentityCredentialWithResult_args->mk_accessors( qw( identityCredential ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{identityCredential} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{identityCredential}) {
                            $self->{identityCredential} = $vals->{identityCredential};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyIdentityCredentialWithResult_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{identityCredential} = IdentityCredential->new();
                              $xfer += $self->{identityCredential}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyIdentityCredentialWithResult_args');
                        if (defined $self->{identityCredential}) {
                          $xfer += $output->writeFieldBegin('identityCredential', Thrift::TType::STRUCT, 2);
                          $xfer += $self->{identityCredential}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyIdentityCredentialWithResult_result;
use base qw(Class::Accessor);
TalkService_verifyIdentityCredentialWithResult_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyIdentityCredentialWithResult_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{success} = UserAuthStatus->new();
                              $xfer += $self->{success}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyIdentityCredentialWithResult_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                          $xfer += $self->{success}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyPhone_args;
use base qw(Class::Accessor);
TalkService_verifyPhone_args->mk_accessors( qw( sessionId pinCode udidHash ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{sessionId} = undef;
                        $self->{pinCode} = undef;
                        $self->{udidHash} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{sessionId}) {
                            $self->{sessionId} = $vals->{sessionId};
                          }
                          if (defined $vals->{pinCode}) {
                            $self->{pinCode} = $vals->{pinCode};
                          }
                          if (defined $vals->{udidHash}) {
                            $self->{udidHash} = $vals->{udidHash};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyPhone_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{sessionId});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{pinCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^4$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{udidHash});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyPhone_args');
                        if (defined $self->{sessionId}) {
                          $xfer += $output->writeFieldBegin('sessionId', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{sessionId});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{pinCode}) {
                          $xfer += $output->writeFieldBegin('pinCode', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{pinCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{udidHash}) {
                          $xfer += $output->writeFieldBegin('udidHash', Thrift::TType::STRING, 4);
                          $xfer += $output->writeString($self->{udidHash});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyPhone_result;
use base qw(Class::Accessor);
TalkService_verifyPhone_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyPhone_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::I32) {
                              $xfer += $input->readI32(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyPhone_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
                          $xfer += $output->writeI32($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyQrcode_args;
use base qw(Class::Accessor);
TalkService_verifyQrcode_args->mk_accessors( qw( verifier pinCode ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{verifier} = undef;
                        $self->{pinCode} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{verifier}) {
                            $self->{verifier} = $vals->{verifier};
                          }
                          if (defined $vals->{pinCode}) {
                            $self->{pinCode} = $vals->{pinCode};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyQrcode_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^2$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{verifier});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^3$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{pinCode});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyQrcode_args');
                        if (defined $self->{verifier}) {
                          $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 2);
                          $xfer += $output->writeString($self->{verifier});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{pinCode}) {
                          $xfer += $output->writeFieldBegin('pinCode', Thrift::TType::STRING, 3);
                          $xfer += $output->writeString($self->{pinCode});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkService_verifyQrcode_result;
use base qw(Class::Accessor);
TalkService_verifyQrcode_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        $self->{e} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                          if (defined $vals->{e}) {
                            $self->{e} = $vals->{e};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'TalkService_verifyQrcode_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == Thrift::TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == Thrift::TType::STRING) {
                              $xfer += $input->readString(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                            /^1$/ && do{                            if ($ftype == Thrift::TType::STRUCT) {
                              $self->{e} = TalkException->new();
                              $xfer += $self->{e}->read($input);
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('TalkService_verifyQrcode_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                          $xfer += $output->writeString($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        if (defined $self->{e}) {
                          $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                          $xfer += $self->{e}->write($output);
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package TalkServiceIf;

use strict;


sub searchCollection{
  my $self = shift;
  my $query = shift;
  my $param = shift;

  die 'implement interface';
}

sub getChatRoomAnnouncementsBulk{
  my $self = shift;
  my $chatRoomMids = shift;

  die 'implement interface';
}

sub getChatRoomAnnouncements{
  my $self = shift;
  my $chatRoomMid = shift;

  die 'implement interface';
}

sub createChatRoomAnnouncement{
  my $self = shift;
  my $reqSeq = shift;
  my $chatRoomMid = shift;
  my $type = shift;
  my $contents = shift;

  die 'implement interface';
}

sub removeChatRoomAnnouncement{
  my $self = shift;
  my $reqSeq = shift;
  my $chatRoomMid = shift;
  my $announcementSeq = shift;

  die 'implement interface';
}

sub unsendMessage{
  my $self = shift;
  my $seq = shift;
  my $messageId = shift;

  die 'implement interface';
}

sub getGroupWithoutMembers{
  my $self = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub requestResendMessage{
  my $self = shift;
  my $reqSeq = shift;
  my $senderMid = shift;
  my $messageId = shift;

  die 'implement interface';
}

sub respondResendMessage{
  my $self = shift;
  my $reqSeq = shift;
  my $receiverMid = shift;
  my $originalMessageId = shift;
  my $resendMessage = shift;
  my $errorCode = shift;

  die 'implement interface';
}

sub acceptGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub acceptGroupInvitationByTicket{
  my $self = shift;
  my $reqSeq = shift;
  my $GroupMid = shift;
  my $ticketId = shift;

  die 'implement interface';
}

sub acceptProximityMatches{
  my $self = shift;
  my $sessionId = shift;
  my $ids = shift;

  die 'implement interface';
}

sub acquireCallRoute{
  my $self = shift;
  my $to = shift;

  die 'implement interface';
}

sub acquireCallTicket{
  my $self = shift;
  my $to = shift;

  die 'implement interface';
}

sub acquireEncryptedAccessToken{
  my $self = shift;
  my $featureType = shift;

  die 'implement interface';
}

sub addSnsId{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;

  die 'implement interface';
}

sub blockContact{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

  die 'implement interface';
}

sub blockRecommendation{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

  die 'implement interface';
}

sub cancelGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub changeVerificationMethod{
  my $self = shift;
  my $sessionId = shift;
  my $method = shift;

  die 'implement interface';
}

sub clearIdentityCredential{
  my $self = shift;

  die 'implement interface';
}

sub clearMessageBox{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;

  die 'implement interface';
}

sub closeProximityMatch{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub commitSendMessage{
  my $self = shift;
  my $seq = shift;
  my $messageId = shift;
  my $receiverMids = shift;

  die 'implement interface';
}

sub commitSendMessages{
  my $self = shift;
  my $seq = shift;
  my $messageIds = shift;
  my $receiverMids = shift;

  die 'implement interface';
}

sub commitUpdateProfile{
  my $self = shift;
  my $seq = shift;
  my $attrs = shift;
  my $receiverMids = shift;

  die 'implement interface';
}

sub confirmEmail{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;

  die 'implement interface';
}

sub createGroup{
  my $self = shift;
  my $seq = shift;
  my $name = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub createQrcodeBase64Image{
  my $self = shift;
  my $url = shift;
  my $characterSet = shift;
  my $imageSize = shift;
  my $x = shift;
  my $y = shift;
  my $width = shift;
  my $height = shift;

  die 'implement interface';
}

sub createRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub createSession{
  my $self = shift;

  die 'implement interface';
}

sub fetchAnnouncements{
  my $self = shift;
  my $lastFetchedIndex = shift;

  die 'implement interface';
}

sub fetchMessages{
  my $self = shift;
  my $localTs = shift;
  my $count = shift;

  die 'implement interface';
}

sub fetchOperations{
  my $self = shift;
  my $localRev = shift;
  my $count = shift;

  die 'implement interface';
}

sub fetchOps{
  my $self = shift;
  my $localRev = shift;
  my $count = shift;
  my $globalRev = shift;
  my $individualRev = shift;

  die 'implement interface';
}

sub findAndAddContactsByEmail{
  my $self = shift;
  my $reqSeq = shift;
  my $emails = shift;

  die 'implement interface';
}

sub findAndAddContactsByMid{
  my $self = shift;
  my $reqSeq = shift;
  my $mid = shift;
  my $type = shift;
  my $reference = shift;

  die 'implement interface';
}

sub findGroupByTicketV2{
  my $self = shift;
  my $ticketId = shift;

  die 'implement interface';
}

sub findAndAddContactsByPhone{
  my $self = shift;
  my $reqSeq = shift;
  my $phones = shift;

  die 'implement interface';
}

sub getFriendRequests{
  my $self = shift;
  my $direction = shift;
  my $lastSeenSeqId = shift;

  die 'implement interface';
}

sub removeFriendRequest{
  my $self = shift;
  my $direction = shift;
  my $midOrEMid = shift;

  die 'implement interface';
}

sub findAndAddContactsByUserid{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;

  die 'implement interface';
}

sub findContactByUserid{
  my $self = shift;
  my $userid = shift;

  die 'implement interface';
}

sub findContactByUserTicket{
  my $self = shift;
  my $ticketIdWithTag = shift;

  die 'implement interface';
}

sub findContactsByEmail{
  my $self = shift;
  my $emails = shift;

  die 'implement interface';
}

sub findContactsByPhone{
  my $self = shift;
  my $phones = shift;

  die 'implement interface';
}

sub findSnsIdUserStatus{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $udidHash = shift;

  die 'implement interface';
}

sub finishUpdateVerification{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub generateUserTicket{
  my $self = shift;
  my $expirationTime = shift;
  my $maxUseCount = shift;

  die 'implement interface';
}

sub destroyMessage{
  my $self = shift;
  my $seq = shift;
  my $chatId = shift;
  my $messageId = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub getAcceptedProximityMatches{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub getActiveBuddySubscriberIds{
  my $self = shift;

  die 'implement interface';
}

sub getAllContactIds{
  my $self = shift;

  die 'implement interface';
}

sub getAuthQrcode{
  my $self = shift;
  my $keepLoggedIn = shift;
  my $systemName = shift;

  die 'implement interface';
}

sub getBlockedContactIds{
  my $self = shift;

  die 'implement interface';
}

sub registerWithPhoneNumber{
  my $self = shift;
  my $sessionId = shift;
  my $migrationPincodeSessionId = shift;

  die 'implement interface';
}

sub registerWithPhoneNumberAndPassword{
  my $self = shift;
  my $sessionId = shift;
  my $keynm = shift;
  my $encrypted = shift;

  die 'implement interface';
}

sub getAnalyticsInfo{
  my $self = shift;

  die 'implement interface';
}

sub reportClientStatistics{
  my $self = shift;
  my $reqSeq = shift;
  my $category = shift;
  my $count = shift;

  die 'implement interface';
}

sub verifyPhoneNumberForLogin{
  my $self = shift;
  my $verifierFromPhone = shift;
  my $pinCodeForPhone = shift;
  my $verifierFromLogin = shift;

  die 'implement interface';
}

sub verifyPhoneNumber{
  my $self = shift;
  my $sessionId = shift;
  my $pinCode = shift;
  my $udidHash = shift;
  my $migrationPincodeSessionId = shift;
  my $oldUdidHash = shift;

  die 'implement interface';
}

sub getBlockedContactIdsByRange{
  my $self = shift;
  my $start = shift;
  my $count = shift;

  die 'implement interface';
}

sub getBlockedRecommendationIds{
  my $self = shift;

  die 'implement interface';
}

sub getBuddyBlockerIds{
  my $self = shift;

  die 'implement interface';
}

sub getBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;

  die 'implement interface';
}

sub getCompactContactsModifiedSince{
  my $self = shift;
  my $timestamp = shift;

  die 'implement interface';
}

sub getCompactGroup{
  my $self = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub getCompactRoom{
  my $self = shift;
  my $roomId = shift;

  die 'implement interface';
}

sub getContact{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub getContacts{
  my $self = shift;
  my $ids = shift;

  die 'implement interface';
}

sub getContactWithFriendRequestStatus{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub getCountryWithRequestIp{
  my $self = shift;

  die 'implement interface';
}

sub getFavoriteMids{
  my $self = shift;

  die 'implement interface';
}

sub getGroup{
  my $self = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub getGroupIdsInvited{
  my $self = shift;

  die 'implement interface';
}

sub getGroupIdsJoined{
  my $self = shift;

  die 'implement interface';
}

sub getGroups{
  my $self = shift;
  my $groupIds = shift;

  die 'implement interface';
}

sub getHiddenContactMids{
  my $self = shift;

  die 'implement interface';
}

sub getIdentityIdentifier{
  my $self = shift;

  die 'implement interface';
}

sub getLastAnnouncementIndex{
  my $self = shift;

  die 'implement interface';
}

sub getLastOpRevision{
  my $self = shift;

  die 'implement interface';
}

sub getSuggestRevisions{
  my $self = shift;

  die 'implement interface';
}

sub getPreviousMessagesV2WithReadCount{
  my $self = shift;
  my $messageBoxId = shift;
  my $endMessageId = shift;
  my $messagesCount = shift;

  die 'implement interface';
}

sub getMessageBox{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;
  my $lastMessagesCount = shift;

  die 'implement interface';
}

sub getMessageBoxCompactWrapUp{
  my $self = shift;
  my $mid = shift;

  die 'implement interface';
}

sub getMessageBoxCompactWrapUpList{
  my $self = shift;
  my $start = shift;
  my $messageBoxCount = shift;

  die 'implement interface';
}

sub getMessageBoxList{
  my $self = shift;
  my $channelId = shift;
  my $lastMessagesCount = shift;

  die 'implement interface';
}

sub getMessageBoxListByStatus{
  my $self = shift;
  my $channelId = shift;
  my $lastMessagesCount = shift;
  my $status = shift;

  die 'implement interface';
}

sub getMessageBoxWrapUp{
  my $self = shift;
  my $mid = shift;

  die 'implement interface';
}

sub getMessageBoxWrapUpList{
  my $self = shift;
  my $start = shift;
  my $messageBoxCount = shift;

  die 'implement interface';
}

sub getMessagesBySequenceNumber{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;
  my $startSeq = shift;
  my $endSeq = shift;

  die 'implement interface';
}

sub getNextMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $startSeq = shift;
  my $messagesCount = shift;

  die 'implement interface';
}

sub getNotificationPolicy{
  my $self = shift;
  my $carrier = shift;

  die 'implement interface';
}

sub getPreviousMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $endSeq = shift;
  my $messagesCount = shift;

  die 'implement interface';
}

sub getProfile{
  my $self = shift;

  die 'implement interface';
}

sub getProximityMatchCandidateList{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub getProximityMatchCandidates{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub getRecentMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $messagesCount = shift;

  die 'implement interface';
}

sub getRecommendationIds{
  my $self = shift;

  die 'implement interface';
}

sub getRoom{
  my $self = shift;
  my $roomId = shift;

  die 'implement interface';
}

sub getRSAKeyInfo{
  my $self = shift;
  my $provider = shift;

  die 'implement interface';
}

sub getServerTime{
  my $self = shift;

  die 'implement interface';
}

sub getSessions{
  my $self = shift;

  die 'implement interface';
}

sub getSettings{
  my $self = shift;

  die 'implement interface';
}

sub getGroupsV2{
  my $self = shift;
  my $groupIds = shift;

  die 'implement interface';
}

sub getSettingsAttributes{
  my $self = shift;
  my $attrBitset = shift;

  die 'implement interface';
}

sub getSystemConfiguration{
  my $self = shift;

  die 'implement interface';
}

sub getUserTicket{
  my $self = shift;

  die 'implement interface';
}

sub getWapInvitation{
  my $self = shift;
  my $invitationHash = shift;

  die 'implement interface';
}

sub invalidateUserTicket{
  my $self = shift;

  die 'implement interface';
}

sub inviteFriendsBySms{
  my $self = shift;
  my $phoneNumberList = shift;

  die 'implement interface';
}

sub inviteIntoGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub inviteIntoRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $roomId = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub inviteViaEmail{
  my $self = shift;
  my $reqSeq = shift;
  my $email = shift;
  my $name = shift;

  die 'implement interface';
}

sub isIdentityIdentifierAvailable{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;

  die 'implement interface';
}

sub isUseridAvailable{
  my $self = shift;
  my $userid = shift;

  die 'implement interface';
}

sub kickoutFromGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub reissueGroupTicket{
  my $self = shift;
  my $groupMid = shift;

  die 'implement interface';
}

sub findGroupByTicket{
  my $self = shift;
  my $ticketId = shift;

  die 'implement interface';
}

sub leaveGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub leaveRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $roomId = shift;

  die 'implement interface';
}

sub loginWithIdentityCredential{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;
  my $keepLoggedIn = shift;
  my $accessLocation = shift;
  my $systemName = shift;
  my $certificate = shift;

  die 'implement interface';
}

sub loginWithIdentityCredentialForCertificate{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;
  my $keepLoggedIn = shift;
  my $accessLocation = shift;
  my $systemName = shift;
  my $certificate = shift;

  die 'implement interface';
}

sub loginWithVerifier{
  my $self = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub loginWithVerifierForCerificate{
  my $self = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub loginWithVerifierForCertificate{
  my $self = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub logout{
  my $self = shift;

  die 'implement interface';
}

sub logoutSession{
  my $self = shift;
  my $tokenKey = shift;

  die 'implement interface';
}

sub noop{
  my $self = shift;

  die 'implement interface';
}

sub notifiedRedirect{
  my $self = shift;
  my $paramMap = shift;

  die 'implement interface';
}

sub notifyBuddyOnAir{
  my $self = shift;
  my $seq = shift;
  my $receiverMids = shift;

  die 'implement interface';
}

sub notifyIndividualEvent{
  my $self = shift;
  my $notificationStatus = shift;
  my $receiverMids = shift;

  die 'implement interface';
}

sub notifyInstalled{
  my $self = shift;
  my $udidHash = shift;
  my $applicationTypeWithExtensions = shift;

  die 'implement interface';
}

sub notifyRegistrationComplete{
  my $self = shift;
  my $udidHash = shift;
  my $applicationTypeWithExtensions = shift;

  die 'implement interface';
}

sub notifySleep{
  my $self = shift;
  my $lastRev = shift;
  my $badge = shift;

  die 'implement interface';
}

sub notifyUpdated{
  my $self = shift;
  my $lastRev = shift;
  my $deviceInfo = shift;

  die 'implement interface';
}

sub openProximityMatch{
  my $self = shift;
  my $location = shift;

  die 'implement interface';
}

sub registerBuddyUser{
  my $self = shift;
  my $buddyId = shift;
  my $registrarPassword = shift;

  die 'implement interface';
}

sub registerBuddyUserid{
  my $self = shift;
  my $seq = shift;
  my $userid = shift;

  die 'implement interface';
}

sub registerDevice{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub registerDeviceWithIdentityCredential{
  my $self = shift;
  my $sessionId = shift;
  my $provider = shift;
  my $identifier = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub registerDeviceWithoutPhoneNumber{
  my $self = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

  die 'implement interface';
}

sub registerDeviceWithoutPhoneNumberWithIdentityCredential{
  my $self = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $provider = shift;
  my $identifier = shift;
  my $verifier = shift;
  my $mid = shift;
  my $migrationPincodeSessionId = shift;

  die 'implement interface';
}

sub registerUserid{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;

  die 'implement interface';
}

sub registerWapDevice{
  my $self = shift;
  my $invitationHash = shift;
  my $guidHash = shift;
  my $email = shift;
  my $deviceInfo = shift;

  die 'implement interface';
}

sub registerWithExistingSnsIdAndIdentityCredential{
  my $self = shift;
  my $identityCredential = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

  die 'implement interface';
}

sub registerWithSnsId{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $mid = shift;

  die 'implement interface';
}

sub registerWithSnsIdAndIdentityCredential{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $identityCredential = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

  die 'implement interface';
}

sub reissueDeviceCredential{
  my $self = shift;

  die 'implement interface';
}

sub reissueUserTicket{
  my $self = shift;
  my $expirationTime = shift;
  my $maxUseCount = shift;

  die 'implement interface';
}

sub getMessageReadRange{
  my $self = shift;
  my $chatIds = shift;

  die 'implement interface';
}

sub rejectGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

  die 'implement interface';
}

sub releaseSession{
  my $self = shift;

  die 'implement interface';
}

sub removeAllMessages{
  my $self = shift;
  my $seq = shift;
  my $lastMessageId = shift;

  die 'implement interface';
}

sub removeBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;

  die 'implement interface';
}

sub removeMessage{
  my $self = shift;
  my $messageId = shift;

  die 'implement interface';
}

sub makeUserAddMyselfAsContact{
  my $self = shift;
  my $contactOwnerMid = shift;

  die 'implement interface';
}

sub removeMessageFromMyHome{
  my $self = shift;
  my $messageId = shift;

  die 'implement interface';
}

sub removeSnsId{
  my $self = shift;
  my $snsIdType = shift;

  die 'implement interface';
}

sub report{
  my $self = shift;
  my $syncOpRevision = shift;
  my $category = shift;
  my $report = shift;

  die 'implement interface';
}

sub reportContacts{
  my $self = shift;
  my $syncOpRevision = shift;
  my $category = shift;
  my $contactReports = shift;
  my $actionType = shift;

  die 'implement interface';
}

sub reportGroups{
  my $self = shift;
  my $syncOpRevision = shift;
  my $groups = shift;

  die 'implement interface';
}

sub reportProfile{
  my $self = shift;
  my $syncOpRevision = shift;
  my $profile = shift;

  die 'implement interface';
}

sub reportRooms{
  my $self = shift;
  my $syncOpRevision = shift;
  my $rooms = shift;

  die 'implement interface';
}

sub findAndAddContactByMetaTag{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;
  my $reference = shift;

  die 'implement interface';
}

sub reportSettings{
  my $self = shift;
  my $syncOpRevision = shift;
  my $settings = shift;

  die 'implement interface';
}

sub reportSpam{
  my $self = shift;
  my $chatMid = shift;
  my $memberMids = shift;
  my $spammerReasons = shift;
  my $senderMids = shift;
  my $spamMessageIds = shift;
  my $spamMessages = shift;

  die 'implement interface';
}

sub reportSpammer{
  my $self = shift;
  my $spammerMid = shift;
  my $spammerReasons = shift;
  my $spamMessageIds = shift;

  die 'implement interface';
}

sub requestAccountPasswordReset{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;
  my $locale = shift;

  die 'implement interface';
}

sub requestEmailConfirmation{
  my $self = shift;
  my $emailConfirmation = shift;

  die 'implement interface';
}

sub requestIdentityUnbind{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;

  die 'implement interface';
}

sub resendEmailConfirmation{
  my $self = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub resendPinCode{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub resendPinCodeBySMS{
  my $self = shift;
  my $sessionId = shift;

  die 'implement interface';
}

sub sendChatChecked{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $lastMessageId = shift;

  die 'implement interface';
}

sub sendMessageAwaitCommit{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

  die 'implement interface';
}

sub sendChatRemoved{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $lastMessageId = shift;

  die 'implement interface';
}

sub sendContentPreviewUpdated{
  my $self = shift;
  my $esq = shift;
  my $messageId = shift;
  my $receiverMids = shift;

  die 'implement interface';
}

sub sendContentReceipt{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageId = shift;

  die 'implement interface';
}

sub sendDummyPush{
  my $self = shift;

  die 'implement interface';
}

sub removeE2EEPublicKey{
  my $self = shift;
  my $publicKey = shift;

  die 'implement interface';
}

sub negotiateE2EEPublicKey{
  my $self = shift;
  my $mid = shift;

  die 'implement interface';
}

sub getE2EEPublicKey{
  my $self = shift;
  my $mid = shift;
  my $version = shift;
  my $keyId = shift;

  die 'implement interface';
}

sub requestE2EEKeyExchange{
  my $self = shift;
  my $reqSeq = shift;
  my $temporalPublicKey = shift;
  my $publicKey = shift;
  my $verifier = shift;

  die 'implement interface';
}

sub getLastE2EEPublicKeys{
  my $self = shift;
  my $chatMid = shift;

  die 'implement interface';
}

sub registerE2EEPublicKey{
  my $self = shift;
  my $reqSeq = shift;
  my $publicKey = shift;

  die 'implement interface';
}

sub getE2EEPublicKeys{
  my $self = shift;

  die 'implement interface';
}

sub getE2EEPublicKeysEx{
  my $self = shift;
  my $ignoreE2EEStatus = shift;

  die 'implement interface';
}

sub getReadMessageOpsInBulk{
  my $self = shift;
  my $chatIds = shift;

  die 'implement interface';
}

sub sendEvent{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

  die 'implement interface';
}

sub sendMessage{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

  die 'implement interface';
}

sub sendMessageIgnored{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageIds = shift;

  die 'implement interface';
}

sub sendMessageReceipt{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageIds = shift;

  die 'implement interface';
}

sub findContactByMetaTag{
  my $self = shift;
  my $userid = shift;
  my $reference = shift;

  die 'implement interface';
}

sub sendMessageToMyHome{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

  die 'implement interface';
}

sub setBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;
  my $location = shift;

  die 'implement interface';
}

sub setIdentityCredential{
  my $self = shift;
  my $identifier = shift;
  my $verifier = shift;
  my $provider = shift;

  die 'implement interface';
}

sub setNotificationsEnabled{
  my $self = shift;
  my $reqSeq = shift;
  my $type = shift;
  my $target = shift;
  my $enablement = shift;

  die 'implement interface';
}

sub startUpdateVerification{
  my $self = shift;
  my $region = shift;
  my $carrier = shift;
  my $phone = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $networkCode = shift;
  my $locale = shift;

  die 'implement interface';
}

sub startVerification{
  my $self = shift;
  my $region = shift;
  my $carrier = shift;
  my $phone = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $networkCode = shift;
  my $mid = shift;
  my $locale = shift;
  my $simInfo = shift;
  my $oldUdidHash = shift;

  die 'implement interface';
}

sub updateGroupPreferenceAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $groupMid = shift;
  my $updatedAttrs = shift;

  die 'implement interface';
}

sub createRoomV2{
  my $self = shift;
  my $reqSeq = shift;
  my $contactIds = shift;

  die 'implement interface';
}

sub storeUpdateProfileAttribute{
  my $self = shift;
  my $seq = shift;
  my $profileAttribute = shift;
  my $value = shift;

  die 'implement interface';
}

sub syncContactBySnsIds{
  my $self = shift;
  my $reqSeq = shift;
  my $modifications = shift;

  die 'implement interface';
}

sub syncContacts{
  my $self = shift;
  my $reqSeq = shift;
  my $localContacts = shift;

  die 'implement interface';
}

sub trySendMessage{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

  die 'implement interface';
}

sub getNextMessagesV2{
  my $self = shift;
  my $messageBoxId = shift;
  my $startMessageId = shift;
  my $messagesCount = shift;

  die 'implement interface';
}

sub getMessageBoxCompactWrapUpV2{
  my $self = shift;
  my $messageBoxId = shift;

  die 'implement interface';
}

sub getRecentMessagesV2{
  my $self = shift;
  my $messageBoxId = shift;
  my $messagesCount = shift;

  die 'implement interface';
}

sub validateContactsOnBot{
  my $self = shift;
  my $contacts = shift;

  die 'implement interface';
}

sub tryFriendRequest{
  my $self = shift;
  my $midOrEMid = shift;
  my $method = shift;
  my $friendRequestParams = shift;

  die 'implement interface';
}

sub unblockContact{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

  die 'implement interface';
}

sub unblockRecommendation{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

  die 'implement interface';
}

sub unregisterUserAndDevice{
  my $self = shift;

  die 'implement interface';
}

sub updateApnsDeviceToken{
  my $self = shift;
  my $apnsDeviceToken = shift;

  die 'implement interface';
}

sub updateBuddySetting{
  my $self = shift;
  my $key = shift;
  my $value = shift;

  die 'implement interface';
}

sub updateC2DMRegistrationId{
  my $self = shift;
  my $registrationId = shift;

  die 'implement interface';
}

sub updateContactSetting{
  my $self = shift;
  my $reqSeq = shift;
  my $mid = shift;
  my $flag = shift;
  my $value = shift;

  die 'implement interface';
}

sub updateCustomModeSettings{
  my $self = shift;
  my $customMode = shift;
  my $paramMap = shift;

  die 'implement interface';
}

sub updateDeviceInfo{
  my $self = shift;
  my $deviceUid = shift;
  my $deviceInfo = shift;

  die 'implement interface';
}

sub updateGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $group = shift;

  die 'implement interface';
}

sub updateNotificationToken{
  my $self = shift;
  my $type = shift;
  my $token = shift;

  die 'implement interface';
}

sub updateNotificationTokenWithBytes{
  my $self = shift;
  my $type = shift;
  my $token = shift;

  die 'implement interface';
}

sub updateProfile{
  my $self = shift;
  my $reqSeq = shift;
  my $profile = shift;

  die 'implement interface';
}

sub updateProfileAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $attr = shift;
  my $value = shift;

  die 'implement interface';
}

sub updateProfileAttributes{
  my $self = shift;
  my $reqSeq = shift;
  my $request = shift;

  die 'implement interface';
}

sub updateRegion{
  my $self = shift;
  my $region = shift;

  die 'implement interface';
}

sub updateSettings{
  my $self = shift;
  my $reqSeq = shift;
  my $settings = shift;

  die 'implement interface';
}

sub updateSettings2{
  my $self = shift;
  my $reqSeq = shift;
  my $settings = shift;

  die 'implement interface';
}

sub updateSettingsAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $attr = shift;
  my $value = shift;

  die 'implement interface';
}

sub updateSettingsAttributes{
  my $self = shift;
  my $reqSeq = shift;
  my $attrBitset = shift;
  my $settings = shift;

  die 'implement interface';
}

sub verifyIdentityCredential{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;

  die 'implement interface';
}

sub verifyIdentityCredentialWithResult{
  my $self = shift;
  my $identityCredential = shift;

  die 'implement interface';
}

sub verifyPhone{
  my $self = shift;
  my $sessionId = shift;
  my $pinCode = shift;
  my $udidHash = shift;

  die 'implement interface';
}

sub verifyQrcode{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;

  die 'implement interface';
}

package TalkServiceRest;

use strict;


sub new {
                        my ($classname, $impl) = @_;
                        my $self     ={ impl => $impl };

                        return bless($self,$classname);
}

sub searchCollection{
                        my ($self, $request) = @_;

                        my $query = ($request->{'query'}) ? $request->{'query'} : undef;
                        my $param = ($request->{'param'}) ? $request->{'param'} : undef;
                        return $self->{impl}->searchCollection($query, $param);
                      }

sub getChatRoomAnnouncementsBulk{
                        my ($self, $request) = @_;

                        my $chatRoomMids = ($request->{'chatRoomMids'}) ? $request->{'chatRoomMids'} : undef;
                        return $self->{impl}->getChatRoomAnnouncementsBulk($chatRoomMids);
                      }

sub getChatRoomAnnouncements{
                        my ($self, $request) = @_;

                        my $chatRoomMid = ($request->{'chatRoomMid'}) ? $request->{'chatRoomMid'} : undef;
                        return $self->{impl}->getChatRoomAnnouncements($chatRoomMid);
                      }

sub createChatRoomAnnouncement{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $chatRoomMid = ($request->{'chatRoomMid'}) ? $request->{'chatRoomMid'} : undef;
                        my $type = ($request->{'type'}) ? $request->{'type'} : undef;
                        my $contents = ($request->{'contents'}) ? $request->{'contents'} : undef;
                        return $self->{impl}->createChatRoomAnnouncement($reqSeq, $chatRoomMid, $type, $contents);
                      }

sub removeChatRoomAnnouncement{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $chatRoomMid = ($request->{'chatRoomMid'}) ? $request->{'chatRoomMid'} : undef;
                        my $announcementSeq = ($request->{'announcementSeq'}) ? $request->{'announcementSeq'} : undef;
                        return $self->{impl}->removeChatRoomAnnouncement($reqSeq, $chatRoomMid, $announcementSeq);
                      }

sub unsendMessage{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        return $self->{impl}->unsendMessage($seq, $messageId);
                      }

sub getGroupWithoutMembers{
                        my ($self, $request) = @_;

                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        return $self->{impl}->getGroupWithoutMembers($groupId);
                      }

sub requestResendMessage{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $senderMid = ($request->{'senderMid'}) ? $request->{'senderMid'} : undef;
                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        return $self->{impl}->requestResendMessage($reqSeq, $senderMid, $messageId);
                      }

sub respondResendMessage{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $receiverMid = ($request->{'receiverMid'}) ? $request->{'receiverMid'} : undef;
                        my $originalMessageId = ($request->{'originalMessageId'}) ? $request->{'originalMessageId'} : undef;
                        my $resendMessage = ($request->{'resendMessage'}) ? $request->{'resendMessage'} : undef;
                        my $errorCode = ($request->{'errorCode'}) ? $request->{'errorCode'} : undef;
                        return $self->{impl}->respondResendMessage($reqSeq, $receiverMid, $originalMessageId, $resendMessage, $errorCode);
                      }

sub acceptGroupInvitation{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        return $self->{impl}->acceptGroupInvitation($reqSeq, $groupId);
                      }

sub acceptGroupInvitationByTicket{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $GroupMid = ($request->{'GroupMid'}) ? $request->{'GroupMid'} : undef;
                        my $ticketId = ($request->{'ticketId'}) ? $request->{'ticketId'} : undef;
                        return $self->{impl}->acceptGroupInvitationByTicket($reqSeq, $GroupMid, $ticketId);
                      }

sub acceptProximityMatches{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $ids = ($request->{'ids'}) ? $request->{'ids'} : undef;
                        return $self->{impl}->acceptProximityMatches($sessionId, $ids);
                      }

sub acquireCallRoute{
                        my ($self, $request) = @_;

                        my $to = ($request->{'to'}) ? $request->{'to'} : undef;
                        return $self->{impl}->acquireCallRoute($to);
                      }

sub acquireCallTicket{
                        my ($self, $request) = @_;

                        my $to = ($request->{'to'}) ? $request->{'to'} : undef;
                        return $self->{impl}->acquireCallTicket($to);
                      }

sub acquireEncryptedAccessToken{
                        my ($self, $request) = @_;

                        my $featureType = ($request->{'featureType'}) ? $request->{'featureType'} : undef;
                        return $self->{impl}->acquireEncryptedAccessToken($featureType);
                      }

sub addSnsId{
                        my ($self, $request) = @_;

                        my $snsIdType = ($request->{'snsIdType'}) ? $request->{'snsIdType'} : undef;
                        my $snsAccessToken = ($request->{'snsAccessToken'}) ? $request->{'snsAccessToken'} : undef;
                        return $self->{impl}->addSnsId($snsIdType, $snsAccessToken);
                      }

sub blockContact{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $id = ($request->{'id'}) ? $request->{'id'} : undef;
                        return $self->{impl}->blockContact($reqSeq, $id);
                      }

sub blockRecommendation{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $id = ($request->{'id'}) ? $request->{'id'} : undef;
                        return $self->{impl}->blockRecommendation($reqSeq, $id);
                      }

sub cancelGroupInvitation{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->cancelGroupInvitation($reqSeq, $groupId, $contactIds);
                      }

sub changeVerificationMethod{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $method = ($request->{'method'}) ? $request->{'method'} : undef;
                        return $self->{impl}->changeVerificationMethod($sessionId, $method);
                      }

sub clearIdentityCredential{
                        my ($self, $request) = @_;

                        return $self->{impl}->clearIdentityCredential();
                      }

sub clearMessageBox{
                        my ($self, $request) = @_;

                        my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        return $self->{impl}->clearMessageBox($channelId, $messageBoxId);
                      }

sub closeProximityMatch{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->closeProximityMatch($sessionId);
                      }

sub commitSendMessage{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        my $receiverMids = ($request->{'receiverMids'}) ? $request->{'receiverMids'} : undef;
                        return $self->{impl}->commitSendMessage($seq, $messageId, $receiverMids);
                      }

sub commitSendMessages{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $messageIds = ($request->{'messageIds'}) ? $request->{'messageIds'} : undef;
                        my $receiverMids = ($request->{'receiverMids'}) ? $request->{'receiverMids'} : undef;
                        return $self->{impl}->commitSendMessages($seq, $messageIds, $receiverMids);
                      }

sub commitUpdateProfile{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $attrs = ($request->{'attrs'}) ? $request->{'attrs'} : undef;
                        my $receiverMids = ($request->{'receiverMids'}) ? $request->{'receiverMids'} : undef;
                        return $self->{impl}->commitUpdateProfile($seq, $attrs, $receiverMids);
                      }

sub confirmEmail{
                        my ($self, $request) = @_;

                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        my $pinCode = ($request->{'pinCode'}) ? $request->{'pinCode'} : undef;
                        return $self->{impl}->confirmEmail($verifier, $pinCode);
                      }

sub createGroup{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $name = ($request->{'name'}) ? $request->{'name'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->createGroup($seq, $name, $contactIds);
                      }

sub createQrcodeBase64Image{
                        my ($self, $request) = @_;

                        my $url = ($request->{'url'}) ? $request->{'url'} : undef;
                        my $characterSet = ($request->{'characterSet'}) ? $request->{'characterSet'} : undef;
                        my $imageSize = ($request->{'imageSize'}) ? $request->{'imageSize'} : undef;
                        my $x = ($request->{'x'}) ? $request->{'x'} : undef;
                        my $y = ($request->{'y'}) ? $request->{'y'} : undef;
                        my $width = ($request->{'width'}) ? $request->{'width'} : undef;
                        my $height = ($request->{'height'}) ? $request->{'height'} : undef;
                        return $self->{impl}->createQrcodeBase64Image($url, $characterSet, $imageSize, $x, $y, $width, $height);
                      }

sub createRoom{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->createRoom($reqSeq, $contactIds);
                      }

sub createSession{
                        my ($self, $request) = @_;

                        return $self->{impl}->createSession();
                      }

sub fetchAnnouncements{
                        my ($self, $request) = @_;

                        my $lastFetchedIndex = ($request->{'lastFetchedIndex'}) ? $request->{'lastFetchedIndex'} : undef;
                        return $self->{impl}->fetchAnnouncements($lastFetchedIndex);
                      }

sub fetchMessages{
                        my ($self, $request) = @_;

                        my $localTs = ($request->{'localTs'}) ? $request->{'localTs'} : undef;
                        my $count = ($request->{'count'}) ? $request->{'count'} : undef;
                        return $self->{impl}->fetchMessages($localTs, $count);
                      }

sub fetchOperations{
                        my ($self, $request) = @_;

                        my $localRev = ($request->{'localRev'}) ? $request->{'localRev'} : undef;
                        my $count = ($request->{'count'}) ? $request->{'count'} : undef;
                        return $self->{impl}->fetchOperations($localRev, $count);
                      }

sub fetchOps{
                        my ($self, $request) = @_;

                        my $localRev = ($request->{'localRev'}) ? $request->{'localRev'} : undef;
                        my $count = ($request->{'count'}) ? $request->{'count'} : undef;
                        my $globalRev = ($request->{'globalRev'}) ? $request->{'globalRev'} : undef;
                        my $individualRev = ($request->{'individualRev'}) ? $request->{'individualRev'} : undef;
                        return $self->{impl}->fetchOps($localRev, $count, $globalRev, $individualRev);
                      }

sub findAndAddContactsByEmail{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $emails = ($request->{'emails'}) ? $request->{'emails'} : undef;
                        return $self->{impl}->findAndAddContactsByEmail($reqSeq, $emails);
                      }

sub findAndAddContactsByMid{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $type = ($request->{'type'}) ? $request->{'type'} : undef;
                        my $reference = ($request->{'reference'}) ? $request->{'reference'} : undef;
                        return $self->{impl}->findAndAddContactsByMid($reqSeq, $mid, $type, $reference);
                      }

sub findGroupByTicketV2{
                        my ($self, $request) = @_;

                        my $ticketId = ($request->{'ticketId'}) ? $request->{'ticketId'} : undef;
                        return $self->{impl}->findGroupByTicketV2($ticketId);
                      }

sub findAndAddContactsByPhone{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $phones = ($request->{'phones'}) ? $request->{'phones'} : undef;
                        return $self->{impl}->findAndAddContactsByPhone($reqSeq, $phones);
                      }

sub getFriendRequests{
                        my ($self, $request) = @_;

                        my $direction = ($request->{'direction'}) ? $request->{'direction'} : undef;
                        my $lastSeenSeqId = ($request->{'lastSeenSeqId'}) ? $request->{'lastSeenSeqId'} : undef;
                        return $self->{impl}->getFriendRequests($direction, $lastSeenSeqId);
                      }

sub removeFriendRequest{
                        my ($self, $request) = @_;

                        my $direction = ($request->{'direction'}) ? $request->{'direction'} : undef;
                        my $midOrEMid = ($request->{'midOrEMid'}) ? $request->{'midOrEMid'} : undef;
                        return $self->{impl}->removeFriendRequest($direction, $midOrEMid);
                      }

sub findAndAddContactsByUserid{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        return $self->{impl}->findAndAddContactsByUserid($reqSeq, $userid);
                      }

sub findContactByUserid{
                        my ($self, $request) = @_;

                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        return $self->{impl}->findContactByUserid($userid);
                      }

sub findContactByUserTicket{
                        my ($self, $request) = @_;

                        my $ticketIdWithTag = ($request->{'ticketIdWithTag'}) ? $request->{'ticketIdWithTag'} : undef;
                        return $self->{impl}->findContactByUserTicket($ticketIdWithTag);
                      }

sub findContactsByEmail{
                        my ($self, $request) = @_;

                        my $emails = ($request->{'emails'}) ? $request->{'emails'} : undef;
                        return $self->{impl}->findContactsByEmail($emails);
                      }

sub findContactsByPhone{
                        my ($self, $request) = @_;

                        my $phones = ($request->{'phones'}) ? $request->{'phones'} : undef;
                        return $self->{impl}->findContactsByPhone($phones);
                      }

sub findSnsIdUserStatus{
                        my ($self, $request) = @_;

                        my $snsIdType = ($request->{'snsIdType'}) ? $request->{'snsIdType'} : undef;
                        my $snsAccessToken = ($request->{'snsAccessToken'}) ? $request->{'snsAccessToken'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        return $self->{impl}->findSnsIdUserStatus($snsIdType, $snsAccessToken, $udidHash);
                      }

sub finishUpdateVerification{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->finishUpdateVerification($sessionId);
                      }

sub generateUserTicket{
                        my ($self, $request) = @_;

                        my $expirationTime = ($request->{'expirationTime'}) ? $request->{'expirationTime'} : undef;
                        my $maxUseCount = ($request->{'maxUseCount'}) ? $request->{'maxUseCount'} : undef;
                        return $self->{impl}->generateUserTicket($expirationTime, $maxUseCount);
                      }

sub destroyMessage{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $chatId = ($request->{'chatId'}) ? $request->{'chatId'} : undef;
                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->destroyMessage($seq, $chatId, $messageId, $sessionId);
                      }

sub getAcceptedProximityMatches{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->getAcceptedProximityMatches($sessionId);
                      }

sub getActiveBuddySubscriberIds{
                        my ($self, $request) = @_;

                        return $self->{impl}->getActiveBuddySubscriberIds();
                      }

sub getAllContactIds{
                        my ($self, $request) = @_;

                        return $self->{impl}->getAllContactIds();
                      }

sub getAuthQrcode{
                        my ($self, $request) = @_;

                        my $keepLoggedIn = ($request->{'keepLoggedIn'}) ? $request->{'keepLoggedIn'} : undef;
                        my $systemName = ($request->{'systemName'}) ? $request->{'systemName'} : undef;
                        return $self->{impl}->getAuthQrcode($keepLoggedIn, $systemName);
                      }

sub getBlockedContactIds{
                        my ($self, $request) = @_;

                        return $self->{impl}->getBlockedContactIds();
                      }

sub registerWithPhoneNumber{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $migrationPincodeSessionId = ($request->{'migrationPincodeSessionId'}) ? $request->{'migrationPincodeSessionId'} : undef;
                        return $self->{impl}->registerWithPhoneNumber($sessionId, $migrationPincodeSessionId);
                      }

sub registerWithPhoneNumberAndPassword{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $keynm = ($request->{'keynm'}) ? $request->{'keynm'} : undef;
                        my $encrypted = ($request->{'encrypted'}) ? $request->{'encrypted'} : undef;
                        return $self->{impl}->registerWithPhoneNumberAndPassword($sessionId, $keynm, $encrypted);
                      }

sub getAnalyticsInfo{
                        my ($self, $request) = @_;

                        return $self->{impl}->getAnalyticsInfo();
                      }

sub reportClientStatistics{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $category = ($request->{'category'}) ? $request->{'category'} : undef;
                        my $count = ($request->{'count'}) ? $request->{'count'} : undef;
                        return $self->{impl}->reportClientStatistics($reqSeq, $category, $count);
                      }

sub verifyPhoneNumberForLogin{
                        my ($self, $request) = @_;

                        my $verifierFromPhone = ($request->{'verifierFromPhone'}) ? $request->{'verifierFromPhone'} : undef;
                        my $pinCodeForPhone = ($request->{'pinCodeForPhone'}) ? $request->{'pinCodeForPhone'} : undef;
                        my $verifierFromLogin = ($request->{'verifierFromLogin'}) ? $request->{'verifierFromLogin'} : undef;
                        return $self->{impl}->verifyPhoneNumberForLogin($verifierFromPhone, $pinCodeForPhone, $verifierFromLogin);
                      }

sub verifyPhoneNumber{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $pinCode = ($request->{'pinCode'}) ? $request->{'pinCode'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $migrationPincodeSessionId = ($request->{'migrationPincodeSessionId'}) ? $request->{'migrationPincodeSessionId'} : undef;
                        my $oldUdidHash = ($request->{'oldUdidHash'}) ? $request->{'oldUdidHash'} : undef;
                        return $self->{impl}->verifyPhoneNumber($sessionId, $pinCode, $udidHash, $migrationPincodeSessionId, $oldUdidHash);
                      }

sub getBlockedContactIdsByRange{
                        my ($self, $request) = @_;

                        my $start = ($request->{'start'}) ? $request->{'start'} : undef;
                        my $count = ($request->{'count'}) ? $request->{'count'} : undef;
                        return $self->{impl}->getBlockedContactIdsByRange($start, $count);
                      }

sub getBlockedRecommendationIds{
                        my ($self, $request) = @_;

                        return $self->{impl}->getBlockedRecommendationIds();
                      }

sub getBuddyBlockerIds{
                        my ($self, $request) = @_;

                        return $self->{impl}->getBuddyBlockerIds();
                      }

sub getBuddyLocation{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $index = ($request->{'index'}) ? $request->{'index'} : undef;
                        return $self->{impl}->getBuddyLocation($mid, $index);
                      }

sub getCompactContactsModifiedSince{
                        my ($self, $request) = @_;

                        my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
                        return $self->{impl}->getCompactContactsModifiedSince($timestamp);
                      }

sub getCompactGroup{
                        my ($self, $request) = @_;

                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        return $self->{impl}->getCompactGroup($groupId);
                      }

sub getCompactRoom{
                        my ($self, $request) = @_;

                        my $roomId = ($request->{'roomId'}) ? $request->{'roomId'} : undef;
                        return $self->{impl}->getCompactRoom($roomId);
                      }

sub getContact{
                        my ($self, $request) = @_;

                        my $id = ($request->{'id'}) ? $request->{'id'} : undef;
                        return $self->{impl}->getContact($id);
                      }

sub getContacts{
                        my ($self, $request) = @_;

                        my $ids = ($request->{'ids'}) ? $request->{'ids'} : undef;
                        return $self->{impl}->getContacts($ids);
                      }

sub getContactWithFriendRequestStatus{
                        my ($self, $request) = @_;

                        my $id = ($request->{'id'}) ? $request->{'id'} : undef;
                        return $self->{impl}->getContactWithFriendRequestStatus($id);
                      }

sub getCountryWithRequestIp{
                        my ($self, $request) = @_;

                        return $self->{impl}->getCountryWithRequestIp();
                      }

sub getFavoriteMids{
                        my ($self, $request) = @_;

                        return $self->{impl}->getFavoriteMids();
                      }

sub getGroup{
                        my ($self, $request) = @_;

                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        return $self->{impl}->getGroup($groupId);
                      }

sub getGroupIdsInvited{
                        my ($self, $request) = @_;

                        return $self->{impl}->getGroupIdsInvited();
                      }

sub getGroupIdsJoined{
                        my ($self, $request) = @_;

                        return $self->{impl}->getGroupIdsJoined();
                      }

sub getGroups{
                        my ($self, $request) = @_;

                        my $groupIds = ($request->{'groupIds'}) ? $request->{'groupIds'} : undef;
                        return $self->{impl}->getGroups($groupIds);
                      }

sub getHiddenContactMids{
                        my ($self, $request) = @_;

                        return $self->{impl}->getHiddenContactMids();
                      }

sub getIdentityIdentifier{
                        my ($self, $request) = @_;

                        return $self->{impl}->getIdentityIdentifier();
                      }

sub getLastAnnouncementIndex{
                        my ($self, $request) = @_;

                        return $self->{impl}->getLastAnnouncementIndex();
                      }

sub getLastOpRevision{
                        my ($self, $request) = @_;

                        return $self->{impl}->getLastOpRevision();
                      }

sub getSuggestRevisions{
                        my ($self, $request) = @_;

                        return $self->{impl}->getSuggestRevisions();
                      }

sub getPreviousMessagesV2WithReadCount{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $endMessageId = ($request->{'endMessageId'}) ? $request->{'endMessageId'} : undef;
                        my $messagesCount = ($request->{'messagesCount'}) ? $request->{'messagesCount'} : undef;
                        return $self->{impl}->getPreviousMessagesV2WithReadCount($messageBoxId, $endMessageId, $messagesCount);
                      }

sub getMessageBox{
                        my ($self, $request) = @_;

                        my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $lastMessagesCount = ($request->{'lastMessagesCount'}) ? $request->{'lastMessagesCount'} : undef;
                        return $self->{impl}->getMessageBox($channelId, $messageBoxId, $lastMessagesCount);
                      }

sub getMessageBoxCompactWrapUp{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        return $self->{impl}->getMessageBoxCompactWrapUp($mid);
                      }

sub getMessageBoxCompactWrapUpList{
                        my ($self, $request) = @_;

                        my $start = ($request->{'start'}) ? $request->{'start'} : undef;
                        my $messageBoxCount = ($request->{'messageBoxCount'}) ? $request->{'messageBoxCount'} : undef;
                        return $self->{impl}->getMessageBoxCompactWrapUpList($start, $messageBoxCount);
                      }

sub getMessageBoxList{
                        my ($self, $request) = @_;

                        my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                        my $lastMessagesCount = ($request->{'lastMessagesCount'}) ? $request->{'lastMessagesCount'} : undef;
                        return $self->{impl}->getMessageBoxList($channelId, $lastMessagesCount);
                      }

sub getMessageBoxListByStatus{
                        my ($self, $request) = @_;

                        my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                        my $lastMessagesCount = ($request->{'lastMessagesCount'}) ? $request->{'lastMessagesCount'} : undef;
                        my $status = ($request->{'status'}) ? $request->{'status'} : undef;
                        return $self->{impl}->getMessageBoxListByStatus($channelId, $lastMessagesCount, $status);
                      }

sub getMessageBoxWrapUp{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        return $self->{impl}->getMessageBoxWrapUp($mid);
                      }

sub getMessageBoxWrapUpList{
                        my ($self, $request) = @_;

                        my $start = ($request->{'start'}) ? $request->{'start'} : undef;
                        my $messageBoxCount = ($request->{'messageBoxCount'}) ? $request->{'messageBoxCount'} : undef;
                        return $self->{impl}->getMessageBoxWrapUpList($start, $messageBoxCount);
                      }

sub getMessagesBySequenceNumber{
                        my ($self, $request) = @_;

                        my $channelId = ($request->{'channelId'}) ? $request->{'channelId'} : undef;
                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $startSeq = ($request->{'startSeq'}) ? $request->{'startSeq'} : undef;
                        my $endSeq = ($request->{'endSeq'}) ? $request->{'endSeq'} : undef;
                        return $self->{impl}->getMessagesBySequenceNumber($channelId, $messageBoxId, $startSeq, $endSeq);
                      }

sub getNextMessages{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $startSeq = ($request->{'startSeq'}) ? $request->{'startSeq'} : undef;
                        my $messagesCount = ($request->{'messagesCount'}) ? $request->{'messagesCount'} : undef;
                        return $self->{impl}->getNextMessages($messageBoxId, $startSeq, $messagesCount);
                      }

sub getNotificationPolicy{
                        my ($self, $request) = @_;

                        my $carrier = ($request->{'carrier'}) ? $request->{'carrier'} : undef;
                        return $self->{impl}->getNotificationPolicy($carrier);
                      }

sub getPreviousMessages{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $endSeq = ($request->{'endSeq'}) ? $request->{'endSeq'} : undef;
                        my $messagesCount = ($request->{'messagesCount'}) ? $request->{'messagesCount'} : undef;
                        return $self->{impl}->getPreviousMessages($messageBoxId, $endSeq, $messagesCount);
                      }

sub getProfile{
                        my ($self, $request) = @_;

                        return $self->{impl}->getProfile();
                      }

sub getProximityMatchCandidateList{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->getProximityMatchCandidateList($sessionId);
                      }

sub getProximityMatchCandidates{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->getProximityMatchCandidates($sessionId);
                      }

sub getRecentMessages{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $messagesCount = ($request->{'messagesCount'}) ? $request->{'messagesCount'} : undef;
                        return $self->{impl}->getRecentMessages($messageBoxId, $messagesCount);
                      }

sub getRecommendationIds{
                        my ($self, $request) = @_;

                        return $self->{impl}->getRecommendationIds();
                      }

sub getRoom{
                        my ($self, $request) = @_;

                        my $roomId = ($request->{'roomId'}) ? $request->{'roomId'} : undef;
                        return $self->{impl}->getRoom($roomId);
                      }

sub getRSAKeyInfo{
                        my ($self, $request) = @_;

                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        return $self->{impl}->getRSAKeyInfo($provider);
                      }

sub getServerTime{
                        my ($self, $request) = @_;

                        return $self->{impl}->getServerTime();
                      }

sub getSessions{
                        my ($self, $request) = @_;

                        return $self->{impl}->getSessions();
                      }

sub getSettings{
                        my ($self, $request) = @_;

                        return $self->{impl}->getSettings();
                      }

sub getGroupsV2{
                        my ($self, $request) = @_;

                        my $groupIds = ($request->{'groupIds'}) ? $request->{'groupIds'} : undef;
                        return $self->{impl}->getGroupsV2($groupIds);
                      }

sub getSettingsAttributes{
                        my ($self, $request) = @_;

                        my $attrBitset = ($request->{'attrBitset'}) ? $request->{'attrBitset'} : undef;
                        return $self->{impl}->getSettingsAttributes($attrBitset);
                      }

sub getSystemConfiguration{
                        my ($self, $request) = @_;

                        return $self->{impl}->getSystemConfiguration();
                      }

sub getUserTicket{
                        my ($self, $request) = @_;

                        return $self->{impl}->getUserTicket();
                      }

sub getWapInvitation{
                        my ($self, $request) = @_;

                        my $invitationHash = ($request->{'invitationHash'}) ? $request->{'invitationHash'} : undef;
                        return $self->{impl}->getWapInvitation($invitationHash);
                      }

sub invalidateUserTicket{
                        my ($self, $request) = @_;

                        return $self->{impl}->invalidateUserTicket();
                      }

sub inviteFriendsBySms{
                        my ($self, $request) = @_;

                        my $phoneNumberList = ($request->{'phoneNumberList'}) ? $request->{'phoneNumberList'} : undef;
                        return $self->{impl}->inviteFriendsBySms($phoneNumberList);
                      }

sub inviteIntoGroup{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->inviteIntoGroup($reqSeq, $groupId, $contactIds);
                      }

sub inviteIntoRoom{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $roomId = ($request->{'roomId'}) ? $request->{'roomId'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->inviteIntoRoom($reqSeq, $roomId, $contactIds);
                      }

sub inviteViaEmail{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $email = ($request->{'email'}) ? $request->{'email'} : undef;
                        my $name = ($request->{'name'}) ? $request->{'name'} : undef;
                        return $self->{impl}->inviteViaEmail($reqSeq, $email, $name);
                      }

sub isIdentityIdentifierAvailable{
                        my ($self, $request) = @_;

                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        return $self->{impl}->isIdentityIdentifierAvailable($provider, $identifier);
                      }

sub isUseridAvailable{
                        my ($self, $request) = @_;

                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        return $self->{impl}->isUseridAvailable($userid);
                      }

sub kickoutFromGroup{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->kickoutFromGroup($reqSeq, $groupId, $contactIds);
                      }

sub reissueGroupTicket{
                        my ($self, $request) = @_;

                        my $groupMid = ($request->{'groupMid'}) ? $request->{'groupMid'} : undef;
                        return $self->{impl}->reissueGroupTicket($groupMid);
                      }

sub findGroupByTicket{
                        my ($self, $request) = @_;

                        my $ticketId = ($request->{'ticketId'}) ? $request->{'ticketId'} : undef;
                        return $self->{impl}->findGroupByTicket($ticketId);
                      }

sub leaveGroup{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        return $self->{impl}->leaveGroup($reqSeq, $groupId);
                      }

sub leaveRoom{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $roomId = ($request->{'roomId'}) ? $request->{'roomId'} : undef;
                        return $self->{impl}->leaveRoom($reqSeq, $roomId);
                      }

sub loginWithIdentityCredential{
                        my ($self, $request) = @_;

                        my $identityProvider = ($request->{'identityProvider'}) ? $request->{'identityProvider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $password = ($request->{'password'}) ? $request->{'password'} : undef;
                        my $keepLoggedIn = ($request->{'keepLoggedIn'}) ? $request->{'keepLoggedIn'} : undef;
                        my $accessLocation = ($request->{'accessLocation'}) ? $request->{'accessLocation'} : undef;
                        my $systemName = ($request->{'systemName'}) ? $request->{'systemName'} : undef;
                        my $certificate = ($request->{'certificate'}) ? $request->{'certificate'} : undef;
                        return $self->{impl}->loginWithIdentityCredential($identityProvider, $identifier, $password, $keepLoggedIn, $accessLocation, $systemName, $certificate);
                      }

sub loginWithIdentityCredentialForCertificate{
                        my ($self, $request) = @_;

                        my $identityProvider = ($request->{'identityProvider'}) ? $request->{'identityProvider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $password = ($request->{'password'}) ? $request->{'password'} : undef;
                        my $keepLoggedIn = ($request->{'keepLoggedIn'}) ? $request->{'keepLoggedIn'} : undef;
                        my $accessLocation = ($request->{'accessLocation'}) ? $request->{'accessLocation'} : undef;
                        my $systemName = ($request->{'systemName'}) ? $request->{'systemName'} : undef;
                        my $certificate = ($request->{'certificate'}) ? $request->{'certificate'} : undef;
                        return $self->{impl}->loginWithIdentityCredentialForCertificate($identityProvider, $identifier, $password, $keepLoggedIn, $accessLocation, $systemName, $certificate);
                      }

sub loginWithVerifier{
                        my ($self, $request) = @_;

                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        return $self->{impl}->loginWithVerifier($verifier);
                      }

sub loginWithVerifierForCerificate{
                        my ($self, $request) = @_;

                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        return $self->{impl}->loginWithVerifierForCerificate($verifier);
                      }

sub loginWithVerifierForCertificate{
                        my ($self, $request) = @_;

                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        return $self->{impl}->loginWithVerifierForCertificate($verifier);
                      }

sub logout{
                        my ($self, $request) = @_;

                        return $self->{impl}->logout();
                      }

sub logoutSession{
                        my ($self, $request) = @_;

                        my $tokenKey = ($request->{'tokenKey'}) ? $request->{'tokenKey'} : undef;
                        return $self->{impl}->logoutSession($tokenKey);
                      }

sub noop{
                        my ($self, $request) = @_;

                        return $self->{impl}->noop();
                      }

sub notifiedRedirect{
                        my ($self, $request) = @_;

                        my $paramMap = ($request->{'paramMap'}) ? $request->{'paramMap'} : undef;
                        return $self->{impl}->notifiedRedirect($paramMap);
                      }

sub notifyBuddyOnAir{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $receiverMids = ($request->{'receiverMids'}) ? $request->{'receiverMids'} : undef;
                        return $self->{impl}->notifyBuddyOnAir($seq, $receiverMids);
                      }

sub notifyIndividualEvent{
                        my ($self, $request) = @_;

                        my $notificationStatus = ($request->{'notificationStatus'}) ? $request->{'notificationStatus'} : undef;
                        my $receiverMids = ($request->{'receiverMids'}) ? $request->{'receiverMids'} : undef;
                        return $self->{impl}->notifyIndividualEvent($notificationStatus, $receiverMids);
                      }

sub notifyInstalled{
                        my ($self, $request) = @_;

                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $applicationTypeWithExtensions = ($request->{'applicationTypeWithExtensions'}) ? $request->{'applicationTypeWithExtensions'} : undef;
                        return $self->{impl}->notifyInstalled($udidHash, $applicationTypeWithExtensions);
                      }

sub notifyRegistrationComplete{
                        my ($self, $request) = @_;

                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $applicationTypeWithExtensions = ($request->{'applicationTypeWithExtensions'}) ? $request->{'applicationTypeWithExtensions'} : undef;
                        return $self->{impl}->notifyRegistrationComplete($udidHash, $applicationTypeWithExtensions);
                      }

sub notifySleep{
                        my ($self, $request) = @_;

                        my $lastRev = ($request->{'lastRev'}) ? $request->{'lastRev'} : undef;
                        my $badge = ($request->{'badge'}) ? $request->{'badge'} : undef;
                        return $self->{impl}->notifySleep($lastRev, $badge);
                      }

sub notifyUpdated{
                        my ($self, $request) = @_;

                        my $lastRev = ($request->{'lastRev'}) ? $request->{'lastRev'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        return $self->{impl}->notifyUpdated($lastRev, $deviceInfo);
                      }

sub openProximityMatch{
                        my ($self, $request) = @_;

                        my $location = ($request->{'location'}) ? $request->{'location'} : undef;
                        return $self->{impl}->openProximityMatch($location);
                      }

sub registerBuddyUser{
                        my ($self, $request) = @_;

                        my $buddyId = ($request->{'buddyId'}) ? $request->{'buddyId'} : undef;
                        my $registrarPassword = ($request->{'registrarPassword'}) ? $request->{'registrarPassword'} : undef;
                        return $self->{impl}->registerBuddyUser($buddyId, $registrarPassword);
                      }

sub registerBuddyUserid{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        return $self->{impl}->registerBuddyUserid($seq, $userid);
                      }

sub registerDevice{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->registerDevice($sessionId);
                      }

sub registerDeviceWithIdentityCredential{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        return $self->{impl}->registerDeviceWithIdentityCredential($sessionId, $provider, $identifier, $verifier);
                      }

sub registerDeviceWithoutPhoneNumber{
                        my ($self, $request) = @_;

                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        return $self->{impl}->registerDeviceWithoutPhoneNumber($region, $udidHash, $deviceInfo);
                      }

sub registerDeviceWithoutPhoneNumberWithIdentityCredential{
                        my ($self, $request) = @_;

                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $migrationPincodeSessionId = ($request->{'migrationPincodeSessionId'}) ? $request->{'migrationPincodeSessionId'} : undef;
                        return $self->{impl}->registerDeviceWithoutPhoneNumberWithIdentityCredential($region, $udidHash, $deviceInfo, $provider, $identifier, $verifier, $mid, $migrationPincodeSessionId);
                      }

sub registerUserid{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        return $self->{impl}->registerUserid($reqSeq, $userid);
                      }

sub registerWapDevice{
                        my ($self, $request) = @_;

                        my $invitationHash = ($request->{'invitationHash'}) ? $request->{'invitationHash'} : undef;
                        my $guidHash = ($request->{'guidHash'}) ? $request->{'guidHash'} : undef;
                        my $email = ($request->{'email'}) ? $request->{'email'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        return $self->{impl}->registerWapDevice($invitationHash, $guidHash, $email, $deviceInfo);
                      }

sub registerWithExistingSnsIdAndIdentityCredential{
                        my ($self, $request) = @_;

                        my $identityCredential = ($request->{'identityCredential'}) ? $request->{'identityCredential'} : undef;
                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        return $self->{impl}->registerWithExistingSnsIdAndIdentityCredential($identityCredential, $region, $udidHash, $deviceInfo);
                      }

sub registerWithSnsId{
                        my ($self, $request) = @_;

                        my $snsIdType = ($request->{'snsIdType'}) ? $request->{'snsIdType'} : undef;
                        my $snsAccessToken = ($request->{'snsAccessToken'}) ? $request->{'snsAccessToken'} : undef;
                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        return $self->{impl}->registerWithSnsId($snsIdType, $snsAccessToken, $region, $udidHash, $deviceInfo, $mid);
                      }

sub registerWithSnsIdAndIdentityCredential{
                        my ($self, $request) = @_;

                        my $snsIdType = ($request->{'snsIdType'}) ? $request->{'snsIdType'} : undef;
                        my $snsAccessToken = ($request->{'snsAccessToken'}) ? $request->{'snsAccessToken'} : undef;
                        my $identityCredential = ($request->{'identityCredential'}) ? $request->{'identityCredential'} : undef;
                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        return $self->{impl}->registerWithSnsIdAndIdentityCredential($snsIdType, $snsAccessToken, $identityCredential, $region, $udidHash, $deviceInfo);
                      }

sub reissueDeviceCredential{
                        my ($self, $request) = @_;

                        return $self->{impl}->reissueDeviceCredential();
                      }

sub reissueUserTicket{
                        my ($self, $request) = @_;

                        my $expirationTime = ($request->{'expirationTime'}) ? $request->{'expirationTime'} : undef;
                        my $maxUseCount = ($request->{'maxUseCount'}) ? $request->{'maxUseCount'} : undef;
                        return $self->{impl}->reissueUserTicket($expirationTime, $maxUseCount);
                      }

sub getMessageReadRange{
                        my ($self, $request) = @_;

                        my $chatIds = ($request->{'chatIds'}) ? $request->{'chatIds'} : undef;
                        return $self->{impl}->getMessageReadRange($chatIds);
                      }

sub rejectGroupInvitation{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupId = ($request->{'groupId'}) ? $request->{'groupId'} : undef;
                        return $self->{impl}->rejectGroupInvitation($reqSeq, $groupId);
                      }

sub releaseSession{
                        my ($self, $request) = @_;

                        return $self->{impl}->releaseSession();
                      }

sub removeAllMessages{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $lastMessageId = ($request->{'lastMessageId'}) ? $request->{'lastMessageId'} : undef;
                        return $self->{impl}->removeAllMessages($seq, $lastMessageId);
                      }

sub removeBuddyLocation{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $index = ($request->{'index'}) ? $request->{'index'} : undef;
                        return $self->{impl}->removeBuddyLocation($mid, $index);
                      }

sub removeMessage{
                        my ($self, $request) = @_;

                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        return $self->{impl}->removeMessage($messageId);
                      }

sub makeUserAddMyselfAsContact{
                        my ($self, $request) = @_;

                        my $contactOwnerMid = ($request->{'contactOwnerMid'}) ? $request->{'contactOwnerMid'} : undef;
                        return $self->{impl}->makeUserAddMyselfAsContact($contactOwnerMid);
                      }

sub removeMessageFromMyHome{
                        my ($self, $request) = @_;

                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        return $self->{impl}->removeMessageFromMyHome($messageId);
                      }

sub removeSnsId{
                        my ($self, $request) = @_;

                        my $snsIdType = ($request->{'snsIdType'}) ? $request->{'snsIdType'} : undef;
                        return $self->{impl}->removeSnsId($snsIdType);
                      }

sub report{
                        my ($self, $request) = @_;

                        my $syncOpRevision = ($request->{'syncOpRevision'}) ? $request->{'syncOpRevision'} : undef;
                        my $category = ($request->{'category'}) ? $request->{'category'} : undef;
                        my $report = ($request->{'report'}) ? $request->{'report'} : undef;
                        return $self->{impl}->report($syncOpRevision, $category, $report);
                      }

sub reportContacts{
                        my ($self, $request) = @_;

                        my $syncOpRevision = ($request->{'syncOpRevision'}) ? $request->{'syncOpRevision'} : undef;
                        my $category = ($request->{'category'}) ? $request->{'category'} : undef;
                        my $contactReports = ($request->{'contactReports'}) ? $request->{'contactReports'} : undef;
                        my $actionType = ($request->{'actionType'}) ? $request->{'actionType'} : undef;
                        return $self->{impl}->reportContacts($syncOpRevision, $category, $contactReports, $actionType);
                      }

sub reportGroups{
                        my ($self, $request) = @_;

                        my $syncOpRevision = ($request->{'syncOpRevision'}) ? $request->{'syncOpRevision'} : undef;
                        my $groups = ($request->{'groups'}) ? $request->{'groups'} : undef;
                        return $self->{impl}->reportGroups($syncOpRevision, $groups);
                      }

sub reportProfile{
                        my ($self, $request) = @_;

                        my $syncOpRevision = ($request->{'syncOpRevision'}) ? $request->{'syncOpRevision'} : undef;
                        my $profile = ($request->{'profile'}) ? $request->{'profile'} : undef;
                        return $self->{impl}->reportProfile($syncOpRevision, $profile);
                      }

sub reportRooms{
                        my ($self, $request) = @_;

                        my $syncOpRevision = ($request->{'syncOpRevision'}) ? $request->{'syncOpRevision'} : undef;
                        my $rooms = ($request->{'rooms'}) ? $request->{'rooms'} : undef;
                        return $self->{impl}->reportRooms($syncOpRevision, $rooms);
                      }

sub findAndAddContactByMetaTag{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        my $reference = ($request->{'reference'}) ? $request->{'reference'} : undef;
                        return $self->{impl}->findAndAddContactByMetaTag($reqSeq, $userid, $reference);
                      }

sub reportSettings{
                        my ($self, $request) = @_;

                        my $syncOpRevision = ($request->{'syncOpRevision'}) ? $request->{'syncOpRevision'} : undef;
                        my $settings = ($request->{'settings'}) ? $request->{'settings'} : undef;
                        return $self->{impl}->reportSettings($syncOpRevision, $settings);
                      }

sub reportSpam{
                        my ($self, $request) = @_;

                        my $chatMid = ($request->{'chatMid'}) ? $request->{'chatMid'} : undef;
                        my $memberMids = ($request->{'memberMids'}) ? $request->{'memberMids'} : undef;
                        my $spammerReasons = ($request->{'spammerReasons'}) ? $request->{'spammerReasons'} : undef;
                        my $senderMids = ($request->{'senderMids'}) ? $request->{'senderMids'} : undef;
                        my $spamMessageIds = ($request->{'spamMessageIds'}) ? $request->{'spamMessageIds'} : undef;
                        my $spamMessages = ($request->{'spamMessages'}) ? $request->{'spamMessages'} : undef;
                        return $self->{impl}->reportSpam($chatMid, $memberMids, $spammerReasons, $senderMids, $spamMessageIds, $spamMessages);
                      }

sub reportSpammer{
                        my ($self, $request) = @_;

                        my $spammerMid = ($request->{'spammerMid'}) ? $request->{'spammerMid'} : undef;
                        my $spammerReasons = ($request->{'spammerReasons'}) ? $request->{'spammerReasons'} : undef;
                        my $spamMessageIds = ($request->{'spamMessageIds'}) ? $request->{'spamMessageIds'} : undef;
                        return $self->{impl}->reportSpammer($spammerMid, $spammerReasons, $spamMessageIds);
                      }

sub requestAccountPasswordReset{
                        my ($self, $request) = @_;

                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                        return $self->{impl}->requestAccountPasswordReset($provider, $identifier, $locale);
                      }

sub requestEmailConfirmation{
                        my ($self, $request) = @_;

                        my $emailConfirmation = ($request->{'emailConfirmation'}) ? $request->{'emailConfirmation'} : undef;
                        return $self->{impl}->requestEmailConfirmation($emailConfirmation);
                      }

sub requestIdentityUnbind{
                        my ($self, $request) = @_;

                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        return $self->{impl}->requestIdentityUnbind($provider, $identifier);
                      }

sub resendEmailConfirmation{
                        my ($self, $request) = @_;

                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        return $self->{impl}->resendEmailConfirmation($verifier);
                      }

sub resendPinCode{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->resendPinCode($sessionId);
                      }

sub resendPinCodeBySMS{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        return $self->{impl}->resendPinCodeBySMS($sessionId);
                      }

sub sendChatChecked{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $consumer = ($request->{'consumer'}) ? $request->{'consumer'} : undef;
                        my $lastMessageId = ($request->{'lastMessageId'}) ? $request->{'lastMessageId'} : undef;
                        return $self->{impl}->sendChatChecked($seq, $consumer, $lastMessageId);
                      }

sub sendMessageAwaitCommit{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $message = ($request->{'message'}) ? $request->{'message'} : undef;
                        return $self->{impl}->sendMessageAwaitCommit($seq, $message);
                      }

sub sendChatRemoved{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $consumer = ($request->{'consumer'}) ? $request->{'consumer'} : undef;
                        my $lastMessageId = ($request->{'lastMessageId'}) ? $request->{'lastMessageId'} : undef;
                        return $self->{impl}->sendChatRemoved($seq, $consumer, $lastMessageId);
                      }

sub sendContentPreviewUpdated{
                        my ($self, $request) = @_;

                        my $esq = ($request->{'esq'}) ? $request->{'esq'} : undef;
                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        my $receiverMids = ($request->{'receiverMids'}) ? $request->{'receiverMids'} : undef;
                        return $self->{impl}->sendContentPreviewUpdated($esq, $messageId, $receiverMids);
                      }

sub sendContentReceipt{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $consumer = ($request->{'consumer'}) ? $request->{'consumer'} : undef;
                        my $messageId = ($request->{'messageId'}) ? $request->{'messageId'} : undef;
                        return $self->{impl}->sendContentReceipt($seq, $consumer, $messageId);
                      }

sub sendDummyPush{
                        my ($self, $request) = @_;

                        return $self->{impl}->sendDummyPush();
                      }

sub removeE2EEPublicKey{
                        my ($self, $request) = @_;

                        my $publicKey = ($request->{'publicKey'}) ? $request->{'publicKey'} : undef;
                        return $self->{impl}->removeE2EEPublicKey($publicKey);
                      }

sub negotiateE2EEPublicKey{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        return $self->{impl}->negotiateE2EEPublicKey($mid);
                      }

sub getE2EEPublicKey{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $version = ($request->{'version'}) ? $request->{'version'} : undef;
                        my $keyId = ($request->{'keyId'}) ? $request->{'keyId'} : undef;
                        return $self->{impl}->getE2EEPublicKey($mid, $version, $keyId);
                      }

sub requestE2EEKeyExchange{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $temporalPublicKey = ($request->{'temporalPublicKey'}) ? $request->{'temporalPublicKey'} : undef;
                        my $publicKey = ($request->{'publicKey'}) ? $request->{'publicKey'} : undef;
                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        return $self->{impl}->requestE2EEKeyExchange($reqSeq, $temporalPublicKey, $publicKey, $verifier);
                      }

sub getLastE2EEPublicKeys{
                        my ($self, $request) = @_;

                        my $chatMid = ($request->{'chatMid'}) ? $request->{'chatMid'} : undef;
                        return $self->{impl}->getLastE2EEPublicKeys($chatMid);
                      }

sub registerE2EEPublicKey{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $publicKey = ($request->{'publicKey'}) ? $request->{'publicKey'} : undef;
                        return $self->{impl}->registerE2EEPublicKey($reqSeq, $publicKey);
                      }

sub getE2EEPublicKeys{
                        my ($self, $request) = @_;

                        return $self->{impl}->getE2EEPublicKeys();
                      }

sub getE2EEPublicKeysEx{
                        my ($self, $request) = @_;

                        my $ignoreE2EEStatus = ($request->{'ignoreE2EEStatus'}) ? $request->{'ignoreE2EEStatus'} : undef;
                        return $self->{impl}->getE2EEPublicKeysEx($ignoreE2EEStatus);
                      }

sub getReadMessageOpsInBulk{
                        my ($self, $request) = @_;

                        my $chatIds = ($request->{'chatIds'}) ? $request->{'chatIds'} : undef;
                        return $self->{impl}->getReadMessageOpsInBulk($chatIds);
                      }

sub sendEvent{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $message = ($request->{'message'}) ? $request->{'message'} : undef;
                        return $self->{impl}->sendEvent($seq, $message);
                      }

sub sendMessage{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $message = ($request->{'message'}) ? $request->{'message'} : undef;
                        return $self->{impl}->sendMessage($seq, $message);
                      }

sub sendMessageIgnored{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $consumer = ($request->{'consumer'}) ? $request->{'consumer'} : undef;
                        my $messageIds = ($request->{'messageIds'}) ? $request->{'messageIds'} : undef;
                        return $self->{impl}->sendMessageIgnored($seq, $consumer, $messageIds);
                      }

sub sendMessageReceipt{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $consumer = ($request->{'consumer'}) ? $request->{'consumer'} : undef;
                        my $messageIds = ($request->{'messageIds'}) ? $request->{'messageIds'} : undef;
                        return $self->{impl}->sendMessageReceipt($seq, $consumer, $messageIds);
                      }

sub findContactByMetaTag{
                        my ($self, $request) = @_;

                        my $userid = ($request->{'userid'}) ? $request->{'userid'} : undef;
                        my $reference = ($request->{'reference'}) ? $request->{'reference'} : undef;
                        return $self->{impl}->findContactByMetaTag($userid, $reference);
                      }

sub sendMessageToMyHome{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $message = ($request->{'message'}) ? $request->{'message'} : undef;
                        return $self->{impl}->sendMessageToMyHome($seq, $message);
                      }

sub setBuddyLocation{
                        my ($self, $request) = @_;

                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $index = ($request->{'index'}) ? $request->{'index'} : undef;
                        my $location = ($request->{'location'}) ? $request->{'location'} : undef;
                        return $self->{impl}->setBuddyLocation($mid, $index, $location);
                      }

sub setIdentityCredential{
                        my ($self, $request) = @_;

                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        my $provider = ($request->{'provider'}) ? $request->{'provider'} : undef;
                        return $self->{impl}->setIdentityCredential($identifier, $verifier, $provider);
                      }

sub setNotificationsEnabled{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $type = ($request->{'type'}) ? $request->{'type'} : undef;
                        my $target = ($request->{'target'}) ? $request->{'target'} : undef;
                        my $enablement = ($request->{'enablement'}) ? $request->{'enablement'} : undef;
                        return $self->{impl}->setNotificationsEnabled($reqSeq, $type, $target, $enablement);
                      }

sub startUpdateVerification{
                        my ($self, $request) = @_;

                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $carrier = ($request->{'carrier'}) ? $request->{'carrier'} : undef;
                        my $phone = ($request->{'phone'}) ? $request->{'phone'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        my $networkCode = ($request->{'networkCode'}) ? $request->{'networkCode'} : undef;
                        my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                        return $self->{impl}->startUpdateVerification($region, $carrier, $phone, $udidHash, $deviceInfo, $networkCode, $locale);
                      }

sub startVerification{
                        my ($self, $request) = @_;

                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        my $carrier = ($request->{'carrier'}) ? $request->{'carrier'} : undef;
                        my $phone = ($request->{'phone'}) ? $request->{'phone'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        my $networkCode = ($request->{'networkCode'}) ? $request->{'networkCode'} : undef;
                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
                        my $simInfo = ($request->{'simInfo'}) ? $request->{'simInfo'} : undef;
                        my $oldUdidHash = ($request->{'oldUdidHash'}) ? $request->{'oldUdidHash'} : undef;
                        return $self->{impl}->startVerification($region, $carrier, $phone, $udidHash, $deviceInfo, $networkCode, $mid, $locale, $simInfo, $oldUdidHash);
                      }

sub updateGroupPreferenceAttribute{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $groupMid = ($request->{'groupMid'}) ? $request->{'groupMid'} : undef;
                        my $updatedAttrs = ($request->{'updatedAttrs'}) ? $request->{'updatedAttrs'} : undef;
                        return $self->{impl}->updateGroupPreferenceAttribute($reqSeq, $groupMid, $updatedAttrs);
                      }

sub createRoomV2{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $contactIds = ($request->{'contactIds'}) ? $request->{'contactIds'} : undef;
                        return $self->{impl}->createRoomV2($reqSeq, $contactIds);
                      }

sub storeUpdateProfileAttribute{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $profileAttribute = ($request->{'profileAttribute'}) ? $request->{'profileAttribute'} : undef;
                        my $value = ($request->{'value'}) ? $request->{'value'} : undef;
                        return $self->{impl}->storeUpdateProfileAttribute($seq, $profileAttribute, $value);
                      }

sub syncContactBySnsIds{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $modifications = ($request->{'modifications'}) ? $request->{'modifications'} : undef;
                        return $self->{impl}->syncContactBySnsIds($reqSeq, $modifications);
                      }

sub syncContacts{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $localContacts = ($request->{'localContacts'}) ? $request->{'localContacts'} : undef;
                        return $self->{impl}->syncContacts($reqSeq, $localContacts);
                      }

sub trySendMessage{
                        my ($self, $request) = @_;

                        my $seq = ($request->{'seq'}) ? $request->{'seq'} : undef;
                        my $message = ($request->{'message'}) ? $request->{'message'} : undef;
                        return $self->{impl}->trySendMessage($seq, $message);
                      }

sub getNextMessagesV2{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $startMessageId = ($request->{'startMessageId'}) ? $request->{'startMessageId'} : undef;
                        my $messagesCount = ($request->{'messagesCount'}) ? $request->{'messagesCount'} : undef;
                        return $self->{impl}->getNextMessagesV2($messageBoxId, $startMessageId, $messagesCount);
                      }

sub getMessageBoxCompactWrapUpV2{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        return $self->{impl}->getMessageBoxCompactWrapUpV2($messageBoxId);
                      }

sub getRecentMessagesV2{
                        my ($self, $request) = @_;

                        my $messageBoxId = ($request->{'messageBoxId'}) ? $request->{'messageBoxId'} : undef;
                        my $messagesCount = ($request->{'messagesCount'}) ? $request->{'messagesCount'} : undef;
                        return $self->{impl}->getRecentMessagesV2($messageBoxId, $messagesCount);
                      }

sub validateContactsOnBot{
                        my ($self, $request) = @_;

                        my $contacts = ($request->{'contacts'}) ? $request->{'contacts'} : undef;
                        return $self->{impl}->validateContactsOnBot($contacts);
                      }

sub tryFriendRequest{
                        my ($self, $request) = @_;

                        my $midOrEMid = ($request->{'midOrEMid'}) ? $request->{'midOrEMid'} : undef;
                        my $method = ($request->{'method'}) ? $request->{'method'} : undef;
                        my $friendRequestParams = ($request->{'friendRequestParams'}) ? $request->{'friendRequestParams'} : undef;
                        return $self->{impl}->tryFriendRequest($midOrEMid, $method, $friendRequestParams);
                      }

sub unblockContact{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $id = ($request->{'id'}) ? $request->{'id'} : undef;
                        return $self->{impl}->unblockContact($reqSeq, $id);
                      }

sub unblockRecommendation{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $id = ($request->{'id'}) ? $request->{'id'} : undef;
                        return $self->{impl}->unblockRecommendation($reqSeq, $id);
                      }

sub unregisterUserAndDevice{
                        my ($self, $request) = @_;

                        return $self->{impl}->unregisterUserAndDevice();
                      }

sub updateApnsDeviceToken{
                        my ($self, $request) = @_;

                        my $apnsDeviceToken = ($request->{'apnsDeviceToken'}) ? $request->{'apnsDeviceToken'} : undef;
                        return $self->{impl}->updateApnsDeviceToken($apnsDeviceToken);
                      }

sub updateBuddySetting{
                        my ($self, $request) = @_;

                        my $key = ($request->{'key'}) ? $request->{'key'} : undef;
                        my $value = ($request->{'value'}) ? $request->{'value'} : undef;
                        return $self->{impl}->updateBuddySetting($key, $value);
                      }

sub updateC2DMRegistrationId{
                        my ($self, $request) = @_;

                        my $registrationId = ($request->{'registrationId'}) ? $request->{'registrationId'} : undef;
                        return $self->{impl}->updateC2DMRegistrationId($registrationId);
                      }

sub updateContactSetting{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $mid = ($request->{'mid'}) ? $request->{'mid'} : undef;
                        my $flag = ($request->{'flag'}) ? $request->{'flag'} : undef;
                        my $value = ($request->{'value'}) ? $request->{'value'} : undef;
                        return $self->{impl}->updateContactSetting($reqSeq, $mid, $flag, $value);
                      }

sub updateCustomModeSettings{
                        my ($self, $request) = @_;

                        my $customMode = ($request->{'customMode'}) ? $request->{'customMode'} : undef;
                        my $paramMap = ($request->{'paramMap'}) ? $request->{'paramMap'} : undef;
                        return $self->{impl}->updateCustomModeSettings($customMode, $paramMap);
                      }

sub updateDeviceInfo{
                        my ($self, $request) = @_;

                        my $deviceUid = ($request->{'deviceUid'}) ? $request->{'deviceUid'} : undef;
                        my $deviceInfo = ($request->{'deviceInfo'}) ? $request->{'deviceInfo'} : undef;
                        return $self->{impl}->updateDeviceInfo($deviceUid, $deviceInfo);
                      }

sub updateGroup{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $group = ($request->{'group'}) ? $request->{'group'} : undef;
                        return $self->{impl}->updateGroup($reqSeq, $group);
                      }

sub updateNotificationToken{
                        my ($self, $request) = @_;

                        my $type = ($request->{'type'}) ? $request->{'type'} : undef;
                        my $token = ($request->{'token'}) ? $request->{'token'} : undef;
                        return $self->{impl}->updateNotificationToken($type, $token);
                      }

sub updateNotificationTokenWithBytes{
                        my ($self, $request) = @_;

                        my $type = ($request->{'type'}) ? $request->{'type'} : undef;
                        my $token = ($request->{'token'}) ? $request->{'token'} : undef;
                        return $self->{impl}->updateNotificationTokenWithBytes($type, $token);
                      }

sub updateProfile{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $profile = ($request->{'profile'}) ? $request->{'profile'} : undef;
                        return $self->{impl}->updateProfile($reqSeq, $profile);
                      }

sub updateProfileAttribute{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $attr = ($request->{'attr'}) ? $request->{'attr'} : undef;
                        my $value = ($request->{'value'}) ? $request->{'value'} : undef;
                        return $self->{impl}->updateProfileAttribute($reqSeq, $attr, $value);
                      }

sub updateProfileAttributes{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $request = ($request->{'request'}) ? $request->{'request'} : undef;
                        return $self->{impl}->updateProfileAttributes($reqSeq, $request);
                      }

sub updateRegion{
                        my ($self, $request) = @_;

                        my $region = ($request->{'region'}) ? $request->{'region'} : undef;
                        return $self->{impl}->updateRegion($region);
                      }

sub updateSettings{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $settings = ($request->{'settings'}) ? $request->{'settings'} : undef;
                        return $self->{impl}->updateSettings($reqSeq, $settings);
                      }

sub updateSettings2{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $settings = ($request->{'settings'}) ? $request->{'settings'} : undef;
                        return $self->{impl}->updateSettings2($reqSeq, $settings);
                      }

sub updateSettingsAttribute{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $attr = ($request->{'attr'}) ? $request->{'attr'} : undef;
                        my $value = ($request->{'value'}) ? $request->{'value'} : undef;
                        return $self->{impl}->updateSettingsAttribute($reqSeq, $attr, $value);
                      }

sub updateSettingsAttributes{
                        my ($self, $request) = @_;

                        my $reqSeq = ($request->{'reqSeq'}) ? $request->{'reqSeq'} : undef;
                        my $attrBitset = ($request->{'attrBitset'}) ? $request->{'attrBitset'} : undef;
                        my $settings = ($request->{'settings'}) ? $request->{'settings'} : undef;
                        return $self->{impl}->updateSettingsAttributes($reqSeq, $attrBitset, $settings);
                      }

sub verifyIdentityCredential{
                        my ($self, $request) = @_;

                        my $identityProvider = ($request->{'identityProvider'}) ? $request->{'identityProvider'} : undef;
                        my $identifier = ($request->{'identifier'}) ? $request->{'identifier'} : undef;
                        my $password = ($request->{'password'}) ? $request->{'password'} : undef;
                        return $self->{impl}->verifyIdentityCredential($identityProvider, $identifier, $password);
                      }

sub verifyIdentityCredentialWithResult{
                        my ($self, $request) = @_;

                        my $identityCredential = ($request->{'identityCredential'}) ? $request->{'identityCredential'} : undef;
                        return $self->{impl}->verifyIdentityCredentialWithResult($identityCredential);
                      }

sub verifyPhone{
                        my ($self, $request) = @_;

                        my $sessionId = ($request->{'sessionId'}) ? $request->{'sessionId'} : undef;
                        my $pinCode = ($request->{'pinCode'}) ? $request->{'pinCode'} : undef;
                        my $udidHash = ($request->{'udidHash'}) ? $request->{'udidHash'} : undef;
                        return $self->{impl}->verifyPhone($sessionId, $pinCode, $udidHash);
                      }

sub verifyQrcode{
                        my ($self, $request) = @_;

                        my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                        my $pinCode = ($request->{'pinCode'}) ? $request->{'pinCode'} : undef;
                        return $self->{impl}->verifyQrcode($verifier, $pinCode);
                      }

package TalkServiceClient;


use base qw(TalkServiceIf);
sub new {
                        my ($classname, $input, $output) = @_;
                        my $self      = {};
                        $self->{input}  = $input;
                        $self->{output} = defined $output ? $output : $input;
                        $self->{seqid}  = 0;
                        return bless($self,$classname);
}

sub searchCollection{
  my $self = shift;
  my $query = shift;
  my $param = shift;

                                                $self->send_searchCollection($query, $param);
                        return $self->recv_searchCollection();
}

sub send_searchCollection{
  my $self = shift;
  my $query = shift;
  my $param = shift;

                        $self->{output}->writeMessageBegin('searchCollection', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_searchCollection_args();
                        $args->{query} = $query;
                        $args->{param} = $param;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_searchCollection{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_searchCollection_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "searchCollection failed: unknown result";
}
sub getChatRoomAnnouncementsBulk{
  my $self = shift;
  my $chatRoomMids = shift;

                                                $self->send_getChatRoomAnnouncementsBulk($chatRoomMids);
                        return $self->recv_getChatRoomAnnouncementsBulk();
}

sub send_getChatRoomAnnouncementsBulk{
  my $self = shift;
  my $chatRoomMids = shift;

                        $self->{output}->writeMessageBegin('getChatRoomAnnouncementsBulk', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getChatRoomAnnouncementsBulk_args();
                        $args->{chatRoomMids} = $chatRoomMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getChatRoomAnnouncementsBulk{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getChatRoomAnnouncementsBulk_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getChatRoomAnnouncementsBulk failed: unknown result";
}
sub getChatRoomAnnouncements{
  my $self = shift;
  my $chatRoomMid = shift;

                                                $self->send_getChatRoomAnnouncements($chatRoomMid);
                        return $self->recv_getChatRoomAnnouncements();
}

sub send_getChatRoomAnnouncements{
  my $self = shift;
  my $chatRoomMid = shift;

                        $self->{output}->writeMessageBegin('getChatRoomAnnouncements', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getChatRoomAnnouncements_args();
                        $args->{chatRoomMid} = $chatRoomMid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getChatRoomAnnouncements{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getChatRoomAnnouncements_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getChatRoomAnnouncements failed: unknown result";
}
sub createChatRoomAnnouncement{
  my $self = shift;
  my $reqSeq = shift;
  my $chatRoomMid = shift;
  my $type = shift;
  my $contents = shift;

                                                $self->send_createChatRoomAnnouncement($reqSeq, $chatRoomMid, $type, $contents);
                        return $self->recv_createChatRoomAnnouncement();
}

sub send_createChatRoomAnnouncement{
  my $self = shift;
  my $reqSeq = shift;
  my $chatRoomMid = shift;
  my $type = shift;
  my $contents = shift;

                        $self->{output}->writeMessageBegin('createChatRoomAnnouncement', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_createChatRoomAnnouncement_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{chatRoomMid} = $chatRoomMid;
                        $args->{type} = $type;
                        $args->{contents} = $contents;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_createChatRoomAnnouncement{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_createChatRoomAnnouncement_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "createChatRoomAnnouncement failed: unknown result";
}
sub removeChatRoomAnnouncement{
  my $self = shift;
  my $reqSeq = shift;
  my $chatRoomMid = shift;
  my $announcementSeq = shift;

                                                $self->send_removeChatRoomAnnouncement($reqSeq, $chatRoomMid, $announcementSeq);
                        $self->recv_removeChatRoomAnnouncement();
}

sub send_removeChatRoomAnnouncement{
  my $self = shift;
  my $reqSeq = shift;
  my $chatRoomMid = shift;
  my $announcementSeq = shift;

                        $self->{output}->writeMessageBegin('removeChatRoomAnnouncement', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeChatRoomAnnouncement_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{chatRoomMid} = $chatRoomMid;
                        $args->{announcementSeq} = $announcementSeq;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeChatRoomAnnouncement{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeChatRoomAnnouncement_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub unsendMessage{
  my $self = shift;
  my $seq = shift;
  my $messageId = shift;

                                                $self->send_unsendMessage($seq, $messageId);
                        $self->recv_unsendMessage();
}

sub send_unsendMessage{
  my $self = shift;
  my $seq = shift;
  my $messageId = shift;

                        $self->{output}->writeMessageBegin('unsendMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_unsendMessage_args();
                        $args->{seq} = $seq;
                        $args->{messageId} = $messageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_unsendMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_unsendMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub getGroupWithoutMembers{
  my $self = shift;
  my $groupId = shift;

                                                $self->send_getGroupWithoutMembers($groupId);
                        return $self->recv_getGroupWithoutMembers();
}

sub send_getGroupWithoutMembers{
  my $self = shift;
  my $groupId = shift;

                        $self->{output}->writeMessageBegin('getGroupWithoutMembers', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getGroupWithoutMembers_args();
                        $args->{groupId} = $groupId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getGroupWithoutMembers{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getGroupWithoutMembers_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getGroupWithoutMembers failed: unknown result";
}
sub requestResendMessage{
  my $self = shift;
  my $reqSeq = shift;
  my $senderMid = shift;
  my $messageId = shift;

                                                $self->send_requestResendMessage($reqSeq, $senderMid, $messageId);
                        $self->recv_requestResendMessage();
}

sub send_requestResendMessage{
  my $self = shift;
  my $reqSeq = shift;
  my $senderMid = shift;
  my $messageId = shift;

                        $self->{output}->writeMessageBegin('requestResendMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_requestResendMessage_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{senderMid} = $senderMid;
                        $args->{messageId} = $messageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_requestResendMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_requestResendMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub respondResendMessage{
  my $self = shift;
  my $reqSeq = shift;
  my $receiverMid = shift;
  my $originalMessageId = shift;
  my $resendMessage = shift;
  my $errorCode = shift;

                                                $self->send_respondResendMessage($reqSeq, $receiverMid, $originalMessageId, $resendMessage, $errorCode);
                        $self->recv_respondResendMessage();
}

sub send_respondResendMessage{
  my $self = shift;
  my $reqSeq = shift;
  my $receiverMid = shift;
  my $originalMessageId = shift;
  my $resendMessage = shift;
  my $errorCode = shift;

                        $self->{output}->writeMessageBegin('respondResendMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_respondResendMessage_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{receiverMid} = $receiverMid;
                        $args->{originalMessageId} = $originalMessageId;
                        $args->{resendMessage} = $resendMessage;
                        $args->{errorCode} = $errorCode;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_respondResendMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_respondResendMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub acceptGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

                                                $self->send_acceptGroupInvitation($reqSeq, $groupId);
                        $self->recv_acceptGroupInvitation();
}

sub send_acceptGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

                        $self->{output}->writeMessageBegin('acceptGroupInvitation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_acceptGroupInvitation_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupId} = $groupId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_acceptGroupInvitation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_acceptGroupInvitation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub acceptGroupInvitationByTicket{
  my $self = shift;
  my $reqSeq = shift;
  my $GroupMid = shift;
  my $ticketId = shift;

                                                $self->send_acceptGroupInvitationByTicket($reqSeq, $GroupMid, $ticketId);
                        $self->recv_acceptGroupInvitationByTicket();
}

sub send_acceptGroupInvitationByTicket{
  my $self = shift;
  my $reqSeq = shift;
  my $GroupMid = shift;
  my $ticketId = shift;

                        $self->{output}->writeMessageBegin('acceptGroupInvitationByTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_acceptGroupInvitationByTicket_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{GroupMid} = $GroupMid;
                        $args->{ticketId} = $ticketId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_acceptGroupInvitationByTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_acceptGroupInvitationByTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub acceptProximityMatches{
  my $self = shift;
  my $sessionId = shift;
  my $ids = shift;

                                                $self->send_acceptProximityMatches($sessionId, $ids);
                        $self->recv_acceptProximityMatches();
}

sub send_acceptProximityMatches{
  my $self = shift;
  my $sessionId = shift;
  my $ids = shift;

                        $self->{output}->writeMessageBegin('acceptProximityMatches', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_acceptProximityMatches_args();
                        $args->{sessionId} = $sessionId;
                        $args->{ids} = $ids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_acceptProximityMatches{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_acceptProximityMatches_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub acquireCallRoute{
  my $self = shift;
  my $to = shift;

                                                $self->send_acquireCallRoute($to);
                        return $self->recv_acquireCallRoute();
}

sub send_acquireCallRoute{
  my $self = shift;
  my $to = shift;

                        $self->{output}->writeMessageBegin('acquireCallRoute', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_acquireCallRoute_args();
                        $args->{to} = $to;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_acquireCallRoute{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_acquireCallRoute_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "acquireCallRoute failed: unknown result";
}
sub acquireCallTicket{
  my $self = shift;
  my $to = shift;

                                                $self->send_acquireCallTicket($to);
                        return $self->recv_acquireCallTicket();
}

sub send_acquireCallTicket{
  my $self = shift;
  my $to = shift;

                        $self->{output}->writeMessageBegin('acquireCallTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_acquireCallTicket_args();
                        $args->{to} = $to;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_acquireCallTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_acquireCallTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "acquireCallTicket failed: unknown result";
}
sub acquireEncryptedAccessToken{
  my $self = shift;
  my $featureType = shift;

                                                $self->send_acquireEncryptedAccessToken($featureType);
                        return $self->recv_acquireEncryptedAccessToken();
}

sub send_acquireEncryptedAccessToken{
  my $self = shift;
  my $featureType = shift;

                        $self->{output}->writeMessageBegin('acquireEncryptedAccessToken', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_acquireEncryptedAccessToken_args();
                        $args->{featureType} = $featureType;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_acquireEncryptedAccessToken{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_acquireEncryptedAccessToken_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "acquireEncryptedAccessToken failed: unknown result";
}
sub addSnsId{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;

                                                $self->send_addSnsId($snsIdType, $snsAccessToken);
                        return $self->recv_addSnsId();
}

sub send_addSnsId{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;

                        $self->{output}->writeMessageBegin('addSnsId', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_addSnsId_args();
                        $args->{snsIdType} = $snsIdType;
                        $args->{snsAccessToken} = $snsAccessToken;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_addSnsId{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_addSnsId_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "addSnsId failed: unknown result";
}
sub blockContact{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                                                $self->send_blockContact($reqSeq, $id);
                        $self->recv_blockContact();
}

sub send_blockContact{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                        $self->{output}->writeMessageBegin('blockContact', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_blockContact_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{id} = $id;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_blockContact{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_blockContact_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub blockRecommendation{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                                                $self->send_blockRecommendation($reqSeq, $id);
                        $self->recv_blockRecommendation();
}

sub send_blockRecommendation{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                        $self->{output}->writeMessageBegin('blockRecommendation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_blockRecommendation_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{id} = $id;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_blockRecommendation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_blockRecommendation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub cancelGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

                                                $self->send_cancelGroupInvitation($reqSeq, $groupId, $contactIds);
                        $self->recv_cancelGroupInvitation();
}

sub send_cancelGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('cancelGroupInvitation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_cancelGroupInvitation_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupId} = $groupId;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_cancelGroupInvitation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_cancelGroupInvitation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub changeVerificationMethod{
  my $self = shift;
  my $sessionId = shift;
  my $method = shift;

                                                $self->send_changeVerificationMethod($sessionId, $method);
                        return $self->recv_changeVerificationMethod();
}

sub send_changeVerificationMethod{
  my $self = shift;
  my $sessionId = shift;
  my $method = shift;

                        $self->{output}->writeMessageBegin('changeVerificationMethod', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_changeVerificationMethod_args();
                        $args->{sessionId} = $sessionId;
                        $args->{method} = $method;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_changeVerificationMethod{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_changeVerificationMethod_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "changeVerificationMethod failed: unknown result";
}
sub clearIdentityCredential{
  my $self = shift;

                                                $self->send_clearIdentityCredential();
                        $self->recv_clearIdentityCredential();
}

sub send_clearIdentityCredential{
  my $self = shift;

                        $self->{output}->writeMessageBegin('clearIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_clearIdentityCredential_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_clearIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_clearIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub clearMessageBox{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;

                                                $self->send_clearMessageBox($channelId, $messageBoxId);
                        $self->recv_clearMessageBox();
}

sub send_clearMessageBox{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;

                        $self->{output}->writeMessageBegin('clearMessageBox', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_clearMessageBox_args();
                        $args->{channelId} = $channelId;
                        $args->{messageBoxId} = $messageBoxId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_clearMessageBox{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_clearMessageBox_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub closeProximityMatch{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_closeProximityMatch($sessionId);
                        $self->recv_closeProximityMatch();
}

sub send_closeProximityMatch{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('closeProximityMatch', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_closeProximityMatch_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_closeProximityMatch{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_closeProximityMatch_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub commitSendMessage{
  my $self = shift;
  my $seq = shift;
  my $messageId = shift;
  my $receiverMids = shift;

                                                $self->send_commitSendMessage($seq, $messageId, $receiverMids);
                        return $self->recv_commitSendMessage();
}

sub send_commitSendMessage{
  my $self = shift;
  my $seq = shift;
  my $messageId = shift;
  my $receiverMids = shift;

                        $self->{output}->writeMessageBegin('commitSendMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_commitSendMessage_args();
                        $args->{seq} = $seq;
                        $args->{messageId} = $messageId;
                        $args->{receiverMids} = $receiverMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_commitSendMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_commitSendMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "commitSendMessage failed: unknown result";
}
sub commitSendMessages{
  my $self = shift;
  my $seq = shift;
  my $messageIds = shift;
  my $receiverMids = shift;

                                                $self->send_commitSendMessages($seq, $messageIds, $receiverMids);
                        return $self->recv_commitSendMessages();
}

sub send_commitSendMessages{
  my $self = shift;
  my $seq = shift;
  my $messageIds = shift;
  my $receiverMids = shift;

                        $self->{output}->writeMessageBegin('commitSendMessages', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_commitSendMessages_args();
                        $args->{seq} = $seq;
                        $args->{messageIds} = $messageIds;
                        $args->{receiverMids} = $receiverMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_commitSendMessages{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_commitSendMessages_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "commitSendMessages failed: unknown result";
}
sub commitUpdateProfile{
  my $self = shift;
  my $seq = shift;
  my $attrs = shift;
  my $receiverMids = shift;

                                                $self->send_commitUpdateProfile($seq, $attrs, $receiverMids);
                        return $self->recv_commitUpdateProfile();
}

sub send_commitUpdateProfile{
  my $self = shift;
  my $seq = shift;
  my $attrs = shift;
  my $receiverMids = shift;

                        $self->{output}->writeMessageBegin('commitUpdateProfile', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_commitUpdateProfile_args();
                        $args->{seq} = $seq;
                        $args->{attrs} = $attrs;
                        $args->{receiverMids} = $receiverMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_commitUpdateProfile{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_commitUpdateProfile_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "commitUpdateProfile failed: unknown result";
}
sub confirmEmail{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;

                                                $self->send_confirmEmail($verifier, $pinCode);
                        $self->recv_confirmEmail();
}

sub send_confirmEmail{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;

                        $self->{output}->writeMessageBegin('confirmEmail', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_confirmEmail_args();
                        $args->{verifier} = $verifier;
                        $args->{pinCode} = $pinCode;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_confirmEmail{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_confirmEmail_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub createGroup{
  my $self = shift;
  my $seq = shift;
  my $name = shift;
  my $contactIds = shift;

                                                $self->send_createGroup($seq, $name, $contactIds);
                        return $self->recv_createGroup();
}

sub send_createGroup{
  my $self = shift;
  my $seq = shift;
  my $name = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('createGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_createGroup_args();
                        $args->{seq} = $seq;
                        $args->{name} = $name;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_createGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_createGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "createGroup failed: unknown result";
}
sub createQrcodeBase64Image{
  my $self = shift;
  my $url = shift;
  my $characterSet = shift;
  my $imageSize = shift;
  my $x = shift;
  my $y = shift;
  my $width = shift;
  my $height = shift;

                                                $self->send_createQrcodeBase64Image($url, $characterSet, $imageSize, $x, $y, $width, $height);
                        return $self->recv_createQrcodeBase64Image();
}

sub send_createQrcodeBase64Image{
  my $self = shift;
  my $url = shift;
  my $characterSet = shift;
  my $imageSize = shift;
  my $x = shift;
  my $y = shift;
  my $width = shift;
  my $height = shift;

                        $self->{output}->writeMessageBegin('createQrcodeBase64Image', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_createQrcodeBase64Image_args();
                        $args->{url} = $url;
                        $args->{characterSet} = $characterSet;
                        $args->{imageSize} = $imageSize;
                        $args->{x} = $x;
                        $args->{y} = $y;
                        $args->{width} = $width;
                        $args->{height} = $height;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_createQrcodeBase64Image{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_createQrcodeBase64Image_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "createQrcodeBase64Image failed: unknown result";
}
sub createRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $contactIds = shift;

                                                $self->send_createRoom($reqSeq, $contactIds);
                        return $self->recv_createRoom();
}

sub send_createRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('createRoom', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_createRoom_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_createRoom{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_createRoom_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "createRoom failed: unknown result";
}
sub createSession{
  my $self = shift;

                                                $self->send_createSession();
                        return $self->recv_createSession();
}

sub send_createSession{
  my $self = shift;

                        $self->{output}->writeMessageBegin('createSession', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_createSession_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_createSession{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_createSession_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "createSession failed: unknown result";
}
sub fetchAnnouncements{
  my $self = shift;
  my $lastFetchedIndex = shift;

                                                $self->send_fetchAnnouncements($lastFetchedIndex);
                        return $self->recv_fetchAnnouncements();
}

sub send_fetchAnnouncements{
  my $self = shift;
  my $lastFetchedIndex = shift;

                        $self->{output}->writeMessageBegin('fetchAnnouncements', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_fetchAnnouncements_args();
                        $args->{lastFetchedIndex} = $lastFetchedIndex;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_fetchAnnouncements{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_fetchAnnouncements_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "fetchAnnouncements failed: unknown result";
}
sub fetchMessages{
  my $self = shift;
  my $localTs = shift;
  my $count = shift;

                                                $self->send_fetchMessages($localTs, $count);
                        return $self->recv_fetchMessages();
}

sub send_fetchMessages{
  my $self = shift;
  my $localTs = shift;
  my $count = shift;

                        $self->{output}->writeMessageBegin('fetchMessages', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_fetchMessages_args();
                        $args->{localTs} = $localTs;
                        $args->{count} = $count;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_fetchMessages{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_fetchMessages_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "fetchMessages failed: unknown result";
}
sub fetchOperations{
  my $self = shift;
  my $localRev = shift;
  my $count = shift;

                                                $self->send_fetchOperations($localRev, $count);
                        return $self->recv_fetchOperations();
}

sub send_fetchOperations{
  my $self = shift;
  my $localRev = shift;
  my $count = shift;

                        $self->{output}->writeMessageBegin('fetchOperations', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_fetchOperations_args();
                        $args->{localRev} = $localRev;
                        $args->{count} = $count;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_fetchOperations{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_fetchOperations_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "fetchOperations failed: unknown result";
}
sub fetchOps{
  my $self = shift;
  my $localRev = shift;
  my $count = shift;
  my $globalRev = shift;
  my $individualRev = shift;

                                                $self->send_fetchOps($localRev, $count, $globalRev, $individualRev);
                        return $self->recv_fetchOps();
}

sub send_fetchOps{
  my $self = shift;
  my $localRev = shift;
  my $count = shift;
  my $globalRev = shift;
  my $individualRev = shift;

                        $self->{output}->writeMessageBegin('fetchOps', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_fetchOps_args();
                        $args->{localRev} = $localRev;
                        $args->{count} = $count;
                        $args->{globalRev} = $globalRev;
                        $args->{individualRev} = $individualRev;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_fetchOps{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_fetchOps_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "fetchOps failed: unknown result";
}
sub findAndAddContactsByEmail{
  my $self = shift;
  my $reqSeq = shift;
  my $emails = shift;

                                                $self->send_findAndAddContactsByEmail($reqSeq, $emails);
                        return $self->recv_findAndAddContactsByEmail();
}

sub send_findAndAddContactsByEmail{
  my $self = shift;
  my $reqSeq = shift;
  my $emails = shift;

                        $self->{output}->writeMessageBegin('findAndAddContactsByEmail', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findAndAddContactsByEmail_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{emails} = $emails;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findAndAddContactsByEmail{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findAndAddContactsByEmail_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findAndAddContactsByEmail failed: unknown result";
}
sub findAndAddContactsByMid{
  my $self = shift;
  my $reqSeq = shift;
  my $mid = shift;
  my $type = shift;
  my $reference = shift;

                                                $self->send_findAndAddContactsByMid($reqSeq, $mid, $type, $reference);
                        return $self->recv_findAndAddContactsByMid();
}

sub send_findAndAddContactsByMid{
  my $self = shift;
  my $reqSeq = shift;
  my $mid = shift;
  my $type = shift;
  my $reference = shift;

                        $self->{output}->writeMessageBegin('findAndAddContactsByMid', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findAndAddContactsByMid_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{mid} = $mid;
                        $args->{type} = $type;
                        $args->{reference} = $reference;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findAndAddContactsByMid{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findAndAddContactsByMid_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findAndAddContactsByMid failed: unknown result";
}
sub findGroupByTicketV2{
  my $self = shift;
  my $ticketId = shift;

                                                $self->send_findGroupByTicketV2($ticketId);
                        return $self->recv_findGroupByTicketV2();
}

sub send_findGroupByTicketV2{
  my $self = shift;
  my $ticketId = shift;

                        $self->{output}->writeMessageBegin('findGroupByTicketV2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findGroupByTicketV2_args();
                        $args->{ticketId} = $ticketId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findGroupByTicketV2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findGroupByTicketV2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findGroupByTicketV2 failed: unknown result";
}
sub findAndAddContactsByPhone{
  my $self = shift;
  my $reqSeq = shift;
  my $phones = shift;

                                                $self->send_findAndAddContactsByPhone($reqSeq, $phones);
                        return $self->recv_findAndAddContactsByPhone();
}

sub send_findAndAddContactsByPhone{
  my $self = shift;
  my $reqSeq = shift;
  my $phones = shift;

                        $self->{output}->writeMessageBegin('findAndAddContactsByPhone', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findAndAddContactsByPhone_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{phones} = $phones;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findAndAddContactsByPhone{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findAndAddContactsByPhone_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findAndAddContactsByPhone failed: unknown result";
}
sub getFriendRequests{
  my $self = shift;
  my $direction = shift;
  my $lastSeenSeqId = shift;

                                                $self->send_getFriendRequests($direction, $lastSeenSeqId);
                        return $self->recv_getFriendRequests();
}

sub send_getFriendRequests{
  my $self = shift;
  my $direction = shift;
  my $lastSeenSeqId = shift;

                        $self->{output}->writeMessageBegin('getFriendRequests', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getFriendRequests_args();
                        $args->{direction} = $direction;
                        $args->{lastSeenSeqId} = $lastSeenSeqId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getFriendRequests{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getFriendRequests_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getFriendRequests failed: unknown result";
}
sub removeFriendRequest{
  my $self = shift;
  my $direction = shift;
  my $midOrEMid = shift;

                                                $self->send_removeFriendRequest($direction, $midOrEMid);
                        $self->recv_removeFriendRequest();
}

sub send_removeFriendRequest{
  my $self = shift;
  my $direction = shift;
  my $midOrEMid = shift;

                        $self->{output}->writeMessageBegin('removeFriendRequest', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeFriendRequest_args();
                        $args->{direction} = $direction;
                        $args->{midOrEMid} = $midOrEMid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeFriendRequest{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeFriendRequest_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub findAndAddContactsByUserid{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;

                                                $self->send_findAndAddContactsByUserid($reqSeq, $userid);
                        return $self->recv_findAndAddContactsByUserid();
}

sub send_findAndAddContactsByUserid{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;

                        $self->{output}->writeMessageBegin('findAndAddContactsByUserid', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findAndAddContactsByUserid_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{userid} = $userid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findAndAddContactsByUserid{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findAndAddContactsByUserid_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findAndAddContactsByUserid failed: unknown result";
}
sub findContactByUserid{
  my $self = shift;
  my $userid = shift;

                                                $self->send_findContactByUserid($userid);
                        return $self->recv_findContactByUserid();
}

sub send_findContactByUserid{
  my $self = shift;
  my $userid = shift;

                        $self->{output}->writeMessageBegin('findContactByUserid', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findContactByUserid_args();
                        $args->{userid} = $userid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findContactByUserid{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findContactByUserid_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findContactByUserid failed: unknown result";
}
sub findContactByUserTicket{
  my $self = shift;
  my $ticketIdWithTag = shift;

                                                $self->send_findContactByUserTicket($ticketIdWithTag);
                        return $self->recv_findContactByUserTicket();
}

sub send_findContactByUserTicket{
  my $self = shift;
  my $ticketIdWithTag = shift;

                        $self->{output}->writeMessageBegin('findContactByUserTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findContactByUserTicket_args();
                        $args->{ticketIdWithTag} = $ticketIdWithTag;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findContactByUserTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findContactByUserTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findContactByUserTicket failed: unknown result";
}
sub findContactsByEmail{
  my $self = shift;
  my $emails = shift;

                                                $self->send_findContactsByEmail($emails);
                        return $self->recv_findContactsByEmail();
}

sub send_findContactsByEmail{
  my $self = shift;
  my $emails = shift;

                        $self->{output}->writeMessageBegin('findContactsByEmail', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findContactsByEmail_args();
                        $args->{emails} = $emails;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findContactsByEmail{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findContactsByEmail_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findContactsByEmail failed: unknown result";
}
sub findContactsByPhone{
  my $self = shift;
  my $phones = shift;

                                                $self->send_findContactsByPhone($phones);
                        return $self->recv_findContactsByPhone();
}

sub send_findContactsByPhone{
  my $self = shift;
  my $phones = shift;

                        $self->{output}->writeMessageBegin('findContactsByPhone', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findContactsByPhone_args();
                        $args->{phones} = $phones;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findContactsByPhone{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findContactsByPhone_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findContactsByPhone failed: unknown result";
}
sub findSnsIdUserStatus{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $udidHash = shift;

                                                $self->send_findSnsIdUserStatus($snsIdType, $snsAccessToken, $udidHash);
                        return $self->recv_findSnsIdUserStatus();
}

sub send_findSnsIdUserStatus{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $udidHash = shift;

                        $self->{output}->writeMessageBegin('findSnsIdUserStatus', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findSnsIdUserStatus_args();
                        $args->{snsIdType} = $snsIdType;
                        $args->{snsAccessToken} = $snsAccessToken;
                        $args->{udidHash} = $udidHash;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findSnsIdUserStatus{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findSnsIdUserStatus_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findSnsIdUserStatus failed: unknown result";
}
sub finishUpdateVerification{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_finishUpdateVerification($sessionId);
                        $self->recv_finishUpdateVerification();
}

sub send_finishUpdateVerification{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('finishUpdateVerification', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_finishUpdateVerification_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_finishUpdateVerification{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_finishUpdateVerification_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub generateUserTicket{
  my $self = shift;
  my $expirationTime = shift;
  my $maxUseCount = shift;

                                                $self->send_generateUserTicket($expirationTime, $maxUseCount);
                        return $self->recv_generateUserTicket();
}

sub send_generateUserTicket{
  my $self = shift;
  my $expirationTime = shift;
  my $maxUseCount = shift;

                        $self->{output}->writeMessageBegin('generateUserTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_generateUserTicket_args();
                        $args->{expirationTime} = $expirationTime;
                        $args->{maxUseCount} = $maxUseCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_generateUserTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_generateUserTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "generateUserTicket failed: unknown result";
}
sub destroyMessage{
  my $self = shift;
  my $seq = shift;
  my $chatId = shift;
  my $messageId = shift;
  my $sessionId = shift;

                                                $self->send_destroyMessage($seq, $chatId, $messageId, $sessionId);
                        $self->recv_destroyMessage();
}

sub send_destroyMessage{
  my $self = shift;
  my $seq = shift;
  my $chatId = shift;
  my $messageId = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('destroyMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_destroyMessage_args();
                        $args->{seq} = $seq;
                        $args->{chatId} = $chatId;
                        $args->{messageId} = $messageId;
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_destroyMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_destroyMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub getAcceptedProximityMatches{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_getAcceptedProximityMatches($sessionId);
                        return $self->recv_getAcceptedProximityMatches();
}

sub send_getAcceptedProximityMatches{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('getAcceptedProximityMatches', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getAcceptedProximityMatches_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getAcceptedProximityMatches{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getAcceptedProximityMatches_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getAcceptedProximityMatches failed: unknown result";
}
sub getActiveBuddySubscriberIds{
  my $self = shift;

                                                $self->send_getActiveBuddySubscriberIds();
                        return $self->recv_getActiveBuddySubscriberIds();
}

sub send_getActiveBuddySubscriberIds{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getActiveBuddySubscriberIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getActiveBuddySubscriberIds_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getActiveBuddySubscriberIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getActiveBuddySubscriberIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getActiveBuddySubscriberIds failed: unknown result";
}
sub getAllContactIds{
  my $self = shift;

                                                $self->send_getAllContactIds();
                        return $self->recv_getAllContactIds();
}

sub send_getAllContactIds{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getAllContactIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getAllContactIds_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getAllContactIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getAllContactIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getAllContactIds failed: unknown result";
}
sub getAuthQrcode{
  my $self = shift;
  my $keepLoggedIn = shift;
  my $systemName = shift;

                                                $self->send_getAuthQrcode($keepLoggedIn, $systemName);
                        return $self->recv_getAuthQrcode();
}

sub send_getAuthQrcode{
  my $self = shift;
  my $keepLoggedIn = shift;
  my $systemName = shift;

                        $self->{output}->writeMessageBegin('getAuthQrcode', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getAuthQrcode_args();
                        $args->{keepLoggedIn} = $keepLoggedIn;
                        $args->{systemName} = $systemName;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getAuthQrcode{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getAuthQrcode_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getAuthQrcode failed: unknown result";
}
sub getBlockedContactIds{
  my $self = shift;

                                                $self->send_getBlockedContactIds();
                        return $self->recv_getBlockedContactIds();
}

sub send_getBlockedContactIds{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getBlockedContactIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getBlockedContactIds_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getBlockedContactIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getBlockedContactIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getBlockedContactIds failed: unknown result";
}
sub registerWithPhoneNumber{
  my $self = shift;
  my $sessionId = shift;
  my $migrationPincodeSessionId = shift;

                                                $self->send_registerWithPhoneNumber($sessionId, $migrationPincodeSessionId);
                        return $self->recv_registerWithPhoneNumber();
}

sub send_registerWithPhoneNumber{
  my $self = shift;
  my $sessionId = shift;
  my $migrationPincodeSessionId = shift;

                        $self->{output}->writeMessageBegin('registerWithPhoneNumber', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerWithPhoneNumber_args();
                        $args->{sessionId} = $sessionId;
                        $args->{migrationPincodeSessionId} = $migrationPincodeSessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerWithPhoneNumber{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerWithPhoneNumber_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerWithPhoneNumber failed: unknown result";
}
sub registerWithPhoneNumberAndPassword{
  my $self = shift;
  my $sessionId = shift;
  my $keynm = shift;
  my $encrypted = shift;

                                                $self->send_registerWithPhoneNumberAndPassword($sessionId, $keynm, $encrypted);
                        return $self->recv_registerWithPhoneNumberAndPassword();
}

sub send_registerWithPhoneNumberAndPassword{
  my $self = shift;
  my $sessionId = shift;
  my $keynm = shift;
  my $encrypted = shift;

                        $self->{output}->writeMessageBegin('registerWithPhoneNumberAndPassword', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerWithPhoneNumberAndPassword_args();
                        $args->{sessionId} = $sessionId;
                        $args->{keynm} = $keynm;
                        $args->{encrypted} = $encrypted;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerWithPhoneNumberAndPassword{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerWithPhoneNumberAndPassword_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerWithPhoneNumberAndPassword failed: unknown result";
}
sub getAnalyticsInfo{
  my $self = shift;

                                                $self->send_getAnalyticsInfo();
                        return $self->recv_getAnalyticsInfo();
}

sub send_getAnalyticsInfo{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getAnalyticsInfo', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getAnalyticsInfo_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getAnalyticsInfo{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getAnalyticsInfo_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getAnalyticsInfo failed: unknown result";
}
sub reportClientStatistics{
  my $self = shift;
  my $reqSeq = shift;
  my $category = shift;
  my $count = shift;

                                                $self->send_reportClientStatistics($reqSeq, $category, $count);
                        $self->recv_reportClientStatistics();
}

sub send_reportClientStatistics{
  my $self = shift;
  my $reqSeq = shift;
  my $category = shift;
  my $count = shift;

                        $self->{output}->writeMessageBegin('reportClientStatistics', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportClientStatistics_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{category} = $category;
                        $args->{count} = $count;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportClientStatistics{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportClientStatistics_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub verifyPhoneNumberForLogin{
  my $self = shift;
  my $verifierFromPhone = shift;
  my $pinCodeForPhone = shift;
  my $verifierFromLogin = shift;

                                                $self->send_verifyPhoneNumberForLogin($verifierFromPhone, $pinCodeForPhone, $verifierFromLogin);
                        return $self->recv_verifyPhoneNumberForLogin();
}

sub send_verifyPhoneNumberForLogin{
  my $self = shift;
  my $verifierFromPhone = shift;
  my $pinCodeForPhone = shift;
  my $verifierFromLogin = shift;

                        $self->{output}->writeMessageBegin('verifyPhoneNumberForLogin', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_verifyPhoneNumberForLogin_args();
                        $args->{verifierFromPhone} = $verifierFromPhone;
                        $args->{pinCodeForPhone} = $pinCodeForPhone;
                        $args->{verifierFromLogin} = $verifierFromLogin;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_verifyPhoneNumberForLogin{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_verifyPhoneNumberForLogin_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "verifyPhoneNumberForLogin failed: unknown result";
}
sub verifyPhoneNumber{
  my $self = shift;
  my $sessionId = shift;
  my $pinCode = shift;
  my $udidHash = shift;
  my $migrationPincodeSessionId = shift;
  my $oldUdidHash = shift;

                                                $self->send_verifyPhoneNumber($sessionId, $pinCode, $udidHash, $migrationPincodeSessionId, $oldUdidHash);
                        return $self->recv_verifyPhoneNumber();
}

sub send_verifyPhoneNumber{
  my $self = shift;
  my $sessionId = shift;
  my $pinCode = shift;
  my $udidHash = shift;
  my $migrationPincodeSessionId = shift;
  my $oldUdidHash = shift;

                        $self->{output}->writeMessageBegin('verifyPhoneNumber', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_verifyPhoneNumber_args();
                        $args->{sessionId} = $sessionId;
                        $args->{pinCode} = $pinCode;
                        $args->{udidHash} = $udidHash;
                        $args->{migrationPincodeSessionId} = $migrationPincodeSessionId;
                        $args->{oldUdidHash} = $oldUdidHash;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_verifyPhoneNumber{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_verifyPhoneNumber_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "verifyPhoneNumber failed: unknown result";
}
sub getBlockedContactIdsByRange{
  my $self = shift;
  my $start = shift;
  my $count = shift;

                                                $self->send_getBlockedContactIdsByRange($start, $count);
                        return $self->recv_getBlockedContactIdsByRange();
}

sub send_getBlockedContactIdsByRange{
  my $self = shift;
  my $start = shift;
  my $count = shift;

                        $self->{output}->writeMessageBegin('getBlockedContactIdsByRange', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getBlockedContactIdsByRange_args();
                        $args->{start} = $start;
                        $args->{count} = $count;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getBlockedContactIdsByRange{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getBlockedContactIdsByRange_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getBlockedContactIdsByRange failed: unknown result";
}
sub getBlockedRecommendationIds{
  my $self = shift;

                                                $self->send_getBlockedRecommendationIds();
                        return $self->recv_getBlockedRecommendationIds();
}

sub send_getBlockedRecommendationIds{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getBlockedRecommendationIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getBlockedRecommendationIds_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getBlockedRecommendationIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getBlockedRecommendationIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getBlockedRecommendationIds failed: unknown result";
}
sub getBuddyBlockerIds{
  my $self = shift;

                                                $self->send_getBuddyBlockerIds();
                        return $self->recv_getBuddyBlockerIds();
}

sub send_getBuddyBlockerIds{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getBuddyBlockerIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getBuddyBlockerIds_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getBuddyBlockerIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getBuddyBlockerIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getBuddyBlockerIds failed: unknown result";
}
sub getBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;

                                                $self->send_getBuddyLocation($mid, $index);
                        return $self->recv_getBuddyLocation();
}

sub send_getBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;

                        $self->{output}->writeMessageBegin('getBuddyLocation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getBuddyLocation_args();
                        $args->{mid} = $mid;
                        $args->{index} = $index;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getBuddyLocation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getBuddyLocation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getBuddyLocation failed: unknown result";
}
sub getCompactContactsModifiedSince{
  my $self = shift;
  my $timestamp = shift;

                                                $self->send_getCompactContactsModifiedSince($timestamp);
                        return $self->recv_getCompactContactsModifiedSince();
}

sub send_getCompactContactsModifiedSince{
  my $self = shift;
  my $timestamp = shift;

                        $self->{output}->writeMessageBegin('getCompactContactsModifiedSince', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getCompactContactsModifiedSince_args();
                        $args->{timestamp} = $timestamp;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getCompactContactsModifiedSince{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getCompactContactsModifiedSince_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getCompactContactsModifiedSince failed: unknown result";
}
sub getCompactGroup{
  my $self = shift;
  my $groupId = shift;

                                                $self->send_getCompactGroup($groupId);
                        return $self->recv_getCompactGroup();
}

sub send_getCompactGroup{
  my $self = shift;
  my $groupId = shift;

                        $self->{output}->writeMessageBegin('getCompactGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getCompactGroup_args();
                        $args->{groupId} = $groupId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getCompactGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getCompactGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getCompactGroup failed: unknown result";
}
sub getCompactRoom{
  my $self = shift;
  my $roomId = shift;

                                                $self->send_getCompactRoom($roomId);
                        return $self->recv_getCompactRoom();
}

sub send_getCompactRoom{
  my $self = shift;
  my $roomId = shift;

                        $self->{output}->writeMessageBegin('getCompactRoom', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getCompactRoom_args();
                        $args->{roomId} = $roomId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getCompactRoom{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getCompactRoom_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getCompactRoom failed: unknown result";
}
sub getContact{
  my $self = shift;
  my $id = shift;

                                                $self->send_getContact($id);
                        return $self->recv_getContact();
}

sub send_getContact{
  my $self = shift;
  my $id = shift;

                        $self->{output}->writeMessageBegin('getContact', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getContact_args();
                        $args->{id} = $id;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getContact{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getContact_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getContact failed: unknown result";
}
sub getContacts{
  my $self = shift;
  my $ids = shift;

                                                $self->send_getContacts($ids);
                        return $self->recv_getContacts();
}

sub send_getContacts{
  my $self = shift;
  my $ids = shift;

                        $self->{output}->writeMessageBegin('getContacts', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getContacts_args();
                        $args->{ids} = $ids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getContacts{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getContacts_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getContacts failed: unknown result";
}
sub getContactWithFriendRequestStatus{
  my $self = shift;
  my $id = shift;

                                                $self->send_getContactWithFriendRequestStatus($id);
                        return $self->recv_getContactWithFriendRequestStatus();
}

sub send_getContactWithFriendRequestStatus{
  my $self = shift;
  my $id = shift;

                        $self->{output}->writeMessageBegin('getContactWithFriendRequestStatus', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getContactWithFriendRequestStatus_args();
                        $args->{id} = $id;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getContactWithFriendRequestStatus{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getContactWithFriendRequestStatus_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getContactWithFriendRequestStatus failed: unknown result";
}
sub getCountryWithRequestIp{
  my $self = shift;

                                                $self->send_getCountryWithRequestIp();
                        return $self->recv_getCountryWithRequestIp();
}

sub send_getCountryWithRequestIp{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getCountryWithRequestIp', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getCountryWithRequestIp_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getCountryWithRequestIp{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getCountryWithRequestIp_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getCountryWithRequestIp failed: unknown result";
}
sub getFavoriteMids{
  my $self = shift;

                                                $self->send_getFavoriteMids();
                        return $self->recv_getFavoriteMids();
}

sub send_getFavoriteMids{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getFavoriteMids', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getFavoriteMids_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getFavoriteMids{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getFavoriteMids_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getFavoriteMids failed: unknown result";
}
sub getGroup{
  my $self = shift;
  my $groupId = shift;

                                                $self->send_getGroup($groupId);
                        return $self->recv_getGroup();
}

sub send_getGroup{
  my $self = shift;
  my $groupId = shift;

                        $self->{output}->writeMessageBegin('getGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getGroup_args();
                        $args->{groupId} = $groupId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getGroup failed: unknown result";
}
sub getGroupIdsInvited{
  my $self = shift;

                                                $self->send_getGroupIdsInvited();
                        return $self->recv_getGroupIdsInvited();
}

sub send_getGroupIdsInvited{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getGroupIdsInvited', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getGroupIdsInvited_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getGroupIdsInvited{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getGroupIdsInvited_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getGroupIdsInvited failed: unknown result";
}
sub getGroupIdsJoined{
  my $self = shift;

                                                $self->send_getGroupIdsJoined();
                        return $self->recv_getGroupIdsJoined();
}

sub send_getGroupIdsJoined{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getGroupIdsJoined', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getGroupIdsJoined_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getGroupIdsJoined{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getGroupIdsJoined_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getGroupIdsJoined failed: unknown result";
}
sub getGroups{
  my $self = shift;
  my $groupIds = shift;

                                                $self->send_getGroups($groupIds);
                        return $self->recv_getGroups();
}

sub send_getGroups{
  my $self = shift;
  my $groupIds = shift;

                        $self->{output}->writeMessageBegin('getGroups', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getGroups_args();
                        $args->{groupIds} = $groupIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getGroups{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getGroups_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getGroups failed: unknown result";
}
sub getHiddenContactMids{
  my $self = shift;

                                                $self->send_getHiddenContactMids();
                        return $self->recv_getHiddenContactMids();
}

sub send_getHiddenContactMids{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getHiddenContactMids', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getHiddenContactMids_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getHiddenContactMids{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getHiddenContactMids_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getHiddenContactMids failed: unknown result";
}
sub getIdentityIdentifier{
  my $self = shift;

                                                $self->send_getIdentityIdentifier();
                        return $self->recv_getIdentityIdentifier();
}

sub send_getIdentityIdentifier{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getIdentityIdentifier', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getIdentityIdentifier_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getIdentityIdentifier{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getIdentityIdentifier_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getIdentityIdentifier failed: unknown result";
}
sub getLastAnnouncementIndex{
  my $self = shift;

                                                $self->send_getLastAnnouncementIndex();
                        return $self->recv_getLastAnnouncementIndex();
}

sub send_getLastAnnouncementIndex{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getLastAnnouncementIndex', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getLastAnnouncementIndex_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getLastAnnouncementIndex{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getLastAnnouncementIndex_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getLastAnnouncementIndex failed: unknown result";
}
sub getLastOpRevision{
  my $self = shift;

                                                $self->send_getLastOpRevision();
                        return $self->recv_getLastOpRevision();
}

sub send_getLastOpRevision{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getLastOpRevision', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getLastOpRevision_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getLastOpRevision{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getLastOpRevision_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getLastOpRevision failed: unknown result";
}
sub getSuggestRevisions{
  my $self = shift;

                                                $self->send_getSuggestRevisions();
                        return $self->recv_getSuggestRevisions();
}

sub send_getSuggestRevisions{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getSuggestRevisions', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getSuggestRevisions_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getSuggestRevisions{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getSuggestRevisions_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getSuggestRevisions failed: unknown result";
}
sub getPreviousMessagesV2WithReadCount{
  my $self = shift;
  my $messageBoxId = shift;
  my $endMessageId = shift;
  my $messagesCount = shift;

                                                $self->send_getPreviousMessagesV2WithReadCount($messageBoxId, $endMessageId, $messagesCount);
                        return $self->recv_getPreviousMessagesV2WithReadCount();
}

sub send_getPreviousMessagesV2WithReadCount{
  my $self = shift;
  my $messageBoxId = shift;
  my $endMessageId = shift;
  my $messagesCount = shift;

                        $self->{output}->writeMessageBegin('getPreviousMessagesV2WithReadCount', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getPreviousMessagesV2WithReadCount_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{endMessageId} = $endMessageId;
                        $args->{messagesCount} = $messagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getPreviousMessagesV2WithReadCount{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getPreviousMessagesV2WithReadCount_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getPreviousMessagesV2WithReadCount failed: unknown result";
}
sub getMessageBox{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;
  my $lastMessagesCount = shift;

                                                $self->send_getMessageBox($channelId, $messageBoxId, $lastMessagesCount);
                        return $self->recv_getMessageBox();
}

sub send_getMessageBox{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;
  my $lastMessagesCount = shift;

                        $self->{output}->writeMessageBegin('getMessageBox', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBox_args();
                        $args->{channelId} = $channelId;
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{lastMessagesCount} = $lastMessagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBox{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBox_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBox failed: unknown result";
}
sub getMessageBoxCompactWrapUp{
  my $self = shift;
  my $mid = shift;

                                                $self->send_getMessageBoxCompactWrapUp($mid);
                        return $self->recv_getMessageBoxCompactWrapUp();
}

sub send_getMessageBoxCompactWrapUp{
  my $self = shift;
  my $mid = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxCompactWrapUp', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxCompactWrapUp_args();
                        $args->{mid} = $mid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxCompactWrapUp{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxCompactWrapUp_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxCompactWrapUp failed: unknown result";
}
sub getMessageBoxCompactWrapUpList{
  my $self = shift;
  my $start = shift;
  my $messageBoxCount = shift;

                                                $self->send_getMessageBoxCompactWrapUpList($start, $messageBoxCount);
                        return $self->recv_getMessageBoxCompactWrapUpList();
}

sub send_getMessageBoxCompactWrapUpList{
  my $self = shift;
  my $start = shift;
  my $messageBoxCount = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxCompactWrapUpList', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxCompactWrapUpList_args();
                        $args->{start} = $start;
                        $args->{messageBoxCount} = $messageBoxCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxCompactWrapUpList{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxCompactWrapUpList_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxCompactWrapUpList failed: unknown result";
}
sub getMessageBoxList{
  my $self = shift;
  my $channelId = shift;
  my $lastMessagesCount = shift;

                                                $self->send_getMessageBoxList($channelId, $lastMessagesCount);
                        return $self->recv_getMessageBoxList();
}

sub send_getMessageBoxList{
  my $self = shift;
  my $channelId = shift;
  my $lastMessagesCount = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxList', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxList_args();
                        $args->{channelId} = $channelId;
                        $args->{lastMessagesCount} = $lastMessagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxList{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxList_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxList failed: unknown result";
}
sub getMessageBoxListByStatus{
  my $self = shift;
  my $channelId = shift;
  my $lastMessagesCount = shift;
  my $status = shift;

                                                $self->send_getMessageBoxListByStatus($channelId, $lastMessagesCount, $status);
                        return $self->recv_getMessageBoxListByStatus();
}

sub send_getMessageBoxListByStatus{
  my $self = shift;
  my $channelId = shift;
  my $lastMessagesCount = shift;
  my $status = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxListByStatus', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxListByStatus_args();
                        $args->{channelId} = $channelId;
                        $args->{lastMessagesCount} = $lastMessagesCount;
                        $args->{status} = $status;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxListByStatus{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxListByStatus_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxListByStatus failed: unknown result";
}
sub getMessageBoxWrapUp{
  my $self = shift;
  my $mid = shift;

                                                $self->send_getMessageBoxWrapUp($mid);
                        return $self->recv_getMessageBoxWrapUp();
}

sub send_getMessageBoxWrapUp{
  my $self = shift;
  my $mid = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxWrapUp', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxWrapUp_args();
                        $args->{mid} = $mid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxWrapUp{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxWrapUp_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxWrapUp failed: unknown result";
}
sub getMessageBoxWrapUpList{
  my $self = shift;
  my $start = shift;
  my $messageBoxCount = shift;

                                                $self->send_getMessageBoxWrapUpList($start, $messageBoxCount);
                        return $self->recv_getMessageBoxWrapUpList();
}

sub send_getMessageBoxWrapUpList{
  my $self = shift;
  my $start = shift;
  my $messageBoxCount = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxWrapUpList', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxWrapUpList_args();
                        $args->{start} = $start;
                        $args->{messageBoxCount} = $messageBoxCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxWrapUpList{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxWrapUpList_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxWrapUpList failed: unknown result";
}
sub getMessagesBySequenceNumber{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;
  my $startSeq = shift;
  my $endSeq = shift;

                                                $self->send_getMessagesBySequenceNumber($channelId, $messageBoxId, $startSeq, $endSeq);
                        return $self->recv_getMessagesBySequenceNumber();
}

sub send_getMessagesBySequenceNumber{
  my $self = shift;
  my $channelId = shift;
  my $messageBoxId = shift;
  my $startSeq = shift;
  my $endSeq = shift;

                        $self->{output}->writeMessageBegin('getMessagesBySequenceNumber', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessagesBySequenceNumber_args();
                        $args->{channelId} = $channelId;
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{startSeq} = $startSeq;
                        $args->{endSeq} = $endSeq;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessagesBySequenceNumber{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessagesBySequenceNumber_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessagesBySequenceNumber failed: unknown result";
}
sub getNextMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $startSeq = shift;
  my $messagesCount = shift;

                                                $self->send_getNextMessages($messageBoxId, $startSeq, $messagesCount);
                        return $self->recv_getNextMessages();
}

sub send_getNextMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $startSeq = shift;
  my $messagesCount = shift;

                        $self->{output}->writeMessageBegin('getNextMessages', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getNextMessages_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{startSeq} = $startSeq;
                        $args->{messagesCount} = $messagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getNextMessages{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getNextMessages_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getNextMessages failed: unknown result";
}
sub getNotificationPolicy{
  my $self = shift;
  my $carrier = shift;

                                                $self->send_getNotificationPolicy($carrier);
                        return $self->recv_getNotificationPolicy();
}

sub send_getNotificationPolicy{
  my $self = shift;
  my $carrier = shift;

                        $self->{output}->writeMessageBegin('getNotificationPolicy', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getNotificationPolicy_args();
                        $args->{carrier} = $carrier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getNotificationPolicy{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getNotificationPolicy_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getNotificationPolicy failed: unknown result";
}
sub getPreviousMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $endSeq = shift;
  my $messagesCount = shift;

                                                $self->send_getPreviousMessages($messageBoxId, $endSeq, $messagesCount);
                        return $self->recv_getPreviousMessages();
}

sub send_getPreviousMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $endSeq = shift;
  my $messagesCount = shift;

                        $self->{output}->writeMessageBegin('getPreviousMessages', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getPreviousMessages_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{endSeq} = $endSeq;
                        $args->{messagesCount} = $messagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getPreviousMessages{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getPreviousMessages_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getPreviousMessages failed: unknown result";
}
sub getProfile{
  my $self = shift;

                                                $self->send_getProfile();
                        return $self->recv_getProfile();
}

sub send_getProfile{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getProfile', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getProfile_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getProfile{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getProfile_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getProfile failed: unknown result";
}
sub getProximityMatchCandidateList{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_getProximityMatchCandidateList($sessionId);
                        return $self->recv_getProximityMatchCandidateList();
}

sub send_getProximityMatchCandidateList{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('getProximityMatchCandidateList', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getProximityMatchCandidateList_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getProximityMatchCandidateList{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getProximityMatchCandidateList_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getProximityMatchCandidateList failed: unknown result";
}
sub getProximityMatchCandidates{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_getProximityMatchCandidates($sessionId);
                        return $self->recv_getProximityMatchCandidates();
}

sub send_getProximityMatchCandidates{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('getProximityMatchCandidates', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getProximityMatchCandidates_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getProximityMatchCandidates{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getProximityMatchCandidates_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getProximityMatchCandidates failed: unknown result";
}
sub getRecentMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $messagesCount = shift;

                                                $self->send_getRecentMessages($messageBoxId, $messagesCount);
                        return $self->recv_getRecentMessages();
}

sub send_getRecentMessages{
  my $self = shift;
  my $messageBoxId = shift;
  my $messagesCount = shift;

                        $self->{output}->writeMessageBegin('getRecentMessages', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getRecentMessages_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{messagesCount} = $messagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getRecentMessages{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getRecentMessages_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getRecentMessages failed: unknown result";
}
sub getRecommendationIds{
  my $self = shift;

                                                $self->send_getRecommendationIds();
                        return $self->recv_getRecommendationIds();
}

sub send_getRecommendationIds{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getRecommendationIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getRecommendationIds_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getRecommendationIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getRecommendationIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getRecommendationIds failed: unknown result";
}
sub getRoom{
  my $self = shift;
  my $roomId = shift;

                                                $self->send_getRoom($roomId);
                        return $self->recv_getRoom();
}

sub send_getRoom{
  my $self = shift;
  my $roomId = shift;

                        $self->{output}->writeMessageBegin('getRoom', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getRoom_args();
                        $args->{roomId} = $roomId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getRoom{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getRoom_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getRoom failed: unknown result";
}
sub getRSAKeyInfo{
  my $self = shift;
  my $provider = shift;

                                                $self->send_getRSAKeyInfo($provider);
                        return $self->recv_getRSAKeyInfo();
}

sub send_getRSAKeyInfo{
  my $self = shift;
  my $provider = shift;

                        $self->{output}->writeMessageBegin('getRSAKeyInfo', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getRSAKeyInfo_args();
                        $args->{provider} = $provider;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getRSAKeyInfo{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getRSAKeyInfo_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getRSAKeyInfo failed: unknown result";
}
sub getServerTime{
  my $self = shift;

                                                $self->send_getServerTime();
                        return $self->recv_getServerTime();
}

sub send_getServerTime{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getServerTime', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getServerTime_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getServerTime{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getServerTime_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getServerTime failed: unknown result";
}
sub getSessions{
  my $self = shift;

                                                $self->send_getSessions();
                        return $self->recv_getSessions();
}

sub send_getSessions{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getSessions', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getSessions_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getSessions{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getSessions_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getSessions failed: unknown result";
}
sub getSettings{
  my $self = shift;

                                                $self->send_getSettings();
                        return $self->recv_getSettings();
}

sub send_getSettings{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getSettings', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getSettings_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getSettings{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getSettings_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getSettings failed: unknown result";
}
sub getGroupsV2{
  my $self = shift;
  my $groupIds = shift;

                                                $self->send_getGroupsV2($groupIds);
                        return $self->recv_getGroupsV2();
}

sub send_getGroupsV2{
  my $self = shift;
  my $groupIds = shift;

                        $self->{output}->writeMessageBegin('getGroupsV2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getGroupsV2_args();
                        $args->{groupIds} = $groupIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getGroupsV2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getGroupsV2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getGroupsV2 failed: unknown result";
}
sub getSettingsAttributes{
  my $self = shift;
  my $attrBitset = shift;

                                                $self->send_getSettingsAttributes($attrBitset);
                        return $self->recv_getSettingsAttributes();
}

sub send_getSettingsAttributes{
  my $self = shift;
  my $attrBitset = shift;

                        $self->{output}->writeMessageBegin('getSettingsAttributes', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getSettingsAttributes_args();
                        $args->{attrBitset} = $attrBitset;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getSettingsAttributes{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getSettingsAttributes_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getSettingsAttributes failed: unknown result";
}
sub getSystemConfiguration{
  my $self = shift;

                                                $self->send_getSystemConfiguration();
                        return $self->recv_getSystemConfiguration();
}

sub send_getSystemConfiguration{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getSystemConfiguration', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getSystemConfiguration_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getSystemConfiguration{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getSystemConfiguration_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getSystemConfiguration failed: unknown result";
}
sub getUserTicket{
  my $self = shift;

                                                $self->send_getUserTicket();
                        return $self->recv_getUserTicket();
}

sub send_getUserTicket{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getUserTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getUserTicket_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getUserTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getUserTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getUserTicket failed: unknown result";
}
sub getWapInvitation{
  my $self = shift;
  my $invitationHash = shift;

                                                $self->send_getWapInvitation($invitationHash);
                        return $self->recv_getWapInvitation();
}

sub send_getWapInvitation{
  my $self = shift;
  my $invitationHash = shift;

                        $self->{output}->writeMessageBegin('getWapInvitation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getWapInvitation_args();
                        $args->{invitationHash} = $invitationHash;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getWapInvitation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getWapInvitation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getWapInvitation failed: unknown result";
}
sub invalidateUserTicket{
  my $self = shift;

                                                $self->send_invalidateUserTicket();
                        $self->recv_invalidateUserTicket();
}

sub send_invalidateUserTicket{
  my $self = shift;

                        $self->{output}->writeMessageBegin('invalidateUserTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_invalidateUserTicket_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_invalidateUserTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_invalidateUserTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub inviteFriendsBySms{
  my $self = shift;
  my $phoneNumberList = shift;

                                                $self->send_inviteFriendsBySms($phoneNumberList);
                        $self->recv_inviteFriendsBySms();
}

sub send_inviteFriendsBySms{
  my $self = shift;
  my $phoneNumberList = shift;

                        $self->{output}->writeMessageBegin('inviteFriendsBySms', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_inviteFriendsBySms_args();
                        $args->{phoneNumberList} = $phoneNumberList;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_inviteFriendsBySms{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_inviteFriendsBySms_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub inviteIntoGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

                                                $self->send_inviteIntoGroup($reqSeq, $groupId, $contactIds);
                        $self->recv_inviteIntoGroup();
}

sub send_inviteIntoGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('inviteIntoGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_inviteIntoGroup_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupId} = $groupId;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_inviteIntoGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_inviteIntoGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub inviteIntoRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $roomId = shift;
  my $contactIds = shift;

                                                $self->send_inviteIntoRoom($reqSeq, $roomId, $contactIds);
                        $self->recv_inviteIntoRoom();
}

sub send_inviteIntoRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $roomId = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('inviteIntoRoom', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_inviteIntoRoom_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{roomId} = $roomId;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_inviteIntoRoom{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_inviteIntoRoom_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub inviteViaEmail{
  my $self = shift;
  my $reqSeq = shift;
  my $email = shift;
  my $name = shift;

                                                $self->send_inviteViaEmail($reqSeq, $email, $name);
                        $self->recv_inviteViaEmail();
}

sub send_inviteViaEmail{
  my $self = shift;
  my $reqSeq = shift;
  my $email = shift;
  my $name = shift;

                        $self->{output}->writeMessageBegin('inviteViaEmail', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_inviteViaEmail_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{email} = $email;
                        $args->{name} = $name;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_inviteViaEmail{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_inviteViaEmail_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub isIdentityIdentifierAvailable{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;

                                                $self->send_isIdentityIdentifierAvailable($provider, $identifier);
                        return $self->recv_isIdentityIdentifierAvailable();
}

sub send_isIdentityIdentifierAvailable{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;

                        $self->{output}->writeMessageBegin('isIdentityIdentifierAvailable', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_isIdentityIdentifierAvailable_args();
                        $args->{provider} = $provider;
                        $args->{identifier} = $identifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_isIdentityIdentifierAvailable{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_isIdentityIdentifierAvailable_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "isIdentityIdentifierAvailable failed: unknown result";
}
sub isUseridAvailable{
  my $self = shift;
  my $userid = shift;

                                                $self->send_isUseridAvailable($userid);
                        return $self->recv_isUseridAvailable();
}

sub send_isUseridAvailable{
  my $self = shift;
  my $userid = shift;

                        $self->{output}->writeMessageBegin('isUseridAvailable', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_isUseridAvailable_args();
                        $args->{userid} = $userid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_isUseridAvailable{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_isUseridAvailable_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "isUseridAvailable failed: unknown result";
}
sub kickoutFromGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

                                                $self->send_kickoutFromGroup($reqSeq, $groupId, $contactIds);
                        $self->recv_kickoutFromGroup();
}

sub send_kickoutFromGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('kickoutFromGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_kickoutFromGroup_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupId} = $groupId;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_kickoutFromGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_kickoutFromGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub reissueGroupTicket{
  my $self = shift;
  my $groupMid = shift;

                                                $self->send_reissueGroupTicket($groupMid);
                        return $self->recv_reissueGroupTicket();
}

sub send_reissueGroupTicket{
  my $self = shift;
  my $groupMid = shift;

                        $self->{output}->writeMessageBegin('reissueGroupTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reissueGroupTicket_args();
                        $args->{groupMid} = $groupMid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reissueGroupTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reissueGroupTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "reissueGroupTicket failed: unknown result";
}
sub findGroupByTicket{
  my $self = shift;
  my $ticketId = shift;

                                                $self->send_findGroupByTicket($ticketId);
                        return $self->recv_findGroupByTicket();
}

sub send_findGroupByTicket{
  my $self = shift;
  my $ticketId = shift;

                        $self->{output}->writeMessageBegin('findGroupByTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findGroupByTicket_args();
                        $args->{ticketId} = $ticketId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findGroupByTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findGroupByTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findGroupByTicket failed: unknown result";
}
sub leaveGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

                                                $self->send_leaveGroup($reqSeq, $groupId);
                        $self->recv_leaveGroup();
}

sub send_leaveGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

                        $self->{output}->writeMessageBegin('leaveGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_leaveGroup_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupId} = $groupId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_leaveGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_leaveGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub leaveRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $roomId = shift;

                                                $self->send_leaveRoom($reqSeq, $roomId);
                        $self->recv_leaveRoom();
}

sub send_leaveRoom{
  my $self = shift;
  my $reqSeq = shift;
  my $roomId = shift;

                        $self->{output}->writeMessageBegin('leaveRoom', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_leaveRoom_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{roomId} = $roomId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_leaveRoom{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_leaveRoom_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub loginWithIdentityCredential{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;
  my $keepLoggedIn = shift;
  my $accessLocation = shift;
  my $systemName = shift;
  my $certificate = shift;

                                                $self->send_loginWithIdentityCredential($identityProvider, $identifier, $password, $keepLoggedIn, $accessLocation, $systemName, $certificate);
                        return $self->recv_loginWithIdentityCredential();
}

sub send_loginWithIdentityCredential{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;
  my $keepLoggedIn = shift;
  my $accessLocation = shift;
  my $systemName = shift;
  my $certificate = shift;

                        $self->{output}->writeMessageBegin('loginWithIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_loginWithIdentityCredential_args();
                        $args->{identityProvider} = $identityProvider;
                        $args->{identifier} = $identifier;
                        $args->{password} = $password;
                        $args->{keepLoggedIn} = $keepLoggedIn;
                        $args->{accessLocation} = $accessLocation;
                        $args->{systemName} = $systemName;
                        $args->{certificate} = $certificate;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_loginWithIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_loginWithIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "loginWithIdentityCredential failed: unknown result";
}
sub loginWithIdentityCredentialForCertificate{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;
  my $keepLoggedIn = shift;
  my $accessLocation = shift;
  my $systemName = shift;
  my $certificate = shift;

                                                $self->send_loginWithIdentityCredentialForCertificate($identityProvider, $identifier, $password, $keepLoggedIn, $accessLocation, $systemName, $certificate);
                        return $self->recv_loginWithIdentityCredentialForCertificate();
}

sub send_loginWithIdentityCredentialForCertificate{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;
  my $keepLoggedIn = shift;
  my $accessLocation = shift;
  my $systemName = shift;
  my $certificate = shift;

                        $self->{output}->writeMessageBegin('loginWithIdentityCredentialForCertificate', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_loginWithIdentityCredentialForCertificate_args();
                        $args->{identityProvider} = $identityProvider;
                        $args->{identifier} = $identifier;
                        $args->{password} = $password;
                        $args->{keepLoggedIn} = $keepLoggedIn;
                        $args->{accessLocation} = $accessLocation;
                        $args->{systemName} = $systemName;
                        $args->{certificate} = $certificate;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_loginWithIdentityCredentialForCertificate{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_loginWithIdentityCredentialForCertificate_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "loginWithIdentityCredentialForCertificate failed: unknown result";
}
sub loginWithVerifier{
  my $self = shift;
  my $verifier = shift;

                                                $self->send_loginWithVerifier($verifier);
                        return $self->recv_loginWithVerifier();
}

sub send_loginWithVerifier{
  my $self = shift;
  my $verifier = shift;

                        $self->{output}->writeMessageBegin('loginWithVerifier', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_loginWithVerifier_args();
                        $args->{verifier} = $verifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_loginWithVerifier{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_loginWithVerifier_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "loginWithVerifier failed: unknown result";
}
sub loginWithVerifierForCerificate{
  my $self = shift;
  my $verifier = shift;

                                                $self->send_loginWithVerifierForCerificate($verifier);
                        return $self->recv_loginWithVerifierForCerificate();
}

sub send_loginWithVerifierForCerificate{
  my $self = shift;
  my $verifier = shift;

                        $self->{output}->writeMessageBegin('loginWithVerifierForCerificate', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_loginWithVerifierForCerificate_args();
                        $args->{verifier} = $verifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_loginWithVerifierForCerificate{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_loginWithVerifierForCerificate_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "loginWithVerifierForCerificate failed: unknown result";
}
sub loginWithVerifierForCertificate{
  my $self = shift;
  my $verifier = shift;

                                                $self->send_loginWithVerifierForCertificate($verifier);
                        return $self->recv_loginWithVerifierForCertificate();
}

sub send_loginWithVerifierForCertificate{
  my $self = shift;
  my $verifier = shift;

                        $self->{output}->writeMessageBegin('loginWithVerifierForCertificate', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_loginWithVerifierForCertificate_args();
                        $args->{verifier} = $verifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_loginWithVerifierForCertificate{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_loginWithVerifierForCertificate_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "loginWithVerifierForCertificate failed: unknown result";
}
sub logout{
  my $self = shift;

                                                $self->send_logout();
                        $self->recv_logout();
}

sub send_logout{
  my $self = shift;

                        $self->{output}->writeMessageBegin('logout', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_logout_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_logout{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_logout_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub logoutSession{
  my $self = shift;
  my $tokenKey = shift;

                                                $self->send_logoutSession($tokenKey);
                        $self->recv_logoutSession();
}

sub send_logoutSession{
  my $self = shift;
  my $tokenKey = shift;

                        $self->{output}->writeMessageBegin('logoutSession', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_logoutSession_args();
                        $args->{tokenKey} = $tokenKey;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_logoutSession{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_logoutSession_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub noop{
  my $self = shift;

                                                $self->send_noop();
                        $self->recv_noop();
}

sub send_noop{
  my $self = shift;

                        $self->{output}->writeMessageBegin('noop', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_noop_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_noop{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_noop_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub notifiedRedirect{
  my $self = shift;
  my $paramMap = shift;

                                                $self->send_notifiedRedirect($paramMap);
                        $self->recv_notifiedRedirect();
}

sub send_notifiedRedirect{
  my $self = shift;
  my $paramMap = shift;

                        $self->{output}->writeMessageBegin('notifiedRedirect', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifiedRedirect_args();
                        $args->{paramMap} = $paramMap;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifiedRedirect{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifiedRedirect_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub notifyBuddyOnAir{
  my $self = shift;
  my $seq = shift;
  my $receiverMids = shift;

                                                $self->send_notifyBuddyOnAir($seq, $receiverMids);
                        return $self->recv_notifyBuddyOnAir();
}

sub send_notifyBuddyOnAir{
  my $self = shift;
  my $seq = shift;
  my $receiverMids = shift;

                        $self->{output}->writeMessageBegin('notifyBuddyOnAir', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifyBuddyOnAir_args();
                        $args->{seq} = $seq;
                        $args->{receiverMids} = $receiverMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifyBuddyOnAir{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifyBuddyOnAir_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "notifyBuddyOnAir failed: unknown result";
}
sub notifyIndividualEvent{
  my $self = shift;
  my $notificationStatus = shift;
  my $receiverMids = shift;

                                                $self->send_notifyIndividualEvent($notificationStatus, $receiverMids);
                        $self->recv_notifyIndividualEvent();
}

sub send_notifyIndividualEvent{
  my $self = shift;
  my $notificationStatus = shift;
  my $receiverMids = shift;

                        $self->{output}->writeMessageBegin('notifyIndividualEvent', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifyIndividualEvent_args();
                        $args->{notificationStatus} = $notificationStatus;
                        $args->{receiverMids} = $receiverMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifyIndividualEvent{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifyIndividualEvent_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub notifyInstalled{
  my $self = shift;
  my $udidHash = shift;
  my $applicationTypeWithExtensions = shift;

                                                $self->send_notifyInstalled($udidHash, $applicationTypeWithExtensions);
                        $self->recv_notifyInstalled();
}

sub send_notifyInstalled{
  my $self = shift;
  my $udidHash = shift;
  my $applicationTypeWithExtensions = shift;

                        $self->{output}->writeMessageBegin('notifyInstalled', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifyInstalled_args();
                        $args->{udidHash} = $udidHash;
                        $args->{applicationTypeWithExtensions} = $applicationTypeWithExtensions;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifyInstalled{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifyInstalled_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub notifyRegistrationComplete{
  my $self = shift;
  my $udidHash = shift;
  my $applicationTypeWithExtensions = shift;

                                                $self->send_notifyRegistrationComplete($udidHash, $applicationTypeWithExtensions);
                        $self->recv_notifyRegistrationComplete();
}

sub send_notifyRegistrationComplete{
  my $self = shift;
  my $udidHash = shift;
  my $applicationTypeWithExtensions = shift;

                        $self->{output}->writeMessageBegin('notifyRegistrationComplete', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifyRegistrationComplete_args();
                        $args->{udidHash} = $udidHash;
                        $args->{applicationTypeWithExtensions} = $applicationTypeWithExtensions;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifyRegistrationComplete{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifyRegistrationComplete_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub notifySleep{
  my $self = shift;
  my $lastRev = shift;
  my $badge = shift;

                                                $self->send_notifySleep($lastRev, $badge);
                        $self->recv_notifySleep();
}

sub send_notifySleep{
  my $self = shift;
  my $lastRev = shift;
  my $badge = shift;

                        $self->{output}->writeMessageBegin('notifySleep', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifySleep_args();
                        $args->{lastRev} = $lastRev;
                        $args->{badge} = $badge;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifySleep{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifySleep_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub notifyUpdated{
  my $self = shift;
  my $lastRev = shift;
  my $deviceInfo = shift;

                                                $self->send_notifyUpdated($lastRev, $deviceInfo);
                        $self->recv_notifyUpdated();
}

sub send_notifyUpdated{
  my $self = shift;
  my $lastRev = shift;
  my $deviceInfo = shift;

                        $self->{output}->writeMessageBegin('notifyUpdated', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_notifyUpdated_args();
                        $args->{lastRev} = $lastRev;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_notifyUpdated{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_notifyUpdated_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub openProximityMatch{
  my $self = shift;
  my $location = shift;

                                                $self->send_openProximityMatch($location);
                        return $self->recv_openProximityMatch();
}

sub send_openProximityMatch{
  my $self = shift;
  my $location = shift;

                        $self->{output}->writeMessageBegin('openProximityMatch', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_openProximityMatch_args();
                        $args->{location} = $location;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_openProximityMatch{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_openProximityMatch_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "openProximityMatch failed: unknown result";
}
sub registerBuddyUser{
  my $self = shift;
  my $buddyId = shift;
  my $registrarPassword = shift;

                                                $self->send_registerBuddyUser($buddyId, $registrarPassword);
                        return $self->recv_registerBuddyUser();
}

sub send_registerBuddyUser{
  my $self = shift;
  my $buddyId = shift;
  my $registrarPassword = shift;

                        $self->{output}->writeMessageBegin('registerBuddyUser', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerBuddyUser_args();
                        $args->{buddyId} = $buddyId;
                        $args->{registrarPassword} = $registrarPassword;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerBuddyUser{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerBuddyUser_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerBuddyUser failed: unknown result";
}
sub registerBuddyUserid{
  my $self = shift;
  my $seq = shift;
  my $userid = shift;

                                                $self->send_registerBuddyUserid($seq, $userid);
                        $self->recv_registerBuddyUserid();
}

sub send_registerBuddyUserid{
  my $self = shift;
  my $seq = shift;
  my $userid = shift;

                        $self->{output}->writeMessageBegin('registerBuddyUserid', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerBuddyUserid_args();
                        $args->{seq} = $seq;
                        $args->{userid} = $userid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerBuddyUserid{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerBuddyUserid_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub registerDevice{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_registerDevice($sessionId);
                        return $self->recv_registerDevice();
}

sub send_registerDevice{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('registerDevice', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerDevice_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerDevice{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerDevice_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerDevice failed: unknown result";
}
sub registerDeviceWithIdentityCredential{
  my $self = shift;
  my $sessionId = shift;
  my $provider = shift;
  my $identifier = shift;
  my $verifier = shift;

                                                $self->send_registerDeviceWithIdentityCredential($sessionId, $provider, $identifier, $verifier);
                        return $self->recv_registerDeviceWithIdentityCredential();
}

sub send_registerDeviceWithIdentityCredential{
  my $self = shift;
  my $sessionId = shift;
  my $provider = shift;
  my $identifier = shift;
  my $verifier = shift;

                        $self->{output}->writeMessageBegin('registerDeviceWithIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerDeviceWithIdentityCredential_args();
                        $args->{sessionId} = $sessionId;
                        $args->{provider} = $provider;
                        $args->{identifier} = $identifier;
                        $args->{verifier} = $verifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerDeviceWithIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerDeviceWithIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerDeviceWithIdentityCredential failed: unknown result";
}
sub registerDeviceWithoutPhoneNumber{
  my $self = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

                                                $self->send_registerDeviceWithoutPhoneNumber($region, $udidHash, $deviceInfo);
                        return $self->recv_registerDeviceWithoutPhoneNumber();
}

sub send_registerDeviceWithoutPhoneNumber{
  my $self = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

                        $self->{output}->writeMessageBegin('registerDeviceWithoutPhoneNumber', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerDeviceWithoutPhoneNumber_args();
                        $args->{region} = $region;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerDeviceWithoutPhoneNumber{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerDeviceWithoutPhoneNumber_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerDeviceWithoutPhoneNumber failed: unknown result";
}
sub registerDeviceWithoutPhoneNumberWithIdentityCredential{
  my $self = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $provider = shift;
  my $identifier = shift;
  my $verifier = shift;
  my $mid = shift;
  my $migrationPincodeSessionId = shift;

                                                $self->send_registerDeviceWithoutPhoneNumberWithIdentityCredential($region, $udidHash, $deviceInfo, $provider, $identifier, $verifier, $mid, $migrationPincodeSessionId);
                        return $self->recv_registerDeviceWithoutPhoneNumberWithIdentityCredential();
}

sub send_registerDeviceWithoutPhoneNumberWithIdentityCredential{
  my $self = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $provider = shift;
  my $identifier = shift;
  my $verifier = shift;
  my $mid = shift;
  my $migrationPincodeSessionId = shift;

                        $self->{output}->writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args();
                        $args->{region} = $region;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->{provider} = $provider;
                        $args->{identifier} = $identifier;
                        $args->{verifier} = $verifier;
                        $args->{mid} = $mid;
                        $args->{migrationPincodeSessionId} = $migrationPincodeSessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerDeviceWithoutPhoneNumberWithIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerDeviceWithoutPhoneNumberWithIdentityCredential failed: unknown result";
}
sub registerUserid{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;

                                                $self->send_registerUserid($reqSeq, $userid);
                        return $self->recv_registerUserid();
}

sub send_registerUserid{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;

                        $self->{output}->writeMessageBegin('registerUserid', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerUserid_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{userid} = $userid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerUserid{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerUserid_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerUserid failed: unknown result";
}
sub registerWapDevice{
  my $self = shift;
  my $invitationHash = shift;
  my $guidHash = shift;
  my $email = shift;
  my $deviceInfo = shift;

                                                $self->send_registerWapDevice($invitationHash, $guidHash, $email, $deviceInfo);
                        return $self->recv_registerWapDevice();
}

sub send_registerWapDevice{
  my $self = shift;
  my $invitationHash = shift;
  my $guidHash = shift;
  my $email = shift;
  my $deviceInfo = shift;

                        $self->{output}->writeMessageBegin('registerWapDevice', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerWapDevice_args();
                        $args->{invitationHash} = $invitationHash;
                        $args->{guidHash} = $guidHash;
                        $args->{email} = $email;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerWapDevice{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerWapDevice_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerWapDevice failed: unknown result";
}
sub registerWithExistingSnsIdAndIdentityCredential{
  my $self = shift;
  my $identityCredential = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

                                                $self->send_registerWithExistingSnsIdAndIdentityCredential($identityCredential, $region, $udidHash, $deviceInfo);
                        return $self->recv_registerWithExistingSnsIdAndIdentityCredential();
}

sub send_registerWithExistingSnsIdAndIdentityCredential{
  my $self = shift;
  my $identityCredential = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

                        $self->{output}->writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerWithExistingSnsIdAndIdentityCredential_args();
                        $args->{identityCredential} = $identityCredential;
                        $args->{region} = $region;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerWithExistingSnsIdAndIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerWithExistingSnsIdAndIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerWithExistingSnsIdAndIdentityCredential failed: unknown result";
}
sub registerWithSnsId{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $mid = shift;

                                                $self->send_registerWithSnsId($snsIdType, $snsAccessToken, $region, $udidHash, $deviceInfo, $mid);
                        return $self->recv_registerWithSnsId();
}

sub send_registerWithSnsId{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $mid = shift;

                        $self->{output}->writeMessageBegin('registerWithSnsId', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerWithSnsId_args();
                        $args->{snsIdType} = $snsIdType;
                        $args->{snsAccessToken} = $snsAccessToken;
                        $args->{region} = $region;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->{mid} = $mid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerWithSnsId{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerWithSnsId_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerWithSnsId failed: unknown result";
}
sub registerWithSnsIdAndIdentityCredential{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $identityCredential = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

                                                $self->send_registerWithSnsIdAndIdentityCredential($snsIdType, $snsAccessToken, $identityCredential, $region, $udidHash, $deviceInfo);
                        return $self->recv_registerWithSnsIdAndIdentityCredential();
}

sub send_registerWithSnsIdAndIdentityCredential{
  my $self = shift;
  my $snsIdType = shift;
  my $snsAccessToken = shift;
  my $identityCredential = shift;
  my $region = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;

                        $self->{output}->writeMessageBegin('registerWithSnsIdAndIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerWithSnsIdAndIdentityCredential_args();
                        $args->{snsIdType} = $snsIdType;
                        $args->{snsAccessToken} = $snsAccessToken;
                        $args->{identityCredential} = $identityCredential;
                        $args->{region} = $region;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerWithSnsIdAndIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerWithSnsIdAndIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerWithSnsIdAndIdentityCredential failed: unknown result";
}
sub reissueDeviceCredential{
  my $self = shift;

                                                $self->send_reissueDeviceCredential();
                        return $self->recv_reissueDeviceCredential();
}

sub send_reissueDeviceCredential{
  my $self = shift;

                        $self->{output}->writeMessageBegin('reissueDeviceCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reissueDeviceCredential_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reissueDeviceCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reissueDeviceCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "reissueDeviceCredential failed: unknown result";
}
sub reissueUserTicket{
  my $self = shift;
  my $expirationTime = shift;
  my $maxUseCount = shift;

                                                $self->send_reissueUserTicket($expirationTime, $maxUseCount);
                        return $self->recv_reissueUserTicket();
}

sub send_reissueUserTicket{
  my $self = shift;
  my $expirationTime = shift;
  my $maxUseCount = shift;

                        $self->{output}->writeMessageBegin('reissueUserTicket', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reissueUserTicket_args();
                        $args->{expirationTime} = $expirationTime;
                        $args->{maxUseCount} = $maxUseCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reissueUserTicket{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reissueUserTicket_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "reissueUserTicket failed: unknown result";
}
sub getMessageReadRange{
  my $self = shift;
  my $chatIds = shift;

                                                $self->send_getMessageReadRange($chatIds);
                        return $self->recv_getMessageReadRange();
}

sub send_getMessageReadRange{
  my $self = shift;
  my $chatIds = shift;

                        $self->{output}->writeMessageBegin('getMessageReadRange', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageReadRange_args();
                        $args->{chatIds} = $chatIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageReadRange{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageReadRange_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageReadRange failed: unknown result";
}
sub rejectGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

                                                $self->send_rejectGroupInvitation($reqSeq, $groupId);
                        $self->recv_rejectGroupInvitation();
}

sub send_rejectGroupInvitation{
  my $self = shift;
  my $reqSeq = shift;
  my $groupId = shift;

                        $self->{output}->writeMessageBegin('rejectGroupInvitation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_rejectGroupInvitation_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupId} = $groupId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_rejectGroupInvitation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_rejectGroupInvitation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub releaseSession{
  my $self = shift;

                                                $self->send_releaseSession();
                        $self->recv_releaseSession();
}

sub send_releaseSession{
  my $self = shift;

                        $self->{output}->writeMessageBegin('releaseSession', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_releaseSession_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_releaseSession{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_releaseSession_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub removeAllMessages{
  my $self = shift;
  my $seq = shift;
  my $lastMessageId = shift;

                                                $self->send_removeAllMessages($seq, $lastMessageId);
                        $self->recv_removeAllMessages();
}

sub send_removeAllMessages{
  my $self = shift;
  my $seq = shift;
  my $lastMessageId = shift;

                        $self->{output}->writeMessageBegin('removeAllMessages', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeAllMessages_args();
                        $args->{seq} = $seq;
                        $args->{lastMessageId} = $lastMessageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeAllMessages{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeAllMessages_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub removeBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;

                                                $self->send_removeBuddyLocation($mid, $index);
                        $self->recv_removeBuddyLocation();
}

sub send_removeBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;

                        $self->{output}->writeMessageBegin('removeBuddyLocation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeBuddyLocation_args();
                        $args->{mid} = $mid;
                        $args->{index} = $index;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeBuddyLocation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeBuddyLocation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub removeMessage{
  my $self = shift;
  my $messageId = shift;

                                                $self->send_removeMessage($messageId);
                        return $self->recv_removeMessage();
}

sub send_removeMessage{
  my $self = shift;
  my $messageId = shift;

                        $self->{output}->writeMessageBegin('removeMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeMessage_args();
                        $args->{messageId} = $messageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "removeMessage failed: unknown result";
}
sub makeUserAddMyselfAsContact{
  my $self = shift;
  my $contactOwnerMid = shift;

                                                $self->send_makeUserAddMyselfAsContact($contactOwnerMid);
                        return $self->recv_makeUserAddMyselfAsContact();
}

sub send_makeUserAddMyselfAsContact{
  my $self = shift;
  my $contactOwnerMid = shift;

                        $self->{output}->writeMessageBegin('makeUserAddMyselfAsContact', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_makeUserAddMyselfAsContact_args();
                        $args->{contactOwnerMid} = $contactOwnerMid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_makeUserAddMyselfAsContact{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_makeUserAddMyselfAsContact_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "makeUserAddMyselfAsContact failed: unknown result";
}
sub removeMessageFromMyHome{
  my $self = shift;
  my $messageId = shift;

                                                $self->send_removeMessageFromMyHome($messageId);
                        return $self->recv_removeMessageFromMyHome();
}

sub send_removeMessageFromMyHome{
  my $self = shift;
  my $messageId = shift;

                        $self->{output}->writeMessageBegin('removeMessageFromMyHome', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeMessageFromMyHome_args();
                        $args->{messageId} = $messageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeMessageFromMyHome{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeMessageFromMyHome_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "removeMessageFromMyHome failed: unknown result";
}
sub removeSnsId{
  my $self = shift;
  my $snsIdType = shift;

                                                $self->send_removeSnsId($snsIdType);
                        return $self->recv_removeSnsId();
}

sub send_removeSnsId{
  my $self = shift;
  my $snsIdType = shift;

                        $self->{output}->writeMessageBegin('removeSnsId', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeSnsId_args();
                        $args->{snsIdType} = $snsIdType;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeSnsId{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeSnsId_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "removeSnsId failed: unknown result";
}
sub report{
  my $self = shift;
  my $syncOpRevision = shift;
  my $category = shift;
  my $report = shift;

                                                $self->send_report($syncOpRevision, $category, $report);
                        $self->recv_report();
}

sub send_report{
  my $self = shift;
  my $syncOpRevision = shift;
  my $category = shift;
  my $report = shift;

                        $self->{output}->writeMessageBegin('report', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_report_args();
                        $args->{syncOpRevision} = $syncOpRevision;
                        $args->{category} = $category;
                        $args->{report} = $report;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_report{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_report_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub reportContacts{
  my $self = shift;
  my $syncOpRevision = shift;
  my $category = shift;
  my $contactReports = shift;
  my $actionType = shift;

                                                $self->send_reportContacts($syncOpRevision, $category, $contactReports, $actionType);
                        return $self->recv_reportContacts();
}

sub send_reportContacts{
  my $self = shift;
  my $syncOpRevision = shift;
  my $category = shift;
  my $contactReports = shift;
  my $actionType = shift;

                        $self->{output}->writeMessageBegin('reportContacts', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportContacts_args();
                        $args->{syncOpRevision} = $syncOpRevision;
                        $args->{category} = $category;
                        $args->{contactReports} = $contactReports;
                        $args->{actionType} = $actionType;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportContacts{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportContacts_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "reportContacts failed: unknown result";
}
sub reportGroups{
  my $self = shift;
  my $syncOpRevision = shift;
  my $groups = shift;

                                                $self->send_reportGroups($syncOpRevision, $groups);
                        $self->recv_reportGroups();
}

sub send_reportGroups{
  my $self = shift;
  my $syncOpRevision = shift;
  my $groups = shift;

                        $self->{output}->writeMessageBegin('reportGroups', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportGroups_args();
                        $args->{syncOpRevision} = $syncOpRevision;
                        $args->{groups} = $groups;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportGroups{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportGroups_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub reportProfile{
  my $self = shift;
  my $syncOpRevision = shift;
  my $profile = shift;

                                                $self->send_reportProfile($syncOpRevision, $profile);
                        $self->recv_reportProfile();
}

sub send_reportProfile{
  my $self = shift;
  my $syncOpRevision = shift;
  my $profile = shift;

                        $self->{output}->writeMessageBegin('reportProfile', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportProfile_args();
                        $args->{syncOpRevision} = $syncOpRevision;
                        $args->{profile} = $profile;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportProfile{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportProfile_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub reportRooms{
  my $self = shift;
  my $syncOpRevision = shift;
  my $rooms = shift;

                                                $self->send_reportRooms($syncOpRevision, $rooms);
                        $self->recv_reportRooms();
}

sub send_reportRooms{
  my $self = shift;
  my $syncOpRevision = shift;
  my $rooms = shift;

                        $self->{output}->writeMessageBegin('reportRooms', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportRooms_args();
                        $args->{syncOpRevision} = $syncOpRevision;
                        $args->{rooms} = $rooms;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportRooms{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportRooms_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub findAndAddContactByMetaTag{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;
  my $reference = shift;

                                                $self->send_findAndAddContactByMetaTag($reqSeq, $userid, $reference);
                        return $self->recv_findAndAddContactByMetaTag();
}

sub send_findAndAddContactByMetaTag{
  my $self = shift;
  my $reqSeq = shift;
  my $userid = shift;
  my $reference = shift;

                        $self->{output}->writeMessageBegin('findAndAddContactByMetaTag', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findAndAddContactByMetaTag_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{userid} = $userid;
                        $args->{reference} = $reference;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findAndAddContactByMetaTag{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findAndAddContactByMetaTag_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findAndAddContactByMetaTag failed: unknown result";
}
sub reportSettings{
  my $self = shift;
  my $syncOpRevision = shift;
  my $settings = shift;

                                                $self->send_reportSettings($syncOpRevision, $settings);
                        $self->recv_reportSettings();
}

sub send_reportSettings{
  my $self = shift;
  my $syncOpRevision = shift;
  my $settings = shift;

                        $self->{output}->writeMessageBegin('reportSettings', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportSettings_args();
                        $args->{syncOpRevision} = $syncOpRevision;
                        $args->{settings} = $settings;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportSettings{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportSettings_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub reportSpam{
  my $self = shift;
  my $chatMid = shift;
  my $memberMids = shift;
  my $spammerReasons = shift;
  my $senderMids = shift;
  my $spamMessageIds = shift;
  my $spamMessages = shift;

                                                $self->send_reportSpam($chatMid, $memberMids, $spammerReasons, $senderMids, $spamMessageIds, $spamMessages);
                        $self->recv_reportSpam();
}

sub send_reportSpam{
  my $self = shift;
  my $chatMid = shift;
  my $memberMids = shift;
  my $spammerReasons = shift;
  my $senderMids = shift;
  my $spamMessageIds = shift;
  my $spamMessages = shift;

                        $self->{output}->writeMessageBegin('reportSpam', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportSpam_args();
                        $args->{chatMid} = $chatMid;
                        $args->{memberMids} = $memberMids;
                        $args->{spammerReasons} = $spammerReasons;
                        $args->{senderMids} = $senderMids;
                        $args->{spamMessageIds} = $spamMessageIds;
                        $args->{spamMessages} = $spamMessages;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportSpam{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportSpam_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub reportSpammer{
  my $self = shift;
  my $spammerMid = shift;
  my $spammerReasons = shift;
  my $spamMessageIds = shift;

                                                $self->send_reportSpammer($spammerMid, $spammerReasons, $spamMessageIds);
                        $self->recv_reportSpammer();
}

sub send_reportSpammer{
  my $self = shift;
  my $spammerMid = shift;
  my $spammerReasons = shift;
  my $spamMessageIds = shift;

                        $self->{output}->writeMessageBegin('reportSpammer', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_reportSpammer_args();
                        $args->{spammerMid} = $spammerMid;
                        $args->{spammerReasons} = $spammerReasons;
                        $args->{spamMessageIds} = $spamMessageIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_reportSpammer{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_reportSpammer_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub requestAccountPasswordReset{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;
  my $locale = shift;

                                                $self->send_requestAccountPasswordReset($provider, $identifier, $locale);
                        $self->recv_requestAccountPasswordReset();
}

sub send_requestAccountPasswordReset{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;
  my $locale = shift;

                        $self->{output}->writeMessageBegin('requestAccountPasswordReset', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_requestAccountPasswordReset_args();
                        $args->{provider} = $provider;
                        $args->{identifier} = $identifier;
                        $args->{locale} = $locale;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_requestAccountPasswordReset{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_requestAccountPasswordReset_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub requestEmailConfirmation{
  my $self = shift;
  my $emailConfirmation = shift;

                                                $self->send_requestEmailConfirmation($emailConfirmation);
                        return $self->recv_requestEmailConfirmation();
}

sub send_requestEmailConfirmation{
  my $self = shift;
  my $emailConfirmation = shift;

                        $self->{output}->writeMessageBegin('requestEmailConfirmation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_requestEmailConfirmation_args();
                        $args->{emailConfirmation} = $emailConfirmation;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_requestEmailConfirmation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_requestEmailConfirmation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "requestEmailConfirmation failed: unknown result";
}
sub requestIdentityUnbind{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;

                                                $self->send_requestIdentityUnbind($provider, $identifier);
                        $self->recv_requestIdentityUnbind();
}

sub send_requestIdentityUnbind{
  my $self = shift;
  my $provider = shift;
  my $identifier = shift;

                        $self->{output}->writeMessageBegin('requestIdentityUnbind', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_requestIdentityUnbind_args();
                        $args->{provider} = $provider;
                        $args->{identifier} = $identifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_requestIdentityUnbind{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_requestIdentityUnbind_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub resendEmailConfirmation{
  my $self = shift;
  my $verifier = shift;

                                                $self->send_resendEmailConfirmation($verifier);
                        return $self->recv_resendEmailConfirmation();
}

sub send_resendEmailConfirmation{
  my $self = shift;
  my $verifier = shift;

                        $self->{output}->writeMessageBegin('resendEmailConfirmation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_resendEmailConfirmation_args();
                        $args->{verifier} = $verifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_resendEmailConfirmation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_resendEmailConfirmation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "resendEmailConfirmation failed: unknown result";
}
sub resendPinCode{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_resendPinCode($sessionId);
                        $self->recv_resendPinCode();
}

sub send_resendPinCode{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('resendPinCode', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_resendPinCode_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_resendPinCode{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_resendPinCode_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub resendPinCodeBySMS{
  my $self = shift;
  my $sessionId = shift;

                                                $self->send_resendPinCodeBySMS($sessionId);
                        $self->recv_resendPinCodeBySMS();
}

sub send_resendPinCodeBySMS{
  my $self = shift;
  my $sessionId = shift;

                        $self->{output}->writeMessageBegin('resendPinCodeBySMS', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_resendPinCodeBySMS_args();
                        $args->{sessionId} = $sessionId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_resendPinCodeBySMS{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_resendPinCodeBySMS_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub sendChatChecked{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $lastMessageId = shift;

                                                $self->send_sendChatChecked($seq, $consumer, $lastMessageId);
                        $self->recv_sendChatChecked();
}

sub send_sendChatChecked{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $lastMessageId = shift;

                        $self->{output}->writeMessageBegin('sendChatChecked', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendChatChecked_args();
                        $args->{seq} = $seq;
                        $args->{consumer} = $consumer;
                        $args->{lastMessageId} = $lastMessageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendChatChecked{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendChatChecked_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub sendMessageAwaitCommit{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                                                $self->send_sendMessageAwaitCommit($seq, $message);
                        return $self->recv_sendMessageAwaitCommit();
}

sub send_sendMessageAwaitCommit{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                        $self->{output}->writeMessageBegin('sendMessageAwaitCommit', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendMessageAwaitCommit_args();
                        $args->{seq} = $seq;
                        $args->{message} = $message;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendMessageAwaitCommit{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendMessageAwaitCommit_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "sendMessageAwaitCommit failed: unknown result";
}
sub sendChatRemoved{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $lastMessageId = shift;

                                                $self->send_sendChatRemoved($seq, $consumer, $lastMessageId);
                        $self->recv_sendChatRemoved();
}

sub send_sendChatRemoved{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $lastMessageId = shift;

                        $self->{output}->writeMessageBegin('sendChatRemoved', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendChatRemoved_args();
                        $args->{seq} = $seq;
                        $args->{consumer} = $consumer;
                        $args->{lastMessageId} = $lastMessageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendChatRemoved{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendChatRemoved_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub sendContentPreviewUpdated{
  my $self = shift;
  my $esq = shift;
  my $messageId = shift;
  my $receiverMids = shift;

                                                $self->send_sendContentPreviewUpdated($esq, $messageId, $receiverMids);
                        return $self->recv_sendContentPreviewUpdated();
}

sub send_sendContentPreviewUpdated{
  my $self = shift;
  my $esq = shift;
  my $messageId = shift;
  my $receiverMids = shift;

                        $self->{output}->writeMessageBegin('sendContentPreviewUpdated', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendContentPreviewUpdated_args();
                        $args->{esq} = $esq;
                        $args->{messageId} = $messageId;
                        $args->{receiverMids} = $receiverMids;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendContentPreviewUpdated{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendContentPreviewUpdated_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "sendContentPreviewUpdated failed: unknown result";
}
sub sendContentReceipt{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageId = shift;

                                                $self->send_sendContentReceipt($seq, $consumer, $messageId);
                        $self->recv_sendContentReceipt();
}

sub send_sendContentReceipt{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageId = shift;

                        $self->{output}->writeMessageBegin('sendContentReceipt', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendContentReceipt_args();
                        $args->{seq} = $seq;
                        $args->{consumer} = $consumer;
                        $args->{messageId} = $messageId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendContentReceipt{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendContentReceipt_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub sendDummyPush{
  my $self = shift;

                                                $self->send_sendDummyPush();
                        $self->recv_sendDummyPush();
}

sub send_sendDummyPush{
  my $self = shift;

                        $self->{output}->writeMessageBegin('sendDummyPush', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendDummyPush_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendDummyPush{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendDummyPush_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub removeE2EEPublicKey{
  my $self = shift;
  my $publicKey = shift;

                                                $self->send_removeE2EEPublicKey($publicKey);
                        $self->recv_removeE2EEPublicKey();
}

sub send_removeE2EEPublicKey{
  my $self = shift;
  my $publicKey = shift;

                        $self->{output}->writeMessageBegin('removeE2EEPublicKey', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_removeE2EEPublicKey_args();
                        $args->{publicKey} = $publicKey;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_removeE2EEPublicKey{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_removeE2EEPublicKey_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub negotiateE2EEPublicKey{
  my $self = shift;
  my $mid = shift;

                                                $self->send_negotiateE2EEPublicKey($mid);
                        return $self->recv_negotiateE2EEPublicKey();
}

sub send_negotiateE2EEPublicKey{
  my $self = shift;
  my $mid = shift;

                        $self->{output}->writeMessageBegin('negotiateE2EEPublicKey', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_negotiateE2EEPublicKey_args();
                        $args->{mid} = $mid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_negotiateE2EEPublicKey{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_negotiateE2EEPublicKey_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "negotiateE2EEPublicKey failed: unknown result";
}
sub getE2EEPublicKey{
  my $self = shift;
  my $mid = shift;
  my $version = shift;
  my $keyId = shift;

                                                $self->send_getE2EEPublicKey($mid, $version, $keyId);
                        return $self->recv_getE2EEPublicKey();
}

sub send_getE2EEPublicKey{
  my $self = shift;
  my $mid = shift;
  my $version = shift;
  my $keyId = shift;

                        $self->{output}->writeMessageBegin('getE2EEPublicKey', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getE2EEPublicKey_args();
                        $args->{mid} = $mid;
                        $args->{version} = $version;
                        $args->{keyId} = $keyId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getE2EEPublicKey{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getE2EEPublicKey_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getE2EEPublicKey failed: unknown result";
}
sub requestE2EEKeyExchange{
  my $self = shift;
  my $reqSeq = shift;
  my $temporalPublicKey = shift;
  my $publicKey = shift;
  my $verifier = shift;

                                                $self->send_requestE2EEKeyExchange($reqSeq, $temporalPublicKey, $publicKey, $verifier);
                        $self->recv_requestE2EEKeyExchange();
}

sub send_requestE2EEKeyExchange{
  my $self = shift;
  my $reqSeq = shift;
  my $temporalPublicKey = shift;
  my $publicKey = shift;
  my $verifier = shift;

                        $self->{output}->writeMessageBegin('requestE2EEKeyExchange', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_requestE2EEKeyExchange_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{temporalPublicKey} = $temporalPublicKey;
                        $args->{publicKey} = $publicKey;
                        $args->{verifier} = $verifier;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_requestE2EEKeyExchange{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_requestE2EEKeyExchange_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub getLastE2EEPublicKeys{
  my $self = shift;
  my $chatMid = shift;

                                                $self->send_getLastE2EEPublicKeys($chatMid);
                        return $self->recv_getLastE2EEPublicKeys();
}

sub send_getLastE2EEPublicKeys{
  my $self = shift;
  my $chatMid = shift;

                        $self->{output}->writeMessageBegin('getLastE2EEPublicKeys', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getLastE2EEPublicKeys_args();
                        $args->{chatMid} = $chatMid;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getLastE2EEPublicKeys{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getLastE2EEPublicKeys_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getLastE2EEPublicKeys failed: unknown result";
}
sub registerE2EEPublicKey{
  my $self = shift;
  my $reqSeq = shift;
  my $publicKey = shift;

                                                $self->send_registerE2EEPublicKey($reqSeq, $publicKey);
                        return $self->recv_registerE2EEPublicKey();
}

sub send_registerE2EEPublicKey{
  my $self = shift;
  my $reqSeq = shift;
  my $publicKey = shift;

                        $self->{output}->writeMessageBegin('registerE2EEPublicKey', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_registerE2EEPublicKey_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{publicKey} = $publicKey;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_registerE2EEPublicKey{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_registerE2EEPublicKey_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "registerE2EEPublicKey failed: unknown result";
}
sub getE2EEPublicKeys{
  my $self = shift;

                                                $self->send_getE2EEPublicKeys();
                        return $self->recv_getE2EEPublicKeys();
}

sub send_getE2EEPublicKeys{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getE2EEPublicKeys', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getE2EEPublicKeys_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getE2EEPublicKeys{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getE2EEPublicKeys_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getE2EEPublicKeys failed: unknown result";
}
sub getE2EEPublicKeysEx{
  my $self = shift;
  my $ignoreE2EEStatus = shift;

                                                $self->send_getE2EEPublicKeysEx($ignoreE2EEStatus);
                        return $self->recv_getE2EEPublicKeysEx();
}

sub send_getE2EEPublicKeysEx{
  my $self = shift;
  my $ignoreE2EEStatus = shift;

                        $self->{output}->writeMessageBegin('getE2EEPublicKeysEx', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getE2EEPublicKeysEx_args();
                        $args->{ignoreE2EEStatus} = $ignoreE2EEStatus;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getE2EEPublicKeysEx{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getE2EEPublicKeysEx_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getE2EEPublicKeysEx failed: unknown result";
}
sub getReadMessageOpsInBulk{
  my $self = shift;
  my $chatIds = shift;

                                                $self->send_getReadMessageOpsInBulk($chatIds);
                        return $self->recv_getReadMessageOpsInBulk();
}

sub send_getReadMessageOpsInBulk{
  my $self = shift;
  my $chatIds = shift;

                        $self->{output}->writeMessageBegin('getReadMessageOpsInBulk', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getReadMessageOpsInBulk_args();
                        $args->{chatIds} = $chatIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getReadMessageOpsInBulk{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getReadMessageOpsInBulk_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getReadMessageOpsInBulk failed: unknown result";
}
sub sendEvent{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                                                $self->send_sendEvent($seq, $message);
                        return $self->recv_sendEvent();
}

sub send_sendEvent{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                        $self->{output}->writeMessageBegin('sendEvent', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendEvent_args();
                        $args->{seq} = $seq;
                        $args->{message} = $message;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendEvent{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendEvent_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "sendEvent failed: unknown result";
}
sub sendMessage{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                                                $self->send_sendMessage($seq, $message);
                        return $self->recv_sendMessage();
}

sub send_sendMessage{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                        $self->{output}->writeMessageBegin('sendMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendMessage_args();
                        $args->{seq} = $seq;
                        $args->{message} = $message;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "sendMessage failed: unknown result";
}
sub sendMessageIgnored{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageIds = shift;

                                                $self->send_sendMessageIgnored($seq, $consumer, $messageIds);
                        $self->recv_sendMessageIgnored();
}

sub send_sendMessageIgnored{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageIds = shift;

                        $self->{output}->writeMessageBegin('sendMessageIgnored', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendMessageIgnored_args();
                        $args->{seq} = $seq;
                        $args->{consumer} = $consumer;
                        $args->{messageIds} = $messageIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendMessageIgnored{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendMessageIgnored_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub sendMessageReceipt{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageIds = shift;

                                                $self->send_sendMessageReceipt($seq, $consumer, $messageIds);
                        $self->recv_sendMessageReceipt();
}

sub send_sendMessageReceipt{
  my $self = shift;
  my $seq = shift;
  my $consumer = shift;
  my $messageIds = shift;

                        $self->{output}->writeMessageBegin('sendMessageReceipt', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendMessageReceipt_args();
                        $args->{seq} = $seq;
                        $args->{consumer} = $consumer;
                        $args->{messageIds} = $messageIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendMessageReceipt{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendMessageReceipt_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub findContactByMetaTag{
  my $self = shift;
  my $userid = shift;
  my $reference = shift;

                                                $self->send_findContactByMetaTag($userid, $reference);
                        return $self->recv_findContactByMetaTag();
}

sub send_findContactByMetaTag{
  my $self = shift;
  my $userid = shift;
  my $reference = shift;

                        $self->{output}->writeMessageBegin('findContactByMetaTag', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_findContactByMetaTag_args();
                        $args->{userid} = $userid;
                        $args->{reference} = $reference;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_findContactByMetaTag{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_findContactByMetaTag_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "findContactByMetaTag failed: unknown result";
}
sub sendMessageToMyHome{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                                                $self->send_sendMessageToMyHome($seq, $message);
                        return $self->recv_sendMessageToMyHome();
}

sub send_sendMessageToMyHome{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                        $self->{output}->writeMessageBegin('sendMessageToMyHome', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_sendMessageToMyHome_args();
                        $args->{seq} = $seq;
                        $args->{message} = $message;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_sendMessageToMyHome{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_sendMessageToMyHome_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "sendMessageToMyHome failed: unknown result";
}
sub setBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;
  my $location = shift;

                                                $self->send_setBuddyLocation($mid, $index, $location);
                        $self->recv_setBuddyLocation();
}

sub send_setBuddyLocation{
  my $self = shift;
  my $mid = shift;
  my $index = shift;
  my $location = shift;

                        $self->{output}->writeMessageBegin('setBuddyLocation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_setBuddyLocation_args();
                        $args->{mid} = $mid;
                        $args->{index} = $index;
                        $args->{location} = $location;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_setBuddyLocation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_setBuddyLocation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub setIdentityCredential{
  my $self = shift;
  my $identifier = shift;
  my $verifier = shift;
  my $provider = shift;

                                                $self->send_setIdentityCredential($identifier, $verifier, $provider);
                        $self->recv_setIdentityCredential();
}

sub send_setIdentityCredential{
  my $self = shift;
  my $identifier = shift;
  my $verifier = shift;
  my $provider = shift;

                        $self->{output}->writeMessageBegin('setIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_setIdentityCredential_args();
                        $args->{identifier} = $identifier;
                        $args->{verifier} = $verifier;
                        $args->{provider} = $provider;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_setIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_setIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub setNotificationsEnabled{
  my $self = shift;
  my $reqSeq = shift;
  my $type = shift;
  my $target = shift;
  my $enablement = shift;

                                                $self->send_setNotificationsEnabled($reqSeq, $type, $target, $enablement);
                        $self->recv_setNotificationsEnabled();
}

sub send_setNotificationsEnabled{
  my $self = shift;
  my $reqSeq = shift;
  my $type = shift;
  my $target = shift;
  my $enablement = shift;

                        $self->{output}->writeMessageBegin('setNotificationsEnabled', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_setNotificationsEnabled_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{type} = $type;
                        $args->{target} = $target;
                        $args->{enablement} = $enablement;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_setNotificationsEnabled{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_setNotificationsEnabled_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub startUpdateVerification{
  my $self = shift;
  my $region = shift;
  my $carrier = shift;
  my $phone = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $networkCode = shift;
  my $locale = shift;

                                                $self->send_startUpdateVerification($region, $carrier, $phone, $udidHash, $deviceInfo, $networkCode, $locale);
                        return $self->recv_startUpdateVerification();
}

sub send_startUpdateVerification{
  my $self = shift;
  my $region = shift;
  my $carrier = shift;
  my $phone = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $networkCode = shift;
  my $locale = shift;

                        $self->{output}->writeMessageBegin('startUpdateVerification', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_startUpdateVerification_args();
                        $args->{region} = $region;
                        $args->{carrier} = $carrier;
                        $args->{phone} = $phone;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->{networkCode} = $networkCode;
                        $args->{locale} = $locale;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_startUpdateVerification{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_startUpdateVerification_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "startUpdateVerification failed: unknown result";
}
sub startVerification{
  my $self = shift;
  my $region = shift;
  my $carrier = shift;
  my $phone = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $networkCode = shift;
  my $mid = shift;
  my $locale = shift;
  my $simInfo = shift;
  my $oldUdidHash = shift;

                                                $self->send_startVerification($region, $carrier, $phone, $udidHash, $deviceInfo, $networkCode, $mid, $locale, $simInfo, $oldUdidHash);
                        return $self->recv_startVerification();
}

sub send_startVerification{
  my $self = shift;
  my $region = shift;
  my $carrier = shift;
  my $phone = shift;
  my $udidHash = shift;
  my $deviceInfo = shift;
  my $networkCode = shift;
  my $mid = shift;
  my $locale = shift;
  my $simInfo = shift;
  my $oldUdidHash = shift;

                        $self->{output}->writeMessageBegin('startVerification', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_startVerification_args();
                        $args->{region} = $region;
                        $args->{carrier} = $carrier;
                        $args->{phone} = $phone;
                        $args->{udidHash} = $udidHash;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->{networkCode} = $networkCode;
                        $args->{mid} = $mid;
                        $args->{locale} = $locale;
                        $args->{simInfo} = $simInfo;
                        $args->{oldUdidHash} = $oldUdidHash;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_startVerification{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_startVerification_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "startVerification failed: unknown result";
}
sub updateGroupPreferenceAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $groupMid = shift;
  my $updatedAttrs = shift;

                                                $self->send_updateGroupPreferenceAttribute($reqSeq, $groupMid, $updatedAttrs);
                        $self->recv_updateGroupPreferenceAttribute();
}

sub send_updateGroupPreferenceAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $groupMid = shift;
  my $updatedAttrs = shift;

                        $self->{output}->writeMessageBegin('updateGroupPreferenceAttribute', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateGroupPreferenceAttribute_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{groupMid} = $groupMid;
                        $args->{updatedAttrs} = $updatedAttrs;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateGroupPreferenceAttribute{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateGroupPreferenceAttribute_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub createRoomV2{
  my $self = shift;
  my $reqSeq = shift;
  my $contactIds = shift;

                                                $self->send_createRoomV2($reqSeq, $contactIds);
                        return $self->recv_createRoomV2();
}

sub send_createRoomV2{
  my $self = shift;
  my $reqSeq = shift;
  my $contactIds = shift;

                        $self->{output}->writeMessageBegin('createRoomV2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_createRoomV2_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{contactIds} = $contactIds;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_createRoomV2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_createRoomV2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "createRoomV2 failed: unknown result";
}
sub storeUpdateProfileAttribute{
  my $self = shift;
  my $seq = shift;
  my $profileAttribute = shift;
  my $value = shift;

                                                $self->send_storeUpdateProfileAttribute($seq, $profileAttribute, $value);
                        $self->recv_storeUpdateProfileAttribute();
}

sub send_storeUpdateProfileAttribute{
  my $self = shift;
  my $seq = shift;
  my $profileAttribute = shift;
  my $value = shift;

                        $self->{output}->writeMessageBegin('storeUpdateProfileAttribute', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_storeUpdateProfileAttribute_args();
                        $args->{seq} = $seq;
                        $args->{profileAttribute} = $profileAttribute;
                        $args->{value} = $value;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_storeUpdateProfileAttribute{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_storeUpdateProfileAttribute_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub syncContactBySnsIds{
  my $self = shift;
  my $reqSeq = shift;
  my $modifications = shift;

                                                $self->send_syncContactBySnsIds($reqSeq, $modifications);
                        return $self->recv_syncContactBySnsIds();
}

sub send_syncContactBySnsIds{
  my $self = shift;
  my $reqSeq = shift;
  my $modifications = shift;

                        $self->{output}->writeMessageBegin('syncContactBySnsIds', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_syncContactBySnsIds_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{modifications} = $modifications;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_syncContactBySnsIds{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_syncContactBySnsIds_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "syncContactBySnsIds failed: unknown result";
}
sub syncContacts{
  my $self = shift;
  my $reqSeq = shift;
  my $localContacts = shift;

                                                $self->send_syncContacts($reqSeq, $localContacts);
                        return $self->recv_syncContacts();
}

sub send_syncContacts{
  my $self = shift;
  my $reqSeq = shift;
  my $localContacts = shift;

                        $self->{output}->writeMessageBegin('syncContacts', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_syncContacts_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{localContacts} = $localContacts;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_syncContacts{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_syncContacts_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "syncContacts failed: unknown result";
}
sub trySendMessage{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                                                $self->send_trySendMessage($seq, $message);
                        return $self->recv_trySendMessage();
}

sub send_trySendMessage{
  my $self = shift;
  my $seq = shift;
  my $message = shift;

                        $self->{output}->writeMessageBegin('trySendMessage', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_trySendMessage_args();
                        $args->{seq} = $seq;
                        $args->{message} = $message;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_trySendMessage{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_trySendMessage_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "trySendMessage failed: unknown result";
}
sub getNextMessagesV2{
  my $self = shift;
  my $messageBoxId = shift;
  my $startMessageId = shift;
  my $messagesCount = shift;

                                                $self->send_getNextMessagesV2($messageBoxId, $startMessageId, $messagesCount);
                        return $self->recv_getNextMessagesV2();
}

sub send_getNextMessagesV2{
  my $self = shift;
  my $messageBoxId = shift;
  my $startMessageId = shift;
  my $messagesCount = shift;

                        $self->{output}->writeMessageBegin('getNextMessagesV2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getNextMessagesV2_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{startMessageId} = $startMessageId;
                        $args->{messagesCount} = $messagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getNextMessagesV2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getNextMessagesV2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getNextMessagesV2 failed: unknown result";
}
sub getMessageBoxCompactWrapUpV2{
  my $self = shift;
  my $messageBoxId = shift;

                                                $self->send_getMessageBoxCompactWrapUpV2($messageBoxId);
                        return $self->recv_getMessageBoxCompactWrapUpV2();
}

sub send_getMessageBoxCompactWrapUpV2{
  my $self = shift;
  my $messageBoxId = shift;

                        $self->{output}->writeMessageBegin('getMessageBoxCompactWrapUpV2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getMessageBoxCompactWrapUpV2_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getMessageBoxCompactWrapUpV2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getMessageBoxCompactWrapUpV2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getMessageBoxCompactWrapUpV2 failed: unknown result";
}
sub getRecentMessagesV2{
  my $self = shift;
  my $messageBoxId = shift;
  my $messagesCount = shift;

                                                $self->send_getRecentMessagesV2($messageBoxId, $messagesCount);
                        return $self->recv_getRecentMessagesV2();
}

sub send_getRecentMessagesV2{
  my $self = shift;
  my $messageBoxId = shift;
  my $messagesCount = shift;

                        $self->{output}->writeMessageBegin('getRecentMessagesV2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_getRecentMessagesV2_args();
                        $args->{messageBoxId} = $messageBoxId;
                        $args->{messagesCount} = $messagesCount;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getRecentMessagesV2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_getRecentMessagesV2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "getRecentMessagesV2 failed: unknown result";
}
sub validateContactsOnBot{
  my $self = shift;
  my $contacts = shift;

                                                $self->send_validateContactsOnBot($contacts);
                        return $self->recv_validateContactsOnBot();
}

sub send_validateContactsOnBot{
  my $self = shift;
  my $contacts = shift;

                        $self->{output}->writeMessageBegin('validateContactsOnBot', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_validateContactsOnBot_args();
                        $args->{contacts} = $contacts;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_validateContactsOnBot{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_validateContactsOnBot_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "validateContactsOnBot failed: unknown result";
}
sub tryFriendRequest{
  my $self = shift;
  my $midOrEMid = shift;
  my $method = shift;
  my $friendRequestParams = shift;

                                                $self->send_tryFriendRequest($midOrEMid, $method, $friendRequestParams);
                        $self->recv_tryFriendRequest();
}

sub send_tryFriendRequest{
  my $self = shift;
  my $midOrEMid = shift;
  my $method = shift;
  my $friendRequestParams = shift;

                        $self->{output}->writeMessageBegin('tryFriendRequest', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_tryFriendRequest_args();
                        $args->{midOrEMid} = $midOrEMid;
                        $args->{method} = $method;
                        $args->{friendRequestParams} = $friendRequestParams;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_tryFriendRequest{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_tryFriendRequest_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub unblockContact{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                                                $self->send_unblockContact($reqSeq, $id);
                        $self->recv_unblockContact();
}

sub send_unblockContact{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                        $self->{output}->writeMessageBegin('unblockContact', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_unblockContact_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{id} = $id;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_unblockContact{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_unblockContact_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub unblockRecommendation{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                                                $self->send_unblockRecommendation($reqSeq, $id);
                        $self->recv_unblockRecommendation();
}

sub send_unblockRecommendation{
  my $self = shift;
  my $reqSeq = shift;
  my $id = shift;

                        $self->{output}->writeMessageBegin('unblockRecommendation', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_unblockRecommendation_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{id} = $id;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_unblockRecommendation{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_unblockRecommendation_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub unregisterUserAndDevice{
  my $self = shift;

                                                $self->send_unregisterUserAndDevice();
                        return $self->recv_unregisterUserAndDevice();
}

sub send_unregisterUserAndDevice{
  my $self = shift;

                        $self->{output}->writeMessageBegin('unregisterUserAndDevice', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_unregisterUserAndDevice_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_unregisterUserAndDevice{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_unregisterUserAndDevice_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "unregisterUserAndDevice failed: unknown result";
}
sub updateApnsDeviceToken{
  my $self = shift;
  my $apnsDeviceToken = shift;

                                                $self->send_updateApnsDeviceToken($apnsDeviceToken);
                        $self->recv_updateApnsDeviceToken();
}

sub send_updateApnsDeviceToken{
  my $self = shift;
  my $apnsDeviceToken = shift;

                        $self->{output}->writeMessageBegin('updateApnsDeviceToken', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateApnsDeviceToken_args();
                        $args->{apnsDeviceToken} = $apnsDeviceToken;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateApnsDeviceToken{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateApnsDeviceToken_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateBuddySetting{
  my $self = shift;
  my $key = shift;
  my $value = shift;

                                                $self->send_updateBuddySetting($key, $value);
                        $self->recv_updateBuddySetting();
}

sub send_updateBuddySetting{
  my $self = shift;
  my $key = shift;
  my $value = shift;

                        $self->{output}->writeMessageBegin('updateBuddySetting', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateBuddySetting_args();
                        $args->{key} = $key;
                        $args->{value} = $value;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateBuddySetting{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateBuddySetting_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateC2DMRegistrationId{
  my $self = shift;
  my $registrationId = shift;

                                                $self->send_updateC2DMRegistrationId($registrationId);
                        $self->recv_updateC2DMRegistrationId();
}

sub send_updateC2DMRegistrationId{
  my $self = shift;
  my $registrationId = shift;

                        $self->{output}->writeMessageBegin('updateC2DMRegistrationId', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateC2DMRegistrationId_args();
                        $args->{registrationId} = $registrationId;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateC2DMRegistrationId{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateC2DMRegistrationId_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateContactSetting{
  my $self = shift;
  my $reqSeq = shift;
  my $mid = shift;
  my $flag = shift;
  my $value = shift;

                                                $self->send_updateContactSetting($reqSeq, $mid, $flag, $value);
                        $self->recv_updateContactSetting();
}

sub send_updateContactSetting{
  my $self = shift;
  my $reqSeq = shift;
  my $mid = shift;
  my $flag = shift;
  my $value = shift;

                        $self->{output}->writeMessageBegin('updateContactSetting', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateContactSetting_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{mid} = $mid;
                        $args->{flag} = $flag;
                        $args->{value} = $value;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateContactSetting{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateContactSetting_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateCustomModeSettings{
  my $self = shift;
  my $customMode = shift;
  my $paramMap = shift;

                                                $self->send_updateCustomModeSettings($customMode, $paramMap);
                        $self->recv_updateCustomModeSettings();
}

sub send_updateCustomModeSettings{
  my $self = shift;
  my $customMode = shift;
  my $paramMap = shift;

                        $self->{output}->writeMessageBegin('updateCustomModeSettings', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateCustomModeSettings_args();
                        $args->{customMode} = $customMode;
                        $args->{paramMap} = $paramMap;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateCustomModeSettings{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateCustomModeSettings_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateDeviceInfo{
  my $self = shift;
  my $deviceUid = shift;
  my $deviceInfo = shift;

                                                $self->send_updateDeviceInfo($deviceUid, $deviceInfo);
                        $self->recv_updateDeviceInfo();
}

sub send_updateDeviceInfo{
  my $self = shift;
  my $deviceUid = shift;
  my $deviceInfo = shift;

                        $self->{output}->writeMessageBegin('updateDeviceInfo', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateDeviceInfo_args();
                        $args->{deviceUid} = $deviceUid;
                        $args->{deviceInfo} = $deviceInfo;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateDeviceInfo{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateDeviceInfo_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $group = shift;

                                                $self->send_updateGroup($reqSeq, $group);
                        $self->recv_updateGroup();
}

sub send_updateGroup{
  my $self = shift;
  my $reqSeq = shift;
  my $group = shift;

                        $self->{output}->writeMessageBegin('updateGroup', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateGroup_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{group} = $group;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateGroup{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateGroup_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateNotificationToken{
  my $self = shift;
  my $type = shift;
  my $token = shift;

                                                $self->send_updateNotificationToken($type, $token);
                        $self->recv_updateNotificationToken();
}

sub send_updateNotificationToken{
  my $self = shift;
  my $type = shift;
  my $token = shift;

                        $self->{output}->writeMessageBegin('updateNotificationToken', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateNotificationToken_args();
                        $args->{type} = $type;
                        $args->{token} = $token;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateNotificationToken{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateNotificationToken_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateNotificationTokenWithBytes{
  my $self = shift;
  my $type = shift;
  my $token = shift;

                                                $self->send_updateNotificationTokenWithBytes($type, $token);
                        $self->recv_updateNotificationTokenWithBytes();
}

sub send_updateNotificationTokenWithBytes{
  my $self = shift;
  my $type = shift;
  my $token = shift;

                        $self->{output}->writeMessageBegin('updateNotificationTokenWithBytes', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateNotificationTokenWithBytes_args();
                        $args->{type} = $type;
                        $args->{token} = $token;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateNotificationTokenWithBytes{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateNotificationTokenWithBytes_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateProfile{
  my $self = shift;
  my $reqSeq = shift;
  my $profile = shift;

                                                $self->send_updateProfile($reqSeq, $profile);
                        $self->recv_updateProfile();
}

sub send_updateProfile{
  my $self = shift;
  my $reqSeq = shift;
  my $profile = shift;

                        $self->{output}->writeMessageBegin('updateProfile', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateProfile_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{profile} = $profile;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateProfile{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateProfile_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateProfileAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $attr = shift;
  my $value = shift;

                                                $self->send_updateProfileAttribute($reqSeq, $attr, $value);
                        $self->recv_updateProfileAttribute();
}

sub send_updateProfileAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $attr = shift;
  my $value = shift;

                        $self->{output}->writeMessageBegin('updateProfileAttribute', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateProfileAttribute_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{attr} = $attr;
                        $args->{value} = $value;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateProfileAttribute{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateProfileAttribute_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateProfileAttributes{
  my $self = shift;
  my $reqSeq = shift;
  my $request = shift;

                                                $self->send_updateProfileAttributes($reqSeq, $request);
                        $self->recv_updateProfileAttributes();
}

sub send_updateProfileAttributes{
  my $self = shift;
  my $reqSeq = shift;
  my $request = shift;

                        $self->{output}->writeMessageBegin('updateProfileAttributes', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateProfileAttributes_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{request} = $request;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateProfileAttributes{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateProfileAttributes_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        return;
}
sub updateRegion{
  my $self = shift;
  my $region = shift;

                                                $self->send_updateRegion($region);
                        $self->recv_updateRegion();
}

sub send_updateRegion{
  my $self = shift;
  my $region = shift;

                        $self->{output}->writeMessageBegin('updateRegion', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateRegion_args();
                        $args->{region} = $region;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateRegion{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateRegion_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateSettings{
  my $self = shift;
  my $reqSeq = shift;
  my $settings = shift;

                                                $self->send_updateSettings($reqSeq, $settings);
                        $self->recv_updateSettings();
}

sub send_updateSettings{
  my $self = shift;
  my $reqSeq = shift;
  my $settings = shift;

                        $self->{output}->writeMessageBegin('updateSettings', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateSettings_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{settings} = $settings;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateSettings{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateSettings_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateSettings2{
  my $self = shift;
  my $reqSeq = shift;
  my $settings = shift;

                                                $self->send_updateSettings2($reqSeq, $settings);
                        return $self->recv_updateSettings2();
}

sub send_updateSettings2{
  my $self = shift;
  my $reqSeq = shift;
  my $settings = shift;

                        $self->{output}->writeMessageBegin('updateSettings2', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateSettings2_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{settings} = $settings;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateSettings2{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateSettings2_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "updateSettings2 failed: unknown result";
}
sub updateSettingsAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $attr = shift;
  my $value = shift;

                                                $self->send_updateSettingsAttribute($reqSeq, $attr, $value);
                        $self->recv_updateSettingsAttribute();
}

sub send_updateSettingsAttribute{
  my $self = shift;
  my $reqSeq = shift;
  my $attr = shift;
  my $value = shift;

                        $self->{output}->writeMessageBegin('updateSettingsAttribute', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateSettingsAttribute_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{attr} = $attr;
                        $args->{value} = $value;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateSettingsAttribute{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateSettingsAttribute_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub updateSettingsAttributes{
  my $self = shift;
  my $reqSeq = shift;
  my $attrBitset = shift;
  my $settings = shift;

                                                $self->send_updateSettingsAttributes($reqSeq, $attrBitset, $settings);
                        return $self->recv_updateSettingsAttributes();
}

sub send_updateSettingsAttributes{
  my $self = shift;
  my $reqSeq = shift;
  my $attrBitset = shift;
  my $settings = shift;

                        $self->{output}->writeMessageBegin('updateSettingsAttributes', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_updateSettingsAttributes_args();
                        $args->{reqSeq} = $reqSeq;
                        $args->{attrBitset} = $attrBitset;
                        $args->{settings} = $settings;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_updateSettingsAttributes{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_updateSettingsAttributes_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "updateSettingsAttributes failed: unknown result";
}
sub verifyIdentityCredential{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;

                                                $self->send_verifyIdentityCredential($identityProvider, $identifier, $password);
                        $self->recv_verifyIdentityCredential();
}

sub send_verifyIdentityCredential{
  my $self = shift;
  my $identityProvider = shift;
  my $identifier = shift;
  my $password = shift;

                        $self->{output}->writeMessageBegin('verifyIdentityCredential', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_verifyIdentityCredential_args();
                        $args->{identityProvider} = $identityProvider;
                        $args->{identifier} = $identifier;
                        $args->{password} = $password;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_verifyIdentityCredential{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_verifyIdentityCredential_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        return;
}
sub verifyIdentityCredentialWithResult{
  my $self = shift;
  my $identityCredential = shift;

                                                $self->send_verifyIdentityCredentialWithResult($identityCredential);
                        return $self->recv_verifyIdentityCredentialWithResult();
}

sub send_verifyIdentityCredentialWithResult{
  my $self = shift;
  my $identityCredential = shift;

                        $self->{output}->writeMessageBegin('verifyIdentityCredentialWithResult', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_verifyIdentityCredentialWithResult_args();
                        $args->{identityCredential} = $identityCredential;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_verifyIdentityCredentialWithResult{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_verifyIdentityCredentialWithResult_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "verifyIdentityCredentialWithResult failed: unknown result";
}
sub verifyPhone{
  my $self = shift;
  my $sessionId = shift;
  my $pinCode = shift;
  my $udidHash = shift;

                                                $self->send_verifyPhone($sessionId, $pinCode, $udidHash);
                        return $self->recv_verifyPhone();
}

sub send_verifyPhone{
  my $self = shift;
  my $sessionId = shift;
  my $pinCode = shift;
  my $udidHash = shift;

                        $self->{output}->writeMessageBegin('verifyPhone', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_verifyPhone_args();
                        $args->{sessionId} = $sessionId;
                        $args->{pinCode} = $pinCode;
                        $args->{udidHash} = $udidHash;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_verifyPhone{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_verifyPhone_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "verifyPhone failed: unknown result";
}
sub verifyQrcode{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;

                                                $self->send_verifyQrcode($verifier, $pinCode);
                        return $self->recv_verifyQrcode();
}

sub send_verifyQrcode{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;

                        $self->{output}->writeMessageBegin('verifyQrcode', Thrift::TMessageType::CALL, $self->{seqid});
                        my $args = new TalkService_verifyQrcode_args();
                        $args->{verifier} = $verifier;
                        $args->{pinCode} = $pinCode;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_verifyQrcode{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == Thrift::TMessageType::EXCEPTION) {
                          my $x = new Thrift::TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new TalkService_verifyQrcode_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        if (defined $result->{e}) {
                          die $result->{e};
                        }
                        die "verifyQrcode failed: unknown result";
}
package TalkServiceProcessor;

use strict;


sub new {
                          my ($classname, $handler) = @_;
                          my $self      = {};
                          $self->{handler} = $handler;
                          return bless ($self, $classname);
}

sub process {
                          my ($self, $input, $output) = @_;
                          my $rseqid = 0;
                          my $fname  = undef;
                          my $mtype  = 0;

                          $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                          my $methodname = 'process_'.$fname;
                          if (!$self->can($methodname)) {
                            $input->skip(Thrift::TType::STRUCT);
                            $input->readMessageEnd();
                            my $x = new Thrift::TApplicationException('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
                            $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
                            $x->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            return;
                          }
                          $self->$methodname($rseqid, $input, $output);
                          return 1;
}

sub process_searchCollection {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_searchCollection_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_searchCollection_result();
                          eval {
                            $result->{success} = $self->{handler}->searchCollection($args->query, $args->param);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('searchCollection', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('searchCollection', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getChatRoomAnnouncementsBulk {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getChatRoomAnnouncementsBulk_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getChatRoomAnnouncementsBulk_result();
                          eval {
                            $result->{success} = $self->{handler}->getChatRoomAnnouncementsBulk($args->chatRoomMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getChatRoomAnnouncementsBulk', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getChatRoomAnnouncementsBulk', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getChatRoomAnnouncements {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getChatRoomAnnouncements_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getChatRoomAnnouncements_result();
                          eval {
                            $result->{success} = $self->{handler}->getChatRoomAnnouncements($args->chatRoomMid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getChatRoomAnnouncements', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getChatRoomAnnouncements', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_createChatRoomAnnouncement {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_createChatRoomAnnouncement_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_createChatRoomAnnouncement_result();
                          eval {
                            $result->{success} = $self->{handler}->createChatRoomAnnouncement($args->reqSeq, $args->chatRoomMid, $args->type, $args->contents);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('createChatRoomAnnouncement', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('createChatRoomAnnouncement', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeChatRoomAnnouncement {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeChatRoomAnnouncement_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeChatRoomAnnouncement_result();
                          eval {
                            $self->{handler}->removeChatRoomAnnouncement($args->reqSeq, $args->chatRoomMid, $args->announcementSeq);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeChatRoomAnnouncement', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeChatRoomAnnouncement', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_unsendMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_unsendMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_unsendMessage_result();
                          eval {
                            $self->{handler}->unsendMessage($args->seq, $args->messageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('unsendMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('unsendMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getGroupWithoutMembers {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getGroupWithoutMembers_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getGroupWithoutMembers_result();
                          eval {
                            $result->{success} = $self->{handler}->getGroupWithoutMembers($args->groupId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getGroupWithoutMembers', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getGroupWithoutMembers', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_requestResendMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_requestResendMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_requestResendMessage_result();
                          eval {
                            $self->{handler}->requestResendMessage($args->reqSeq, $args->senderMid, $args->messageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('requestResendMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('requestResendMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_respondResendMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_respondResendMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_respondResendMessage_result();
                          eval {
                            $self->{handler}->respondResendMessage($args->reqSeq, $args->receiverMid, $args->originalMessageId, $args->resendMessage, $args->errorCode);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('respondResendMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('respondResendMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_acceptGroupInvitation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_acceptGroupInvitation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_acceptGroupInvitation_result();
                          eval {
                            $self->{handler}->acceptGroupInvitation($args->reqSeq, $args->groupId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('acceptGroupInvitation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('acceptGroupInvitation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_acceptGroupInvitationByTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_acceptGroupInvitationByTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_acceptGroupInvitationByTicket_result();
                          eval {
                            $self->{handler}->acceptGroupInvitationByTicket($args->reqSeq, $args->GroupMid, $args->ticketId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('acceptGroupInvitationByTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('acceptGroupInvitationByTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_acceptProximityMatches {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_acceptProximityMatches_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_acceptProximityMatches_result();
                          eval {
                            $self->{handler}->acceptProximityMatches($args->sessionId, $args->ids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('acceptProximityMatches', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('acceptProximityMatches', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_acquireCallRoute {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_acquireCallRoute_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_acquireCallRoute_result();
                          eval {
                            $result->{success} = $self->{handler}->acquireCallRoute($args->to);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('acquireCallRoute', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('acquireCallRoute', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_acquireCallTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_acquireCallTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_acquireCallTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->acquireCallTicket($args->to);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('acquireCallTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('acquireCallTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_acquireEncryptedAccessToken {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_acquireEncryptedAccessToken_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_acquireEncryptedAccessToken_result();
                          eval {
                            $result->{success} = $self->{handler}->acquireEncryptedAccessToken($args->featureType);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('acquireEncryptedAccessToken', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('acquireEncryptedAccessToken', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_addSnsId {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_addSnsId_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_addSnsId_result();
                          eval {
                            $result->{success} = $self->{handler}->addSnsId($args->snsIdType, $args->snsAccessToken);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('addSnsId', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('addSnsId', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_blockContact {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_blockContact_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_blockContact_result();
                          eval {
                            $self->{handler}->blockContact($args->reqSeq, $args->id);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('blockContact', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('blockContact', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_blockRecommendation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_blockRecommendation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_blockRecommendation_result();
                          eval {
                            $self->{handler}->blockRecommendation($args->reqSeq, $args->id);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('blockRecommendation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('blockRecommendation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_cancelGroupInvitation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_cancelGroupInvitation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_cancelGroupInvitation_result();
                          eval {
                            $self->{handler}->cancelGroupInvitation($args->reqSeq, $args->groupId, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('cancelGroupInvitation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('cancelGroupInvitation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_changeVerificationMethod {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_changeVerificationMethod_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_changeVerificationMethod_result();
                          eval {
                            $result->{success} = $self->{handler}->changeVerificationMethod($args->sessionId, $args->method);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('changeVerificationMethod', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('changeVerificationMethod', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_clearIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_clearIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_clearIdentityCredential_result();
                          eval {
                            $self->{handler}->clearIdentityCredential();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('clearIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('clearIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_clearMessageBox {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_clearMessageBox_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_clearMessageBox_result();
                          eval {
                            $self->{handler}->clearMessageBox($args->channelId, $args->messageBoxId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('clearMessageBox', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('clearMessageBox', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_closeProximityMatch {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_closeProximityMatch_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_closeProximityMatch_result();
                          eval {
                            $self->{handler}->closeProximityMatch($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('closeProximityMatch', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('closeProximityMatch', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_commitSendMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_commitSendMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_commitSendMessage_result();
                          eval {
                            $result->{success} = $self->{handler}->commitSendMessage($args->seq, $args->messageId, $args->receiverMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('commitSendMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('commitSendMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_commitSendMessages {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_commitSendMessages_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_commitSendMessages_result();
                          eval {
                            $result->{success} = $self->{handler}->commitSendMessages($args->seq, $args->messageIds, $args->receiverMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('commitSendMessages', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('commitSendMessages', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_commitUpdateProfile {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_commitUpdateProfile_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_commitUpdateProfile_result();
                          eval {
                            $result->{success} = $self->{handler}->commitUpdateProfile($args->seq, $args->attrs, $args->receiverMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('commitUpdateProfile', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('commitUpdateProfile', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_confirmEmail {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_confirmEmail_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_confirmEmail_result();
                          eval {
                            $self->{handler}->confirmEmail($args->verifier, $args->pinCode);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('confirmEmail', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('confirmEmail', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_createGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_createGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_createGroup_result();
                          eval {
                            $result->{success} = $self->{handler}->createGroup($args->seq, $args->name, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('createGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('createGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_createQrcodeBase64Image {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_createQrcodeBase64Image_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_createQrcodeBase64Image_result();
                          eval {
                            $result->{success} = $self->{handler}->createQrcodeBase64Image($args->url, $args->characterSet, $args->imageSize, $args->x, $args->y, $args->width, $args->height);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('createQrcodeBase64Image', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('createQrcodeBase64Image', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_createRoom {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_createRoom_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_createRoom_result();
                          eval {
                            $result->{success} = $self->{handler}->createRoom($args->reqSeq, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('createRoom', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('createRoom', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_createSession {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_createSession_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_createSession_result();
                          eval {
                            $result->{success} = $self->{handler}->createSession();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('createSession', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('createSession', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_fetchAnnouncements {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_fetchAnnouncements_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_fetchAnnouncements_result();
                          eval {
                            $result->{success} = $self->{handler}->fetchAnnouncements($args->lastFetchedIndex);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('fetchAnnouncements', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('fetchAnnouncements', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_fetchMessages {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_fetchMessages_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_fetchMessages_result();
                          eval {
                            $result->{success} = $self->{handler}->fetchMessages($args->localTs, $args->count);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('fetchMessages', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('fetchMessages', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_fetchOperations {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_fetchOperations_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_fetchOperations_result();
                          eval {
                            $result->{success} = $self->{handler}->fetchOperations($args->localRev, $args->count);
                          }; if( UNIVERSAL::isa($@,'ShouldSyncException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('fetchOperations', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('fetchOperations', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_fetchOps {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_fetchOps_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_fetchOps_result();
                          eval {
                            $result->{success} = $self->{handler}->fetchOps($args->localRev, $args->count, $args->globalRev, $args->individualRev);
                          }; if( UNIVERSAL::isa($@,'ShouldSyncException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('fetchOps', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('fetchOps', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findAndAddContactsByEmail {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findAndAddContactsByEmail_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findAndAddContactsByEmail_result();
                          eval {
                            $result->{success} = $self->{handler}->findAndAddContactsByEmail($args->reqSeq, $args->emails);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findAndAddContactsByEmail', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findAndAddContactsByEmail', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findAndAddContactsByMid {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findAndAddContactsByMid_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findAndAddContactsByMid_result();
                          eval {
                            $result->{success} = $self->{handler}->findAndAddContactsByMid($args->reqSeq, $args->mid, $args->type, $args->reference);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findAndAddContactsByMid', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findAndAddContactsByMid', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findGroupByTicketV2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findGroupByTicketV2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findGroupByTicketV2_result();
                          eval {
                            $result->{success} = $self->{handler}->findGroupByTicketV2($args->ticketId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findGroupByTicketV2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findGroupByTicketV2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findAndAddContactsByPhone {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findAndAddContactsByPhone_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findAndAddContactsByPhone_result();
                          eval {
                            $result->{success} = $self->{handler}->findAndAddContactsByPhone($args->reqSeq, $args->phones);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findAndAddContactsByPhone', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findAndAddContactsByPhone', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getFriendRequests {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getFriendRequests_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getFriendRequests_result();
                          eval {
                            $result->{success} = $self->{handler}->getFriendRequests($args->direction, $args->lastSeenSeqId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getFriendRequests', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getFriendRequests', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeFriendRequest {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeFriendRequest_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeFriendRequest_result();
                          eval {
                            $self->{handler}->removeFriendRequest($args->direction, $args->midOrEMid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeFriendRequest', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeFriendRequest', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findAndAddContactsByUserid {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findAndAddContactsByUserid_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findAndAddContactsByUserid_result();
                          eval {
                            $result->{success} = $self->{handler}->findAndAddContactsByUserid($args->reqSeq, $args->userid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findAndAddContactsByUserid', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findAndAddContactsByUserid', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findContactByUserid {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findContactByUserid_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findContactByUserid_result();
                          eval {
                            $result->{success} = $self->{handler}->findContactByUserid($args->userid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findContactByUserid', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findContactByUserid', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findContactByUserTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findContactByUserTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findContactByUserTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->findContactByUserTicket($args->ticketIdWithTag);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findContactByUserTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findContactByUserTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findContactsByEmail {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findContactsByEmail_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findContactsByEmail_result();
                          eval {
                            $result->{success} = $self->{handler}->findContactsByEmail($args->emails);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findContactsByEmail', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findContactsByEmail', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findContactsByPhone {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findContactsByPhone_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findContactsByPhone_result();
                          eval {
                            $result->{success} = $self->{handler}->findContactsByPhone($args->phones);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findContactsByPhone', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findContactsByPhone', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findSnsIdUserStatus {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findSnsIdUserStatus_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findSnsIdUserStatus_result();
                          eval {
                            $result->{success} = $self->{handler}->findSnsIdUserStatus($args->snsIdType, $args->snsAccessToken, $args->udidHash);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findSnsIdUserStatus', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findSnsIdUserStatus', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_finishUpdateVerification {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_finishUpdateVerification_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_finishUpdateVerification_result();
                          eval {
                            $self->{handler}->finishUpdateVerification($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('finishUpdateVerification', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('finishUpdateVerification', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_generateUserTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_generateUserTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_generateUserTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->generateUserTicket($args->expirationTime, $args->maxUseCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('generateUserTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('generateUserTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_destroyMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_destroyMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_destroyMessage_result();
                          eval {
                            $self->{handler}->destroyMessage($args->seq, $args->chatId, $args->messageId, $args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('destroyMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('destroyMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getAcceptedProximityMatches {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getAcceptedProximityMatches_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getAcceptedProximityMatches_result();
                          eval {
                            $result->{success} = $self->{handler}->getAcceptedProximityMatches($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getAcceptedProximityMatches', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getAcceptedProximityMatches', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getActiveBuddySubscriberIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getActiveBuddySubscriberIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getActiveBuddySubscriberIds_result();
                          eval {
                            $result->{success} = $self->{handler}->getActiveBuddySubscriberIds();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getActiveBuddySubscriberIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getActiveBuddySubscriberIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getAllContactIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getAllContactIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getAllContactIds_result();
                          eval {
                            $result->{success} = $self->{handler}->getAllContactIds();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getAllContactIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getAllContactIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getAuthQrcode {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getAuthQrcode_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getAuthQrcode_result();
                          eval {
                            $result->{success} = $self->{handler}->getAuthQrcode($args->keepLoggedIn, $args->systemName);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getAuthQrcode', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getAuthQrcode', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getBlockedContactIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getBlockedContactIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getBlockedContactIds_result();
                          eval {
                            $result->{success} = $self->{handler}->getBlockedContactIds();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getBlockedContactIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getBlockedContactIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerWithPhoneNumber {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerWithPhoneNumber_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerWithPhoneNumber_result();
                          eval {
                            $result->{success} = $self->{handler}->registerWithPhoneNumber($args->sessionId, $args->migrationPincodeSessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerWithPhoneNumber', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerWithPhoneNumber', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerWithPhoneNumberAndPassword {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerWithPhoneNumberAndPassword_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerWithPhoneNumberAndPassword_result();
                          eval {
                            $result->{success} = $self->{handler}->registerWithPhoneNumberAndPassword($args->sessionId, $args->keynm, $args->encrypted);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerWithPhoneNumberAndPassword', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerWithPhoneNumberAndPassword', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getAnalyticsInfo {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getAnalyticsInfo_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getAnalyticsInfo_result();
                          eval {
                            $result->{success} = $self->{handler}->getAnalyticsInfo();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getAnalyticsInfo', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getAnalyticsInfo', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportClientStatistics {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportClientStatistics_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportClientStatistics_result();
                          eval {
                            $self->{handler}->reportClientStatistics($args->reqSeq, $args->category, $args->count);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportClientStatistics', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportClientStatistics', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_verifyPhoneNumberForLogin {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_verifyPhoneNumberForLogin_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_verifyPhoneNumberForLogin_result();
                          eval {
                            $result->{success} = $self->{handler}->verifyPhoneNumberForLogin($args->verifierFromPhone, $args->pinCodeForPhone, $args->verifierFromLogin);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('verifyPhoneNumberForLogin', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('verifyPhoneNumberForLogin', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_verifyPhoneNumber {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_verifyPhoneNumber_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_verifyPhoneNumber_result();
                          eval {
                            $result->{success} = $self->{handler}->verifyPhoneNumber($args->sessionId, $args->pinCode, $args->udidHash, $args->migrationPincodeSessionId, $args->oldUdidHash);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('verifyPhoneNumber', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('verifyPhoneNumber', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getBlockedContactIdsByRange {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getBlockedContactIdsByRange_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getBlockedContactIdsByRange_result();
                          eval {
                            $result->{success} = $self->{handler}->getBlockedContactIdsByRange($args->start, $args->count);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getBlockedContactIdsByRange', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getBlockedContactIdsByRange', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getBlockedRecommendationIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getBlockedRecommendationIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getBlockedRecommendationIds_result();
                          eval {
                            $result->{success} = $self->{handler}->getBlockedRecommendationIds();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getBlockedRecommendationIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getBlockedRecommendationIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getBuddyBlockerIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getBuddyBlockerIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getBuddyBlockerIds_result();
                          eval {
                            $result->{success} = $self->{handler}->getBuddyBlockerIds();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getBuddyBlockerIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getBuddyBlockerIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getBuddyLocation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getBuddyLocation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getBuddyLocation_result();
                          eval {
                            $result->{success} = $self->{handler}->getBuddyLocation($args->mid, $args->index);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getBuddyLocation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getBuddyLocation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getCompactContactsModifiedSince {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getCompactContactsModifiedSince_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getCompactContactsModifiedSince_result();
                          eval {
                            $result->{success} = $self->{handler}->getCompactContactsModifiedSince($args->timestamp);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getCompactContactsModifiedSince', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getCompactContactsModifiedSince', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getCompactGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getCompactGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getCompactGroup_result();
                          eval {
                            $result->{success} = $self->{handler}->getCompactGroup($args->groupId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getCompactGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getCompactGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getCompactRoom {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getCompactRoom_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getCompactRoom_result();
                          eval {
                            $result->{success} = $self->{handler}->getCompactRoom($args->roomId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getCompactRoom', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getCompactRoom', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getContact {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getContact_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getContact_result();
                          eval {
                            $result->{success} = $self->{handler}->getContact($args->id);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getContact', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getContact', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getContacts {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getContacts_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getContacts_result();
                          eval {
                            $result->{success} = $self->{handler}->getContacts($args->ids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getContacts', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getContacts', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getContactWithFriendRequestStatus {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getContactWithFriendRequestStatus_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getContactWithFriendRequestStatus_result();
                          eval {
                            $result->{success} = $self->{handler}->getContactWithFriendRequestStatus($args->id);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getContactWithFriendRequestStatus', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getContactWithFriendRequestStatus', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getCountryWithRequestIp {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getCountryWithRequestIp_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getCountryWithRequestIp_result();
                          eval {
                            $result->{success} = $self->{handler}->getCountryWithRequestIp();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getCountryWithRequestIp', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getCountryWithRequestIp', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getFavoriteMids {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getFavoriteMids_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getFavoriteMids_result();
                          eval {
                            $result->{success} = $self->{handler}->getFavoriteMids();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getFavoriteMids', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getFavoriteMids', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getGroup_result();
                          eval {
                            $result->{success} = $self->{handler}->getGroup($args->groupId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getGroupIdsInvited {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getGroupIdsInvited_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getGroupIdsInvited_result();
                          eval {
                            $result->{success} = $self->{handler}->getGroupIdsInvited();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getGroupIdsInvited', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getGroupIdsInvited', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getGroupIdsJoined {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getGroupIdsJoined_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getGroupIdsJoined_result();
                          eval {
                            $result->{success} = $self->{handler}->getGroupIdsJoined();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getGroupIdsJoined', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getGroupIdsJoined', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getGroups {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getGroups_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getGroups_result();
                          eval {
                            $result->{success} = $self->{handler}->getGroups($args->groupIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getGroups', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getGroups', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getHiddenContactMids {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getHiddenContactMids_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getHiddenContactMids_result();
                          eval {
                            $result->{success} = $self->{handler}->getHiddenContactMids();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getHiddenContactMids', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getHiddenContactMids', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getIdentityIdentifier {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getIdentityIdentifier_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getIdentityIdentifier_result();
                          eval {
                            $result->{success} = $self->{handler}->getIdentityIdentifier();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getIdentityIdentifier', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getIdentityIdentifier', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getLastAnnouncementIndex {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getLastAnnouncementIndex_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getLastAnnouncementIndex_result();
                          eval {
                            $result->{success} = $self->{handler}->getLastAnnouncementIndex();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getLastAnnouncementIndex', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getLastAnnouncementIndex', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getLastOpRevision {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getLastOpRevision_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getLastOpRevision_result();
                          eval {
                            $result->{success} = $self->{handler}->getLastOpRevision();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getLastOpRevision', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getLastOpRevision', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getSuggestRevisions {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getSuggestRevisions_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getSuggestRevisions_result();
                          eval {
                            $result->{success} = $self->{handler}->getSuggestRevisions();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getSuggestRevisions', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getSuggestRevisions', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getPreviousMessagesV2WithReadCount {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getPreviousMessagesV2WithReadCount_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getPreviousMessagesV2WithReadCount_result();
                          eval {
                            $result->{success} = $self->{handler}->getPreviousMessagesV2WithReadCount($args->messageBoxId, $args->endMessageId, $args->messagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getPreviousMessagesV2WithReadCount', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getPreviousMessagesV2WithReadCount', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBox {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBox_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBox_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBox($args->channelId, $args->messageBoxId, $args->lastMessagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBox', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBox', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxCompactWrapUp {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxCompactWrapUp_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxCompactWrapUp_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxCompactWrapUp($args->mid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxCompactWrapUp', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxCompactWrapUp', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxCompactWrapUpList {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxCompactWrapUpList_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxCompactWrapUpList_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxCompactWrapUpList($args->start, $args->messageBoxCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxCompactWrapUpList', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxCompactWrapUpList', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxList {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxList_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxList_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxList($args->channelId, $args->lastMessagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxList', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxList', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxListByStatus {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxListByStatus_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxListByStatus_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxListByStatus($args->channelId, $args->lastMessagesCount, $args->status);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxListByStatus', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxListByStatus', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxWrapUp {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxWrapUp_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxWrapUp_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxWrapUp($args->mid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxWrapUp', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxWrapUp', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxWrapUpList {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxWrapUpList_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxWrapUpList_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxWrapUpList($args->start, $args->messageBoxCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxWrapUpList', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxWrapUpList', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessagesBySequenceNumber {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessagesBySequenceNumber_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessagesBySequenceNumber_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessagesBySequenceNumber($args->channelId, $args->messageBoxId, $args->startSeq, $args->endSeq);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessagesBySequenceNumber', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessagesBySequenceNumber', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getNextMessages {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getNextMessages_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getNextMessages_result();
                          eval {
                            $result->{success} = $self->{handler}->getNextMessages($args->messageBoxId, $args->startSeq, $args->messagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getNextMessages', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getNextMessages', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getNotificationPolicy {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getNotificationPolicy_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getNotificationPolicy_result();
                          eval {
                            $result->{success} = $self->{handler}->getNotificationPolicy($args->carrier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getNotificationPolicy', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getNotificationPolicy', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getPreviousMessages {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getPreviousMessages_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getPreviousMessages_result();
                          eval {
                            $result->{success} = $self->{handler}->getPreviousMessages($args->messageBoxId, $args->endSeq, $args->messagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getPreviousMessages', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getPreviousMessages', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getProfile {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getProfile_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getProfile_result();
                          eval {
                            $result->{success} = $self->{handler}->getProfile();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getProfile', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getProfile', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getProximityMatchCandidateList {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getProximityMatchCandidateList_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getProximityMatchCandidateList_result();
                          eval {
                            $result->{success} = $self->{handler}->getProximityMatchCandidateList($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getProximityMatchCandidateList', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getProximityMatchCandidateList', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getProximityMatchCandidates {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getProximityMatchCandidates_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getProximityMatchCandidates_result();
                          eval {
                            $result->{success} = $self->{handler}->getProximityMatchCandidates($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getProximityMatchCandidates', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getProximityMatchCandidates', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getRecentMessages {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getRecentMessages_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getRecentMessages_result();
                          eval {
                            $result->{success} = $self->{handler}->getRecentMessages($args->messageBoxId, $args->messagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getRecentMessages', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getRecentMessages', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getRecommendationIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getRecommendationIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getRecommendationIds_result();
                          eval {
                            $result->{success} = $self->{handler}->getRecommendationIds();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getRecommendationIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getRecommendationIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getRoom {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getRoom_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getRoom_result();
                          eval {
                            $result->{success} = $self->{handler}->getRoom($args->roomId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getRoom', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getRoom', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getRSAKeyInfo {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getRSAKeyInfo_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getRSAKeyInfo_result();
                          eval {
                            $result->{success} = $self->{handler}->getRSAKeyInfo($args->provider);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getRSAKeyInfo', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getRSAKeyInfo', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getServerTime {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getServerTime_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getServerTime_result();
                          eval {
                            $result->{success} = $self->{handler}->getServerTime();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getServerTime', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getServerTime', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getSessions {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getSessions_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getSessions_result();
                          eval {
                            $result->{success} = $self->{handler}->getSessions();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getSessions', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getSessions', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getSettings {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getSettings_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getSettings_result();
                          eval {
                            $result->{success} = $self->{handler}->getSettings();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getSettings', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getGroupsV2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getGroupsV2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getGroupsV2_result();
                          eval {
                            $result->{success} = $self->{handler}->getGroupsV2($args->groupIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getGroupsV2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getGroupsV2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getSettingsAttributes {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getSettingsAttributes_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getSettingsAttributes_result();
                          eval {
                            $result->{success} = $self->{handler}->getSettingsAttributes($args->attrBitset);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getSettingsAttributes', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getSettingsAttributes', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getSystemConfiguration {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getSystemConfiguration_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getSystemConfiguration_result();
                          eval {
                            $result->{success} = $self->{handler}->getSystemConfiguration();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getSystemConfiguration', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getSystemConfiguration', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getUserTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getUserTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getUserTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->getUserTicket();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getUserTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getUserTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getWapInvitation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getWapInvitation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getWapInvitation_result();
                          eval {
                            $result->{success} = $self->{handler}->getWapInvitation($args->invitationHash);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getWapInvitation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getWapInvitation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_invalidateUserTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_invalidateUserTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_invalidateUserTicket_result();
                          eval {
                            $self->{handler}->invalidateUserTicket();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('invalidateUserTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('invalidateUserTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_inviteFriendsBySms {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_inviteFriendsBySms_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_inviteFriendsBySms_result();
                          eval {
                            $self->{handler}->inviteFriendsBySms($args->phoneNumberList);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('inviteFriendsBySms', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('inviteFriendsBySms', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_inviteIntoGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_inviteIntoGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_inviteIntoGroup_result();
                          eval {
                            $self->{handler}->inviteIntoGroup($args->reqSeq, $args->groupId, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('inviteIntoGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('inviteIntoGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_inviteIntoRoom {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_inviteIntoRoom_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_inviteIntoRoom_result();
                          eval {
                            $self->{handler}->inviteIntoRoom($args->reqSeq, $args->roomId, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('inviteIntoRoom', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('inviteIntoRoom', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_inviteViaEmail {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_inviteViaEmail_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_inviteViaEmail_result();
                          eval {
                            $self->{handler}->inviteViaEmail($args->reqSeq, $args->email, $args->name);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('inviteViaEmail', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('inviteViaEmail', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_isIdentityIdentifierAvailable {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_isIdentityIdentifierAvailable_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_isIdentityIdentifierAvailable_result();
                          eval {
                            $result->{success} = $self->{handler}->isIdentityIdentifierAvailable($args->provider, $args->identifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('isIdentityIdentifierAvailable', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('isIdentityIdentifierAvailable', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_isUseridAvailable {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_isUseridAvailable_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_isUseridAvailable_result();
                          eval {
                            $result->{success} = $self->{handler}->isUseridAvailable($args->userid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('isUseridAvailable', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('isUseridAvailable', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_kickoutFromGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_kickoutFromGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_kickoutFromGroup_result();
                          eval {
                            $self->{handler}->kickoutFromGroup($args->reqSeq, $args->groupId, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('kickoutFromGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('kickoutFromGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reissueGroupTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reissueGroupTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reissueGroupTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->reissueGroupTicket($args->groupMid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reissueGroupTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reissueGroupTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findGroupByTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findGroupByTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findGroupByTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->findGroupByTicket($args->ticketId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findGroupByTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findGroupByTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_leaveGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_leaveGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_leaveGroup_result();
                          eval {
                            $self->{handler}->leaveGroup($args->reqSeq, $args->groupId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('leaveGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('leaveGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_leaveRoom {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_leaveRoom_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_leaveRoom_result();
                          eval {
                            $self->{handler}->leaveRoom($args->reqSeq, $args->roomId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('leaveRoom', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('leaveRoom', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_loginWithIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_loginWithIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_loginWithIdentityCredential_result();
                          eval {
                            $result->{success} = $self->{handler}->loginWithIdentityCredential($args->identityProvider, $args->identifier, $args->password, $args->keepLoggedIn, $args->accessLocation, $args->systemName, $args->certificate);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('loginWithIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('loginWithIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_loginWithIdentityCredentialForCertificate {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_loginWithIdentityCredentialForCertificate_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_loginWithIdentityCredentialForCertificate_result();
                          eval {
                            $result->{success} = $self->{handler}->loginWithIdentityCredentialForCertificate($args->identityProvider, $args->identifier, $args->password, $args->keepLoggedIn, $args->accessLocation, $args->systemName, $args->certificate);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('loginWithIdentityCredentialForCertificate', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('loginWithIdentityCredentialForCertificate', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_loginWithVerifier {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_loginWithVerifier_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_loginWithVerifier_result();
                          eval {
                            $result->{success} = $self->{handler}->loginWithVerifier($args->verifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('loginWithVerifier', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('loginWithVerifier', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_loginWithVerifierForCerificate {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_loginWithVerifierForCerificate_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_loginWithVerifierForCerificate_result();
                          eval {
                            $result->{success} = $self->{handler}->loginWithVerifierForCerificate($args->verifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('loginWithVerifierForCerificate', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('loginWithVerifierForCerificate', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_loginWithVerifierForCertificate {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_loginWithVerifierForCertificate_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_loginWithVerifierForCertificate_result();
                          eval {
                            $result->{success} = $self->{handler}->loginWithVerifierForCertificate($args->verifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('loginWithVerifierForCertificate', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('loginWithVerifierForCertificate', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_logout {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_logout_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_logout_result();
                          eval {
                            $self->{handler}->logout();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('logout', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('logout', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_logoutSession {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_logoutSession_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_logoutSession_result();
                          eval {
                            $self->{handler}->logoutSession($args->tokenKey);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('logoutSession', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('logoutSession', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_noop {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_noop_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_noop_result();
                          eval {
                            $self->{handler}->noop();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('noop', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('noop', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifiedRedirect {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifiedRedirect_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifiedRedirect_result();
                          eval {
                            $self->{handler}->notifiedRedirect($args->paramMap);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifiedRedirect', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifiedRedirect', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifyBuddyOnAir {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifyBuddyOnAir_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifyBuddyOnAir_result();
                          eval {
                            $result->{success} = $self->{handler}->notifyBuddyOnAir($args->seq, $args->receiverMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifyBuddyOnAir', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifyBuddyOnAir', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifyIndividualEvent {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifyIndividualEvent_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifyIndividualEvent_result();
                          eval {
                            $self->{handler}->notifyIndividualEvent($args->notificationStatus, $args->receiverMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifyIndividualEvent', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifyIndividualEvent', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifyInstalled {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifyInstalled_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifyInstalled_result();
                          eval {
                            $self->{handler}->notifyInstalled($args->udidHash, $args->applicationTypeWithExtensions);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifyInstalled', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifyInstalled', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifyRegistrationComplete {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifyRegistrationComplete_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifyRegistrationComplete_result();
                          eval {
                            $self->{handler}->notifyRegistrationComplete($args->udidHash, $args->applicationTypeWithExtensions);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifyRegistrationComplete', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifyRegistrationComplete', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifySleep {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifySleep_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifySleep_result();
                          eval {
                            $self->{handler}->notifySleep($args->lastRev, $args->badge);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifySleep', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifySleep', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_notifyUpdated {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_notifyUpdated_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_notifyUpdated_result();
                          eval {
                            $self->{handler}->notifyUpdated($args->lastRev, $args->deviceInfo);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('notifyUpdated', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('notifyUpdated', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_openProximityMatch {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_openProximityMatch_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_openProximityMatch_result();
                          eval {
                            $result->{success} = $self->{handler}->openProximityMatch($args->location);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('openProximityMatch', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('openProximityMatch', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerBuddyUser {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerBuddyUser_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerBuddyUser_result();
                          eval {
                            $result->{success} = $self->{handler}->registerBuddyUser($args->buddyId, $args->registrarPassword);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerBuddyUser', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerBuddyUser', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerBuddyUserid {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerBuddyUserid_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerBuddyUserid_result();
                          eval {
                            $self->{handler}->registerBuddyUserid($args->seq, $args->userid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerBuddyUserid', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerBuddyUserid', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerDevice {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerDevice_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerDevice_result();
                          eval {
                            $result->{success} = $self->{handler}->registerDevice($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerDevice', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerDevice', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerDeviceWithIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerDeviceWithIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerDeviceWithIdentityCredential_result();
                          eval {
                            $result->{success} = $self->{handler}->registerDeviceWithIdentityCredential($args->sessionId, $args->provider, $args->identifier, $args->verifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerDeviceWithIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerDeviceWithIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerDeviceWithoutPhoneNumber {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerDeviceWithoutPhoneNumber_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerDeviceWithoutPhoneNumber_result();
                          eval {
                            $result->{success} = $self->{handler}->registerDeviceWithoutPhoneNumber($args->region, $args->udidHash, $args->deviceInfo);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerDeviceWithoutPhoneNumber', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerDeviceWithoutPhoneNumber', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerDeviceWithoutPhoneNumberWithIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result();
                          eval {
                            $result->{success} = $self->{handler}->registerDeviceWithoutPhoneNumberWithIdentityCredential($args->region, $args->udidHash, $args->deviceInfo, $args->provider, $args->identifier, $args->verifier, $args->mid, $args->migrationPincodeSessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerUserid {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerUserid_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerUserid_result();
                          eval {
                            $result->{success} = $self->{handler}->registerUserid($args->reqSeq, $args->userid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerUserid', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerUserid', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerWapDevice {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerWapDevice_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerWapDevice_result();
                          eval {
                            $result->{success} = $self->{handler}->registerWapDevice($args->invitationHash, $args->guidHash, $args->email, $args->deviceInfo);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerWapDevice', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerWapDevice', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerWithExistingSnsIdAndIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerWithExistingSnsIdAndIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerWithExistingSnsIdAndIdentityCredential_result();
                          eval {
                            $result->{success} = $self->{handler}->registerWithExistingSnsIdAndIdentityCredential($args->identityCredential, $args->region, $args->udidHash, $args->deviceInfo);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerWithSnsId {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerWithSnsId_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerWithSnsId_result();
                          eval {
                            $result->{success} = $self->{handler}->registerWithSnsId($args->snsIdType, $args->snsAccessToken, $args->region, $args->udidHash, $args->deviceInfo, $args->mid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerWithSnsId', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerWithSnsId', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerWithSnsIdAndIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerWithSnsIdAndIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerWithSnsIdAndIdentityCredential_result();
                          eval {
                            $result->{success} = $self->{handler}->registerWithSnsIdAndIdentityCredential($args->snsIdType, $args->snsAccessToken, $args->identityCredential, $args->region, $args->udidHash, $args->deviceInfo);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerWithSnsIdAndIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerWithSnsIdAndIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reissueDeviceCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reissueDeviceCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reissueDeviceCredential_result();
                          eval {
                            $result->{success} = $self->{handler}->reissueDeviceCredential();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reissueDeviceCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reissueDeviceCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reissueUserTicket {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reissueUserTicket_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reissueUserTicket_result();
                          eval {
                            $result->{success} = $self->{handler}->reissueUserTicket($args->expirationTime, $args->maxUseCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reissueUserTicket', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reissueUserTicket', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageReadRange {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageReadRange_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageReadRange_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageReadRange($args->chatIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageReadRange', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageReadRange', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_rejectGroupInvitation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_rejectGroupInvitation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_rejectGroupInvitation_result();
                          eval {
                            $self->{handler}->rejectGroupInvitation($args->reqSeq, $args->groupId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('rejectGroupInvitation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('rejectGroupInvitation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_releaseSession {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_releaseSession_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_releaseSession_result();
                          eval {
                            $self->{handler}->releaseSession();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('releaseSession', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('releaseSession', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeAllMessages {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeAllMessages_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeAllMessages_result();
                          eval {
                            $self->{handler}->removeAllMessages($args->seq, $args->lastMessageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeAllMessages', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeAllMessages', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeBuddyLocation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeBuddyLocation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeBuddyLocation_result();
                          eval {
                            $self->{handler}->removeBuddyLocation($args->mid, $args->index);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeBuddyLocation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeBuddyLocation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeMessage_result();
                          eval {
                            $result->{success} = $self->{handler}->removeMessage($args->messageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_makeUserAddMyselfAsContact {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_makeUserAddMyselfAsContact_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_makeUserAddMyselfAsContact_result();
                          eval {
                            $result->{success} = $self->{handler}->makeUserAddMyselfAsContact($args->contactOwnerMid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('makeUserAddMyselfAsContact', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('makeUserAddMyselfAsContact', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeMessageFromMyHome {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeMessageFromMyHome_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeMessageFromMyHome_result();
                          eval {
                            $result->{success} = $self->{handler}->removeMessageFromMyHome($args->messageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeMessageFromMyHome', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeMessageFromMyHome', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeSnsId {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeSnsId_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeSnsId_result();
                          eval {
                            $result->{success} = $self->{handler}->removeSnsId($args->snsIdType);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeSnsId', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeSnsId', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_report {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_report_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_report_result();
                          eval {
                            $self->{handler}->report($args->syncOpRevision, $args->category, $args->report);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('report', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('report', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportContacts {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportContacts_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportContacts_result();
                          eval {
                            $result->{success} = $self->{handler}->reportContacts($args->syncOpRevision, $args->category, $args->contactReports, $args->actionType);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportContacts', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportContacts', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportGroups {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportGroups_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportGroups_result();
                          eval {
                            $self->{handler}->reportGroups($args->syncOpRevision, $args->groups);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportGroups', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportGroups', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportProfile {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportProfile_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportProfile_result();
                          eval {
                            $self->{handler}->reportProfile($args->syncOpRevision, $args->profile);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportProfile', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportProfile', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportRooms {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportRooms_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportRooms_result();
                          eval {
                            $self->{handler}->reportRooms($args->syncOpRevision, $args->rooms);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportRooms', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportRooms', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findAndAddContactByMetaTag {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findAndAddContactByMetaTag_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findAndAddContactByMetaTag_result();
                          eval {
                            $result->{success} = $self->{handler}->findAndAddContactByMetaTag($args->reqSeq, $args->userid, $args->reference);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findAndAddContactByMetaTag', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findAndAddContactByMetaTag', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportSettings {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportSettings_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportSettings_result();
                          eval {
                            $self->{handler}->reportSettings($args->syncOpRevision, $args->settings);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportSettings', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportSpam {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportSpam_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportSpam_result();
                          eval {
                            $self->{handler}->reportSpam($args->chatMid, $args->memberMids, $args->spammerReasons, $args->senderMids, $args->spamMessageIds, $args->spamMessages);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportSpam', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportSpam', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_reportSpammer {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_reportSpammer_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_reportSpammer_result();
                          eval {
                            $self->{handler}->reportSpammer($args->spammerMid, $args->spammerReasons, $args->spamMessageIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('reportSpammer', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('reportSpammer', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_requestAccountPasswordReset {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_requestAccountPasswordReset_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_requestAccountPasswordReset_result();
                          eval {
                            $self->{handler}->requestAccountPasswordReset($args->provider, $args->identifier, $args->locale);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('requestAccountPasswordReset', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('requestAccountPasswordReset', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_requestEmailConfirmation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_requestEmailConfirmation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_requestEmailConfirmation_result();
                          eval {
                            $result->{success} = $self->{handler}->requestEmailConfirmation($args->emailConfirmation);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('requestEmailConfirmation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('requestEmailConfirmation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_requestIdentityUnbind {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_requestIdentityUnbind_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_requestIdentityUnbind_result();
                          eval {
                            $self->{handler}->requestIdentityUnbind($args->provider, $args->identifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('requestIdentityUnbind', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('requestIdentityUnbind', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_resendEmailConfirmation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_resendEmailConfirmation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_resendEmailConfirmation_result();
                          eval {
                            $result->{success} = $self->{handler}->resendEmailConfirmation($args->verifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('resendEmailConfirmation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('resendEmailConfirmation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_resendPinCode {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_resendPinCode_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_resendPinCode_result();
                          eval {
                            $self->{handler}->resendPinCode($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('resendPinCode', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('resendPinCode', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_resendPinCodeBySMS {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_resendPinCodeBySMS_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_resendPinCodeBySMS_result();
                          eval {
                            $self->{handler}->resendPinCodeBySMS($args->sessionId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('resendPinCodeBySMS', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('resendPinCodeBySMS', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendChatChecked {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendChatChecked_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendChatChecked_result();
                          eval {
                            $self->{handler}->sendChatChecked($args->seq, $args->consumer, $args->lastMessageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendChatChecked', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendChatChecked', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendMessageAwaitCommit {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendMessageAwaitCommit_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendMessageAwaitCommit_result();
                          eval {
                            $result->{success} = $self->{handler}->sendMessageAwaitCommit($args->seq, $args->message);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendMessageAwaitCommit', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendMessageAwaitCommit', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendChatRemoved {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendChatRemoved_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendChatRemoved_result();
                          eval {
                            $self->{handler}->sendChatRemoved($args->seq, $args->consumer, $args->lastMessageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendChatRemoved', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendChatRemoved', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendContentPreviewUpdated {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendContentPreviewUpdated_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendContentPreviewUpdated_result();
                          eval {
                            $result->{success} = $self->{handler}->sendContentPreviewUpdated($args->esq, $args->messageId, $args->receiverMids);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendContentPreviewUpdated', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendContentPreviewUpdated', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendContentReceipt {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendContentReceipt_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendContentReceipt_result();
                          eval {
                            $self->{handler}->sendContentReceipt($args->seq, $args->consumer, $args->messageId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendContentReceipt', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendContentReceipt', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendDummyPush {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendDummyPush_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendDummyPush_result();
                          eval {
                            $self->{handler}->sendDummyPush();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendDummyPush', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendDummyPush', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_removeE2EEPublicKey {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_removeE2EEPublicKey_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_removeE2EEPublicKey_result();
                          eval {
                            $self->{handler}->removeE2EEPublicKey($args->publicKey);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('removeE2EEPublicKey', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('removeE2EEPublicKey', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_negotiateE2EEPublicKey {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_negotiateE2EEPublicKey_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_negotiateE2EEPublicKey_result();
                          eval {
                            $result->{success} = $self->{handler}->negotiateE2EEPublicKey($args->mid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('negotiateE2EEPublicKey', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('negotiateE2EEPublicKey', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getE2EEPublicKey {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getE2EEPublicKey_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getE2EEPublicKey_result();
                          eval {
                            $result->{success} = $self->{handler}->getE2EEPublicKey($args->mid, $args->version, $args->keyId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getE2EEPublicKey', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getE2EEPublicKey', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_requestE2EEKeyExchange {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_requestE2EEKeyExchange_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_requestE2EEKeyExchange_result();
                          eval {
                            $self->{handler}->requestE2EEKeyExchange($args->reqSeq, $args->temporalPublicKey, $args->publicKey, $args->verifier);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('requestE2EEKeyExchange', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('requestE2EEKeyExchange', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getLastE2EEPublicKeys {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getLastE2EEPublicKeys_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getLastE2EEPublicKeys_result();
                          eval {
                            $result->{success} = $self->{handler}->getLastE2EEPublicKeys($args->chatMid);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getLastE2EEPublicKeys', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getLastE2EEPublicKeys', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_registerE2EEPublicKey {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_registerE2EEPublicKey_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_registerE2EEPublicKey_result();
                          eval {
                            $result->{success} = $self->{handler}->registerE2EEPublicKey($args->reqSeq, $args->publicKey);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('registerE2EEPublicKey', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('registerE2EEPublicKey', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getE2EEPublicKeys {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getE2EEPublicKeys_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getE2EEPublicKeys_result();
                          eval {
                            $result->{success} = $self->{handler}->getE2EEPublicKeys();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getE2EEPublicKeys', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getE2EEPublicKeys', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getE2EEPublicKeysEx {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getE2EEPublicKeysEx_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getE2EEPublicKeysEx_result();
                          eval {
                            $result->{success} = $self->{handler}->getE2EEPublicKeysEx($args->ignoreE2EEStatus);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getE2EEPublicKeysEx', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getE2EEPublicKeysEx', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getReadMessageOpsInBulk {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getReadMessageOpsInBulk_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getReadMessageOpsInBulk_result();
                          eval {
                            $result->{success} = $self->{handler}->getReadMessageOpsInBulk($args->chatIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getReadMessageOpsInBulk', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getReadMessageOpsInBulk', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendEvent {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendEvent_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendEvent_result();
                          eval {
                            $result->{success} = $self->{handler}->sendEvent($args->seq, $args->message);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendEvent', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendEvent', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendMessage_result();
                          eval {
                            $result->{success} = $self->{handler}->sendMessage($args->seq, $args->message);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendMessageIgnored {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendMessageIgnored_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendMessageIgnored_result();
                          eval {
                            $self->{handler}->sendMessageIgnored($args->seq, $args->consumer, $args->messageIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendMessageIgnored', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendMessageIgnored', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendMessageReceipt {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendMessageReceipt_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendMessageReceipt_result();
                          eval {
                            $self->{handler}->sendMessageReceipt($args->seq, $args->consumer, $args->messageIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendMessageReceipt', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendMessageReceipt', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_findContactByMetaTag {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_findContactByMetaTag_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_findContactByMetaTag_result();
                          eval {
                            $result->{success} = $self->{handler}->findContactByMetaTag($args->userid, $args->reference);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('findContactByMetaTag', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('findContactByMetaTag', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_sendMessageToMyHome {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_sendMessageToMyHome_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_sendMessageToMyHome_result();
                          eval {
                            $result->{success} = $self->{handler}->sendMessageToMyHome($args->seq, $args->message);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('sendMessageToMyHome', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('sendMessageToMyHome', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_setBuddyLocation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_setBuddyLocation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_setBuddyLocation_result();
                          eval {
                            $self->{handler}->setBuddyLocation($args->mid, $args->index, $args->location);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('setBuddyLocation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('setBuddyLocation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_setIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_setIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_setIdentityCredential_result();
                          eval {
                            $self->{handler}->setIdentityCredential($args->identifier, $args->verifier, $args->provider);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('setIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('setIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_setNotificationsEnabled {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_setNotificationsEnabled_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_setNotificationsEnabled_result();
                          eval {
                            $self->{handler}->setNotificationsEnabled($args->reqSeq, $args->type, $args->target, $args->enablement);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('setNotificationsEnabled', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('setNotificationsEnabled', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_startUpdateVerification {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_startUpdateVerification_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_startUpdateVerification_result();
                          eval {
                            $result->{success} = $self->{handler}->startUpdateVerification($args->region, $args->carrier, $args->phone, $args->udidHash, $args->deviceInfo, $args->networkCode, $args->locale);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('startUpdateVerification', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('startUpdateVerification', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_startVerification {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_startVerification_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_startVerification_result();
                          eval {
                            $result->{success} = $self->{handler}->startVerification($args->region, $args->carrier, $args->phone, $args->udidHash, $args->deviceInfo, $args->networkCode, $args->mid, $args->locale, $args->simInfo, $args->oldUdidHash);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('startVerification', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('startVerification', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateGroupPreferenceAttribute {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateGroupPreferenceAttribute_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateGroupPreferenceAttribute_result();
                          eval {
                            $self->{handler}->updateGroupPreferenceAttribute($args->reqSeq, $args->groupMid, $args->updatedAttrs);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateGroupPreferenceAttribute', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateGroupPreferenceAttribute', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_createRoomV2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_createRoomV2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_createRoomV2_result();
                          eval {
                            $result->{success} = $self->{handler}->createRoomV2($args->reqSeq, $args->contactIds);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('createRoomV2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('createRoomV2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_storeUpdateProfileAttribute {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_storeUpdateProfileAttribute_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_storeUpdateProfileAttribute_result();
                          eval {
                            $self->{handler}->storeUpdateProfileAttribute($args->seq, $args->profileAttribute, $args->value);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('storeUpdateProfileAttribute', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('storeUpdateProfileAttribute', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_syncContactBySnsIds {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_syncContactBySnsIds_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_syncContactBySnsIds_result();
                          eval {
                            $result->{success} = $self->{handler}->syncContactBySnsIds($args->reqSeq, $args->modifications);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('syncContactBySnsIds', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('syncContactBySnsIds', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_syncContacts {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_syncContacts_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_syncContacts_result();
                          eval {
                            $result->{success} = $self->{handler}->syncContacts($args->reqSeq, $args->localContacts);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('syncContacts', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('syncContacts', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_trySendMessage {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_trySendMessage_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_trySendMessage_result();
                          eval {
                            $result->{success} = $self->{handler}->trySendMessage($args->seq, $args->message);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('trySendMessage', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('trySendMessage', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getNextMessagesV2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getNextMessagesV2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getNextMessagesV2_result();
                          eval {
                            $result->{success} = $self->{handler}->getNextMessagesV2($args->messageBoxId, $args->startMessageId, $args->messagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getNextMessagesV2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getNextMessagesV2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getMessageBoxCompactWrapUpV2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getMessageBoxCompactWrapUpV2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getMessageBoxCompactWrapUpV2_result();
                          eval {
                            $result->{success} = $self->{handler}->getMessageBoxCompactWrapUpV2($args->messageBoxId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getMessageBoxCompactWrapUpV2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getMessageBoxCompactWrapUpV2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getRecentMessagesV2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_getRecentMessagesV2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_getRecentMessagesV2_result();
                          eval {
                            $result->{success} = $self->{handler}->getRecentMessagesV2($args->messageBoxId, $args->messagesCount);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('getRecentMessagesV2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('getRecentMessagesV2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_validateContactsOnBot {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_validateContactsOnBot_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_validateContactsOnBot_result();
                          eval {
                            $result->{success} = $self->{handler}->validateContactsOnBot($args->contacts);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('validateContactsOnBot', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('validateContactsOnBot', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_tryFriendRequest {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_tryFriendRequest_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_tryFriendRequest_result();
                          eval {
                            $self->{handler}->tryFriendRequest($args->midOrEMid, $args->method, $args->friendRequestParams);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('tryFriendRequest', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('tryFriendRequest', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_unblockContact {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_unblockContact_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_unblockContact_result();
                          eval {
                            $self->{handler}->unblockContact($args->reqSeq, $args->id);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('unblockContact', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('unblockContact', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_unblockRecommendation {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_unblockRecommendation_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_unblockRecommendation_result();
                          eval {
                            $self->{handler}->unblockRecommendation($args->reqSeq, $args->id);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('unblockRecommendation', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('unblockRecommendation', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_unregisterUserAndDevice {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_unregisterUserAndDevice_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_unregisterUserAndDevice_result();
                          eval {
                            $result->{success} = $self->{handler}->unregisterUserAndDevice();
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('unregisterUserAndDevice', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('unregisterUserAndDevice', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateApnsDeviceToken {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateApnsDeviceToken_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateApnsDeviceToken_result();
                          eval {
                            $self->{handler}->updateApnsDeviceToken($args->apnsDeviceToken);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateApnsDeviceToken', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateApnsDeviceToken', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateBuddySetting {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateBuddySetting_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateBuddySetting_result();
                          eval {
                            $self->{handler}->updateBuddySetting($args->key, $args->value);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateBuddySetting', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateBuddySetting', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateC2DMRegistrationId {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateC2DMRegistrationId_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateC2DMRegistrationId_result();
                          eval {
                            $self->{handler}->updateC2DMRegistrationId($args->registrationId);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateC2DMRegistrationId', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateC2DMRegistrationId', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateContactSetting {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateContactSetting_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateContactSetting_result();
                          eval {
                            $self->{handler}->updateContactSetting($args->reqSeq, $args->mid, $args->flag, $args->value);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateContactSetting', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateContactSetting', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateCustomModeSettings {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateCustomModeSettings_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateCustomModeSettings_result();
                          eval {
                            $self->{handler}->updateCustomModeSettings($args->customMode, $args->paramMap);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateCustomModeSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateCustomModeSettings', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateDeviceInfo {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateDeviceInfo_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateDeviceInfo_result();
                          eval {
                            $self->{handler}->updateDeviceInfo($args->deviceUid, $args->deviceInfo);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateDeviceInfo', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateDeviceInfo', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateGroup {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateGroup_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateGroup_result();
                          eval {
                            $self->{handler}->updateGroup($args->reqSeq, $args->group);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateGroup', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateGroup', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateNotificationToken {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateNotificationToken_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateNotificationToken_result();
                          eval {
                            $self->{handler}->updateNotificationToken($args->type, $args->token);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateNotificationToken', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateNotificationToken', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateNotificationTokenWithBytes {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateNotificationTokenWithBytes_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateNotificationTokenWithBytes_result();
                          eval {
                            $self->{handler}->updateNotificationTokenWithBytes($args->type, $args->token);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateNotificationTokenWithBytes', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateNotificationTokenWithBytes', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateProfile {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateProfile_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateProfile_result();
                          eval {
                            $self->{handler}->updateProfile($args->reqSeq, $args->profile);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateProfile', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateProfile', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateProfileAttribute {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateProfileAttribute_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateProfileAttribute_result();
                          eval {
                            $self->{handler}->updateProfileAttribute($args->reqSeq, $args->attr, $args->value);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateProfileAttribute', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateProfileAttribute', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateProfileAttributes {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateProfileAttributes_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateProfileAttributes_result();
                          $self->{handler}->updateProfileAttributes($args->reqSeq, $args->request);
                          $output->writeMessageBegin('updateProfileAttributes', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateRegion {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateRegion_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateRegion_result();
                          eval {
                            $self->{handler}->updateRegion($args->region);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateRegion', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateRegion', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateSettings {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateSettings_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateSettings_result();
                          eval {
                            $self->{handler}->updateSettings($args->reqSeq, $args->settings);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateSettings', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateSettings2 {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateSettings2_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateSettings2_result();
                          eval {
                            $result->{success} = $self->{handler}->updateSettings2($args->reqSeq, $args->settings);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateSettings2', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateSettings2', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateSettingsAttribute {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateSettingsAttribute_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateSettingsAttribute_result();
                          eval {
                            $self->{handler}->updateSettingsAttribute($args->reqSeq, $args->attr, $args->value);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateSettingsAttribute', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateSettingsAttribute', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_updateSettingsAttributes {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_updateSettingsAttributes_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_updateSettingsAttributes_result();
                          eval {
                            $result->{success} = $self->{handler}->updateSettingsAttributes($args->reqSeq, $args->attrBitset, $args->settings);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('updateSettingsAttributes', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('updateSettingsAttributes', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_verifyIdentityCredential {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_verifyIdentityCredential_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_verifyIdentityCredential_result();
                          eval {
                            $self->{handler}->verifyIdentityCredential($args->identityProvider, $args->identifier, $args->password);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('verifyIdentityCredential', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('verifyIdentityCredential', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_verifyIdentityCredentialWithResult {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_verifyIdentityCredentialWithResult_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_verifyIdentityCredentialWithResult_result();
                          eval {
                            $result->{success} = $self->{handler}->verifyIdentityCredentialWithResult($args->identityCredential);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('verifyIdentityCredentialWithResult', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('verifyIdentityCredentialWithResult', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_verifyPhone {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_verifyPhone_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_verifyPhone_result();
                          eval {
                            $result->{success} = $self->{handler}->verifyPhone($args->sessionId, $args->pinCode, $args->udidHash);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('verifyPhone', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('verifyPhone', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_verifyQrcode {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new TalkService_verifyQrcode_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new TalkService_verifyQrcode_result();
                          eval {
                            $result->{success} = $self->{handler}->verifyQrcode($args->verifier, $args->pinCode);
                          }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                            $result->{e} = $@;
                            $@ = undef;
                          }
                          if ($@) {
                            $@ =~ s/^\s+|\s+$//g;
                            my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                            $output->writeMessageBegin('verifyQrcode', Thrift::TMessageType::EXCEPTION, $seqid);
                            $err->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            $@ = undef;
                            return;
                          }
                          $output->writeMessageBegin('verifyQrcode', Thrift::TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

1;
