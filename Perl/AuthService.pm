#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Types;


# HELPER FUNCTIONS AND STRUCTURES

package AuthService_normalizePhoneNumber_args;
use base qw(Class::Accessor);
AuthService_normalizePhoneNumber_args->mk_accessors( qw( countryCode phoneNumber countryCodeHint ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{countryCode} = undef;
                              $self->{phoneNumber} = undef;
                              $self->{countryCodeHint} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{countryCode}) {
                                  $self->{countryCode} = $vals->{countryCode};
                                }
                                if (defined $vals->{phoneNumber}) {
                                  $self->{phoneNumber} = $vals->{phoneNumber};
                                }
                                if (defined $vals->{countryCodeHint}) {
                                  $self->{countryCodeHint} = $vals->{countryCodeHint};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_normalizePhoneNumber_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{countryCode});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^3$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{phoneNumber});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^4$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{countryCodeHint});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_normalizePhoneNumber_args');
                              if (defined $self->{countryCode}) {
                                $xfer += $output->writeFieldBegin('countryCode', Thrift::TType::STRING, 2);
                                $xfer += $output->writeString($self->{countryCode});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{phoneNumber}) {
                                $xfer += $output->writeFieldBegin('phoneNumber', Thrift::TType::STRING, 3);
                                $xfer += $output->writeString($self->{phoneNumber});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{countryCodeHint}) {
                                $xfer += $output->writeFieldBegin('countryCodeHint', Thrift::TType::STRING, 4);
                                $xfer += $output->writeString($self->{countryCodeHint});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_normalizePhoneNumber_result;
use base qw(Class::Accessor);
AuthService_normalizePhoneNumber_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_normalizePhoneNumber_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{success});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_normalizePhoneNumber_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                                $xfer += $output->writeString($self->{success});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_respondE2EELoginRequest_args;
use base qw(Class::Accessor);
AuthService_respondE2EELoginRequest_args->mk_accessors( qw( verifier publicKey encryptedKeyChain hashKeyChain errorCode ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{verifier} = undef;
                              $self->{publicKey} = undef;
                              $self->{encryptedKeyChain} = undef;
                              $self->{hashKeyChain} = undef;
                              $self->{errorCode} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{verifier}) {
                                  $self->{verifier} = $vals->{verifier};
                                }
                                if (defined $vals->{publicKey}) {
                                  $self->{publicKey} = $vals->{publicKey};
                                }
                                if (defined $vals->{encryptedKeyChain}) {
                                  $self->{encryptedKeyChain} = $vals->{encryptedKeyChain};
                                }
                                if (defined $vals->{hashKeyChain}) {
                                  $self->{hashKeyChain} = $vals->{hashKeyChain};
                                }
                                if (defined $vals->{errorCode}) {
                                  $self->{errorCode} = $vals->{errorCode};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_respondE2EELoginRequest_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{verifier});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{publicKey} = E2EEPublicKey->new();
                                    $xfer += $self->{publicKey}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^3$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{encryptedKeyChain});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^4$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{hashKeyChain});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^5$/ && do{                                  if ($ftype == Thrift::TType::I32) {
                                    $xfer += $input->readI32(\$self->{errorCode});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_respondE2EELoginRequest_args');
                              if (defined $self->{verifier}) {
                                $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 1);
                                $xfer += $output->writeString($self->{verifier});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{publicKey}) {
                                $xfer += $output->writeFieldBegin('publicKey', Thrift::TType::STRUCT, 2);
                                $xfer += $self->{publicKey}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{encryptedKeyChain}) {
                                $xfer += $output->writeFieldBegin('encryptedKeyChain', Thrift::TType::STRING, 3);
                                $xfer += $output->writeString($self->{encryptedKeyChain});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{hashKeyChain}) {
                                $xfer += $output->writeFieldBegin('hashKeyChain', Thrift::TType::STRING, 4);
                                $xfer += $output->writeString($self->{hashKeyChain});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{errorCode}) {
                                $xfer += $output->writeFieldBegin('errorCode', Thrift::TType::I32, 5);
                                $xfer += $output->writeI32($self->{errorCode});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_respondE2EELoginRequest_result;
use base qw(Class::Accessor);
AuthService_respondE2EELoginRequest_result->mk_accessors( qw( ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_respondE2EELoginRequest_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_respondE2EELoginRequest_result');
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_confirmE2EELogin_args;
use base qw(Class::Accessor);
AuthService_confirmE2EELogin_args->mk_accessors( qw( verifier deviceSecret ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{verifier} = undef;
                              $self->{deviceSecret} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{verifier}) {
                                  $self->{verifier} = $vals->{verifier};
                                }
                                if (defined $vals->{deviceSecret}) {
                                  $self->{deviceSecret} = $vals->{deviceSecret};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_confirmE2EELogin_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{verifier});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{deviceSecret});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_confirmE2EELogin_args');
                              if (defined $self->{verifier}) {
                                $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 1);
                                $xfer += $output->writeString($self->{verifier});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{deviceSecret}) {
                                $xfer += $output->writeFieldBegin('deviceSecret', Thrift::TType::STRING, 2);
                                $xfer += $output->writeString($self->{deviceSecret});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_confirmE2EELogin_result;
use base qw(Class::Accessor);
AuthService_confirmE2EELogin_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_confirmE2EELogin_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{success});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_confirmE2EELogin_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                                $xfer += $output->writeString($self->{success});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_logoutZ_args;
use base qw(Class::Accessor);

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_logoutZ_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_logoutZ_args');
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_logoutZ_result;
use base qw(Class::Accessor);
AuthService_logoutZ_result->mk_accessors( qw( ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_logoutZ_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_logoutZ_result');
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_loginZ_args;
use base qw(Class::Accessor);
AuthService_loginZ_args->mk_accessors( qw( loginRequest ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{loginRequest} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{loginRequest}) {
                                  $self->{loginRequest} = $vals->{loginRequest};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_loginZ_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{loginRequest} = LoginRequest->new();
                                    $xfer += $self->{loginRequest}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_loginZ_args');
                              if (defined $self->{loginRequest}) {
                                $xfer += $output->writeFieldBegin('loginRequest', Thrift::TType::STRUCT, 2);
                                $xfer += $self->{loginRequest}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_loginZ_result;
use base qw(Class::Accessor);
AuthService_loginZ_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_loginZ_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{success} = LoginResult->new();
                                    $xfer += $self->{success}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_loginZ_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                                $xfer += $self->{success}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_issueTokenForAccountMigrationSettings_args;
use base qw(Class::Accessor);
AuthService_issueTokenForAccountMigrationSettings_args->mk_accessors( qw( enforce ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{enforce} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{enforce}) {
                                  $self->{enforce} = $vals->{enforce};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_issueTokenForAccountMigrationSettings_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::BOOL) {
                                    $xfer += $input->readBool(\$self->{enforce});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_issueTokenForAccountMigrationSettings_args');
                              if (defined $self->{enforce}) {
                                $xfer += $output->writeFieldBegin('enforce', Thrift::TType::BOOL, 2);
                                $xfer += $output->writeBool($self->{enforce});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_issueTokenForAccountMigrationSettings_result;
use base qw(Class::Accessor);
AuthService_issueTokenForAccountMigrationSettings_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_issueTokenForAccountMigrationSettings_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{success} = SecurityCenterResult->new();
                                    $xfer += $self->{success}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_issueTokenForAccountMigrationSettings_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                                $xfer += $self->{success}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_issueTokenForAccountMigration_args;
use base qw(Class::Accessor);
AuthService_issueTokenForAccountMigration_args->mk_accessors( qw( migrationSessionId ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{migrationSessionId} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{migrationSessionId}) {
                                  $self->{migrationSessionId} = $vals->{migrationSessionId};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_issueTokenForAccountMigration_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{migrationSessionId});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_issueTokenForAccountMigration_args');
                              if (defined $self->{migrationSessionId}) {
                                $xfer += $output->writeFieldBegin('migrationSessionId', Thrift::TType::STRING, 2);
                                $xfer += $output->writeString($self->{migrationSessionId});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_issueTokenForAccountMigration_result;
use base qw(Class::Accessor);
AuthService_issueTokenForAccountMigration_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_issueTokenForAccountMigration_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{success} = SecurityCenterResult->new();
                                    $xfer += $self->{success}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_issueTokenForAccountMigration_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
                                $xfer += $self->{success}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_verifyQrcodeWithE2EE_args;
use base qw(Class::Accessor);
AuthService_verifyQrcodeWithE2EE_args->mk_accessors( qw( verifier pinCode errorCode publicKey encryptedKeyChain hashKeyChain ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{verifier} = undef;
                              $self->{pinCode} = undef;
                              $self->{errorCode} = undef;
                              $self->{publicKey} = undef;
                              $self->{encryptedKeyChain} = undef;
                              $self->{hashKeyChain} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{verifier}) {
                                  $self->{verifier} = $vals->{verifier};
                                }
                                if (defined $vals->{pinCode}) {
                                  $self->{pinCode} = $vals->{pinCode};
                                }
                                if (defined $vals->{errorCode}) {
                                  $self->{errorCode} = $vals->{errorCode};
                                }
                                if (defined $vals->{publicKey}) {
                                  $self->{publicKey} = $vals->{publicKey};
                                }
                                if (defined $vals->{encryptedKeyChain}) {
                                  $self->{encryptedKeyChain} = $vals->{encryptedKeyChain};
                                }
                                if (defined $vals->{hashKeyChain}) {
                                  $self->{hashKeyChain} = $vals->{hashKeyChain};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_verifyQrcodeWithE2EE_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^2$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{verifier});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^3$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{pinCode});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^4$/ && do{                                  if ($ftype == Thrift::TType::I32) {
                                    $xfer += $input->readI32(\$self->{errorCode});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^5$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{publicKey} = E2EEPublicKey->new();
                                    $xfer += $self->{publicKey}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^6$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{encryptedKeyChain});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^7$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{hashKeyChain});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_verifyQrcodeWithE2EE_args');
                              if (defined $self->{verifier}) {
                                $xfer += $output->writeFieldBegin('verifier', Thrift::TType::STRING, 2);
                                $xfer += $output->writeString($self->{verifier});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{pinCode}) {
                                $xfer += $output->writeFieldBegin('pinCode', Thrift::TType::STRING, 3);
                                $xfer += $output->writeString($self->{pinCode});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{errorCode}) {
                                $xfer += $output->writeFieldBegin('errorCode', Thrift::TType::I32, 4);
                                $xfer += $output->writeI32($self->{errorCode});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{publicKey}) {
                                $xfer += $output->writeFieldBegin('publicKey', Thrift::TType::STRUCT, 5);
                                $xfer += $self->{publicKey}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{encryptedKeyChain}) {
                                $xfer += $output->writeFieldBegin('encryptedKeyChain', Thrift::TType::STRING, 6);
                                $xfer += $output->writeString($self->{encryptedKeyChain});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{hashKeyChain}) {
                                $xfer += $output->writeFieldBegin('hashKeyChain', Thrift::TType::STRING, 7);
                                $xfer += $output->writeString($self->{hashKeyChain});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthService_verifyQrcodeWithE2EE_result;
use base qw(Class::Accessor);
AuthService_verifyQrcodeWithE2EE_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              $self->{e} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                                if (defined $vals->{e}) {
                                  $self->{e} = $vals->{e};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'AuthService_verifyQrcodeWithE2EE_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == Thrift::TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == Thrift::TType::STRING) {
                                    $xfer += $input->readString(\$self->{success});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                  /^1$/ && do{                                  if ($ftype == Thrift::TType::STRUCT) {
                                    $self->{e} = TalkException->new();
                                    $xfer += $self->{e}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('AuthService_verifyQrcodeWithE2EE_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
                                $xfer += $output->writeString($self->{success});
                                $xfer += $output->writeFieldEnd();
                              }
                              if (defined $self->{e}) {
                                $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
                                $xfer += $self->{e}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package AuthServiceIf;

use strict;


sub normalizePhoneNumber{
  my $self = shift;
  my $countryCode = shift;
  my $phoneNumber = shift;
  my $countryCodeHint = shift;

  die 'implement interface';
}

sub respondE2EELoginRequest{
  my $self = shift;
  my $verifier = shift;
  my $publicKey = shift;
  my $encryptedKeyChain = shift;
  my $hashKeyChain = shift;
  my $errorCode = shift;

  die 'implement interface';
}

sub confirmE2EELogin{
  my $self = shift;
  my $verifier = shift;
  my $deviceSecret = shift;

  die 'implement interface';
}

sub logoutZ{
  my $self = shift;

  die 'implement interface';
}

sub loginZ{
  my $self = shift;
  my $loginRequest = shift;

  die 'implement interface';
}

sub issueTokenForAccountMigrationSettings{
  my $self = shift;
  my $enforce = shift;

  die 'implement interface';
}

sub issueTokenForAccountMigration{
  my $self = shift;
  my $migrationSessionId = shift;

  die 'implement interface';
}

sub verifyQrcodeWithE2EE{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;
  my $errorCode = shift;
  my $publicKey = shift;
  my $encryptedKeyChain = shift;
  my $hashKeyChain = shift;

  die 'implement interface';
}

package AuthServiceRest;

use strict;


sub new {
                              my ($classname, $impl) = @_;
                              my $self     ={ impl => $impl };

                              return bless($self,$classname);
}

sub normalizePhoneNumber{
                              my ($self, $request) = @_;

                              my $countryCode = ($request->{'countryCode'}) ? $request->{'countryCode'} : undef;
                              my $phoneNumber = ($request->{'phoneNumber'}) ? $request->{'phoneNumber'} : undef;
                              my $countryCodeHint = ($request->{'countryCodeHint'}) ? $request->{'countryCodeHint'} : undef;
                              return $self->{impl}->normalizePhoneNumber($countryCode, $phoneNumber, $countryCodeHint);
                            }

sub respondE2EELoginRequest{
                              my ($self, $request) = @_;

                              my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                              my $publicKey = ($request->{'publicKey'}) ? $request->{'publicKey'} : undef;
                              my $encryptedKeyChain = ($request->{'encryptedKeyChain'}) ? $request->{'encryptedKeyChain'} : undef;
                              my $hashKeyChain = ($request->{'hashKeyChain'}) ? $request->{'hashKeyChain'} : undef;
                              my $errorCode = ($request->{'errorCode'}) ? $request->{'errorCode'} : undef;
                              return $self->{impl}->respondE2EELoginRequest($verifier, $publicKey, $encryptedKeyChain, $hashKeyChain, $errorCode);
                            }

sub confirmE2EELogin{
                              my ($self, $request) = @_;

                              my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                              my $deviceSecret = ($request->{'deviceSecret'}) ? $request->{'deviceSecret'} : undef;
                              return $self->{impl}->confirmE2EELogin($verifier, $deviceSecret);
                            }

sub logoutZ{
                              my ($self, $request) = @_;

                              return $self->{impl}->logoutZ();
                            }

sub loginZ{
                              my ($self, $request) = @_;

                              my $loginRequest = ($request->{'loginRequest'}) ? $request->{'loginRequest'} : undef;
                              return $self->{impl}->loginZ($loginRequest);
                            }

sub issueTokenForAccountMigrationSettings{
                              my ($self, $request) = @_;

                              my $enforce = ($request->{'enforce'}) ? $request->{'enforce'} : undef;
                              return $self->{impl}->issueTokenForAccountMigrationSettings($enforce);
                            }

sub issueTokenForAccountMigration{
                              my ($self, $request) = @_;

                              my $migrationSessionId = ($request->{'migrationSessionId'}) ? $request->{'migrationSessionId'} : undef;
                              return $self->{impl}->issueTokenForAccountMigration($migrationSessionId);
                            }

sub verifyQrcodeWithE2EE{
                              my ($self, $request) = @_;

                              my $verifier = ($request->{'verifier'}) ? $request->{'verifier'} : undef;
                              my $pinCode = ($request->{'pinCode'}) ? $request->{'pinCode'} : undef;
                              my $errorCode = ($request->{'errorCode'}) ? $request->{'errorCode'} : undef;
                              my $publicKey = ($request->{'publicKey'}) ? $request->{'publicKey'} : undef;
                              my $encryptedKeyChain = ($request->{'encryptedKeyChain'}) ? $request->{'encryptedKeyChain'} : undef;
                              my $hashKeyChain = ($request->{'hashKeyChain'}) ? $request->{'hashKeyChain'} : undef;
                              return $self->{impl}->verifyQrcodeWithE2EE($verifier, $pinCode, $errorCode, $publicKey, $encryptedKeyChain, $hashKeyChain);
                            }

package AuthServiceClient;


use base qw(AuthServiceIf);
sub new {
                              my ($classname, $input, $output) = @_;
                              my $self      = {};
                              $self->{input}  = $input;
                              $self->{output} = defined $output ? $output : $input;
                              $self->{seqid}  = 0;
                              return bless($self,$classname);
}

sub normalizePhoneNumber{
  my $self = shift;
  my $countryCode = shift;
  my $phoneNumber = shift;
  my $countryCodeHint = shift;

                                                            $self->send_normalizePhoneNumber($countryCode, $phoneNumber, $countryCodeHint);
                              return $self->recv_normalizePhoneNumber();
}

sub send_normalizePhoneNumber{
  my $self = shift;
  my $countryCode = shift;
  my $phoneNumber = shift;
  my $countryCodeHint = shift;

                              $self->{output}->writeMessageBegin('normalizePhoneNumber', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_normalizePhoneNumber_args();
                              $args->{countryCode} = $countryCode;
                              $args->{phoneNumber} = $phoneNumber;
                              $args->{countryCodeHint} = $countryCodeHint;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_normalizePhoneNumber{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_normalizePhoneNumber_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              die "normalizePhoneNumber failed: unknown result";
}
sub respondE2EELoginRequest{
  my $self = shift;
  my $verifier = shift;
  my $publicKey = shift;
  my $encryptedKeyChain = shift;
  my $hashKeyChain = shift;
  my $errorCode = shift;

                                                            $self->send_respondE2EELoginRequest($verifier, $publicKey, $encryptedKeyChain, $hashKeyChain, $errorCode);
                              $self->recv_respondE2EELoginRequest();
}

sub send_respondE2EELoginRequest{
  my $self = shift;
  my $verifier = shift;
  my $publicKey = shift;
  my $encryptedKeyChain = shift;
  my $hashKeyChain = shift;
  my $errorCode = shift;

                              $self->{output}->writeMessageBegin('respondE2EELoginRequest', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_respondE2EELoginRequest_args();
                              $args->{verifier} = $verifier;
                              $args->{publicKey} = $publicKey;
                              $args->{encryptedKeyChain} = $encryptedKeyChain;
                              $args->{hashKeyChain} = $hashKeyChain;
                              $args->{errorCode} = $errorCode;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_respondE2EELoginRequest{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_respondE2EELoginRequest_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              return;
}
sub confirmE2EELogin{
  my $self = shift;
  my $verifier = shift;
  my $deviceSecret = shift;

                                                            $self->send_confirmE2EELogin($verifier, $deviceSecret);
                              return $self->recv_confirmE2EELogin();
}

sub send_confirmE2EELogin{
  my $self = shift;
  my $verifier = shift;
  my $deviceSecret = shift;

                              $self->{output}->writeMessageBegin('confirmE2EELogin', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_confirmE2EELogin_args();
                              $args->{verifier} = $verifier;
                              $args->{deviceSecret} = $deviceSecret;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_confirmE2EELogin{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_confirmE2EELogin_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              die "confirmE2EELogin failed: unknown result";
}
sub logoutZ{
  my $self = shift;

                                                            $self->send_logoutZ();
                              $self->recv_logoutZ();
}

sub send_logoutZ{
  my $self = shift;

                              $self->{output}->writeMessageBegin('logoutZ', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_logoutZ_args();
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_logoutZ{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_logoutZ_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              return;
}
sub loginZ{
  my $self = shift;
  my $loginRequest = shift;

                                                            $self->send_loginZ($loginRequest);
                              return $self->recv_loginZ();
}

sub send_loginZ{
  my $self = shift;
  my $loginRequest = shift;

                              $self->{output}->writeMessageBegin('loginZ', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_loginZ_args();
                              $args->{loginRequest} = $loginRequest;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_loginZ{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_loginZ_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              die "loginZ failed: unknown result";
}
sub issueTokenForAccountMigrationSettings{
  my $self = shift;
  my $enforce = shift;

                                                            $self->send_issueTokenForAccountMigrationSettings($enforce);
                              return $self->recv_issueTokenForAccountMigrationSettings();
}

sub send_issueTokenForAccountMigrationSettings{
  my $self = shift;
  my $enforce = shift;

                              $self->{output}->writeMessageBegin('issueTokenForAccountMigrationSettings', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_issueTokenForAccountMigrationSettings_args();
                              $args->{enforce} = $enforce;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_issueTokenForAccountMigrationSettings{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_issueTokenForAccountMigrationSettings_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              die "issueTokenForAccountMigrationSettings failed: unknown result";
}
sub issueTokenForAccountMigration{
  my $self = shift;
  my $migrationSessionId = shift;

                                                            $self->send_issueTokenForAccountMigration($migrationSessionId);
                              return $self->recv_issueTokenForAccountMigration();
}

sub send_issueTokenForAccountMigration{
  my $self = shift;
  my $migrationSessionId = shift;

                              $self->{output}->writeMessageBegin('issueTokenForAccountMigration', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_issueTokenForAccountMigration_args();
                              $args->{migrationSessionId} = $migrationSessionId;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_issueTokenForAccountMigration{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_issueTokenForAccountMigration_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              die "issueTokenForAccountMigration failed: unknown result";
}
sub verifyQrcodeWithE2EE{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;
  my $errorCode = shift;
  my $publicKey = shift;
  my $encryptedKeyChain = shift;
  my $hashKeyChain = shift;

                                                            $self->send_verifyQrcodeWithE2EE($verifier, $pinCode, $errorCode, $publicKey, $encryptedKeyChain, $hashKeyChain);
                              return $self->recv_verifyQrcodeWithE2EE();
}

sub send_verifyQrcodeWithE2EE{
  my $self = shift;
  my $verifier = shift;
  my $pinCode = shift;
  my $errorCode = shift;
  my $publicKey = shift;
  my $encryptedKeyChain = shift;
  my $hashKeyChain = shift;

                              $self->{output}->writeMessageBegin('verifyQrcodeWithE2EE', Thrift::TMessageType::CALL, $self->{seqid});
                              my $args = new AuthService_verifyQrcodeWithE2EE_args();
                              $args->{verifier} = $verifier;
                              $args->{pinCode} = $pinCode;
                              $args->{errorCode} = $errorCode;
                              $args->{publicKey} = $publicKey;
                              $args->{encryptedKeyChain} = $encryptedKeyChain;
                              $args->{hashKeyChain} = $hashKeyChain;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_verifyQrcodeWithE2EE{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == Thrift::TMessageType::EXCEPTION) {
                                my $x = new Thrift::TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new AuthService_verifyQrcodeWithE2EE_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              if (defined $result->{e}) {
                                die $result->{e};
                              }
                              die "verifyQrcodeWithE2EE failed: unknown result";
}
package AuthServiceProcessor;

use strict;


sub new {
                                my ($classname, $handler) = @_;
                                my $self      = {};
                                $self->{handler} = $handler;
                                return bless ($self, $classname);
}

sub process {
                                my ($self, $input, $output) = @_;
                                my $rseqid = 0;
                                my $fname  = undef;
                                my $mtype  = 0;

                                $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                my $methodname = 'process_'.$fname;
                                if (!$self->can($methodname)) {
                                  $input->skip(Thrift::TType::STRUCT);
                                  $input->readMessageEnd();
                                  my $x = new Thrift::TApplicationException('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
                                  $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
                                  $x->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  return;
                                }
                                $self->$methodname($rseqid, $input, $output);
                                return 1;
}

sub process_normalizePhoneNumber {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_normalizePhoneNumber_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_normalizePhoneNumber_result();
                                eval {
                                  $result->{success} = $self->{handler}->normalizePhoneNumber($args->countryCode, $args->phoneNumber, $args->countryCodeHint);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('normalizePhoneNumber', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('normalizePhoneNumber', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_respondE2EELoginRequest {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_respondE2EELoginRequest_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_respondE2EELoginRequest_result();
                                eval {
                                  $self->{handler}->respondE2EELoginRequest($args->verifier, $args->publicKey, $args->encryptedKeyChain, $args->hashKeyChain, $args->errorCode);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('respondE2EELoginRequest', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('respondE2EELoginRequest', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_confirmE2EELogin {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_confirmE2EELogin_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_confirmE2EELogin_result();
                                eval {
                                  $result->{success} = $self->{handler}->confirmE2EELogin($args->verifier, $args->deviceSecret);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('confirmE2EELogin', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('confirmE2EELogin', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_logoutZ {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_logoutZ_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_logoutZ_result();
                                eval {
                                  $self->{handler}->logoutZ();
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('logoutZ', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('logoutZ', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_loginZ {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_loginZ_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_loginZ_result();
                                eval {
                                  $result->{success} = $self->{handler}->loginZ($args->loginRequest);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('loginZ', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('loginZ', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_issueTokenForAccountMigrationSettings {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_issueTokenForAccountMigrationSettings_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_issueTokenForAccountMigrationSettings_result();
                                eval {
                                  $result->{success} = $self->{handler}->issueTokenForAccountMigrationSettings($args->enforce);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('issueTokenForAccountMigrationSettings', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('issueTokenForAccountMigrationSettings', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_issueTokenForAccountMigration {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_issueTokenForAccountMigration_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_issueTokenForAccountMigration_result();
                                eval {
                                  $result->{success} = $self->{handler}->issueTokenForAccountMigration($args->migrationSessionId);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('issueTokenForAccountMigration', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('issueTokenForAccountMigration', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_verifyQrcodeWithE2EE {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new AuthService_verifyQrcodeWithE2EE_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new AuthService_verifyQrcodeWithE2EE_result();
                                eval {
                                  $result->{success} = $self->{handler}->verifyQrcodeWithE2EE($args->verifier, $args->pinCode, $args->errorCode, $args->publicKey, $args->encryptedKeyChain, $args->hashKeyChain);
                                }; if( UNIVERSAL::isa($@,'TalkException') ){ 
                                  $result->{e} = $@;
                                  $@ = undef;
                                }
                                if ($@) {
                                  $@ =~ s/^\s+|\s+$//g;
                                  my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
                                  $output->writeMessageBegin('verifyQrcodeWithE2EE', Thrift::TMessageType::EXCEPTION, $seqid);
                                  $err->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  $@ = undef;
                                  return;
                                }
                                $output->writeMessageBegin('verifyQrcodeWithE2EE', Thrift::TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

1;
